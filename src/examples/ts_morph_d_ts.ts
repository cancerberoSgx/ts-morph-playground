export const ts_morph_d_ts: string =
  "import * as ts from \"typescript\";\r\nimport { SyntaxKind, CompilerOptions, EmitHint, ScriptKind, NewLineKind, LanguageVariant, ScriptTarget, TypeFlags, ObjectFlags, SymbolFlags, TypeFormatFlags, DiagnosticCategory, EditorSettings, ModuleResolutionKind } from \"typescript\";\r\nimport { CodeBlockWriter } from \"./code-block-writer\";\r\n\r\nexport declare class Directory {\r\n    private __context;\r\n    private _path;\r\n    private _pathParts;\r\n    private constructor();\r\n    /**\r\n     * Checks if this directory is an ancestor of the provided directory.\r\n     * @param possibleDescendant - Directory or source file that's a possible descendant.\r\n     */\r\n    isAncestorOf(possibleDescendant: Directory | SourceFile): boolean;\r\n    /**\r\n     * Checks if this directory is a descendant of the provided directory.\r\n     * @param possibleAncestor - Directory or source file that's a possible ancestor.\r\n     */\r\n    isDescendantOf(possibleAncestor: Directory): boolean;\r\n    /**\r\n     * Gets the path to the directory.\r\n     */\r\n    getPath(): string;\r\n    /**\r\n     * Gets the directory path's base name.\r\n     */\r\n    getBaseName(): string;\r\n    /**\r\n     * Gets the parent directory or throws if it doesn't exist or was never added to the project.\r\n     */\r\n    getParentOrThrow(): Directory;\r\n    /**\r\n     * Gets the parent directory if it exists and was added to the project.\r\n     */\r\n    getParent(): Directory | undefined;\r\n    /**\r\n     * Gets a child directory with the specified path or throws if not found.\r\n     * @param path - Relative path from this directory or absolute path.\r\n     */\r\n    getDirectoryOrThrow(path: string): Directory;\r\n    /**\r\n     * Gets a child directory by the specified condition or throws if not found.\r\n     * @param condition - Condition to check the directory with.\r\n     */\r\n    getDirectoryOrThrow(condition: (directory: Directory) => boolean): Directory;\r\n    /**\r\n     * Gets a directory with the specified path or undefined if not found.\r\n     * @param path - Relative path from this directory or absolute path.\r\n     */\r\n    getDirectory(path: string): Directory | undefined;\r\n    /**\r\n     * Gets a child directory by the specified condition or undefined if not found.\r\n     * @param condition - Condition to check the directory with.\r\n     */\r\n    getDirectory(condition: (directory: Directory) => boolean): Directory | undefined;\r\n    /**\r\n     * Gets a child source file with the specified path or throws if not found.\r\n     * @param path - Relative or absolute path to the file.\r\n     */\r\n    getSourceFileOrThrow(path: string): SourceFile;\r\n    /**\r\n     * Gets a child source file by the specified condition or throws if not found.\r\n     * @param condition - Condition to check the source file with.\r\n     */\r\n    getSourceFileOrThrow(condition: (sourceFile: SourceFile) => boolean): SourceFile;\r\n    /**\r\n     * Gets a child source file with the specified path or undefined if not found.\r\n     * @param path - Relative or absolute path to the file.\r\n     */\r\n    getSourceFile(path: string): SourceFile | undefined;\r\n    /**\r\n     * Gets a child source file by the specified condition or undefined if not found.\r\n     * @param condition - Condition to check the source file with.\r\n     */\r\n    getSourceFile(condition: (sourceFile: SourceFile) => boolean): SourceFile | undefined;\r\n    /**\r\n     * Gets the child directories.\r\n     */\r\n    getDirectories(): Directory[];\r\n    /**\r\n     * Gets the source files within this directory.\r\n     */\r\n    getSourceFiles(): SourceFile[];\r\n    /**\r\n     * Gets the source files in the current directory and all the descendant directories.\r\n     */\r\n    getDescendantSourceFiles(): SourceFile[];\r\n    /**\r\n     * Gets the descendant directories.\r\n     */\r\n    getDescendantDirectories(): Directory[];\r\n    /**\r\n     * Add source files based on file globs.\r\n     * @param fileGlobs - File glob or globs to add files based on.\r\n     * @returns The matched source files.\r\n     */\r\n    addExistingSourceFiles(fileGlobs: string | ReadonlyArray<string>): SourceFile[];\r\n    /**\r\n     * Adds an existing directory from the relative path or directory name, or returns undefined if it doesn't exist.\r\n     *\r\n     * Will return the directory if it was already added.\r\n     * @param dirPath - Directory name or path to the directory that should be added.\r\n     * @param options - Options.\r\n     */\r\n    addExistingDirectoryIfExists(dirPath: string, options?: DirectoryAddOptions): Directory | undefined;\r\n    /**\r\n     * Adds an existing directory from the relative path or directory name, or throws if it doesn't exist.\r\n     *\r\n     * Will return the directory if it was already added.\r\n     * @param dirPath - Directory name or path to the directory that should be added.\r\n     * @throws DirectoryNotFoundError if the directory does not exist.\r\n     */\r\n    addExistingDirectory(dirPath: string, options?: DirectoryAddOptions): Directory;\r\n    /**\r\n     * Creates a directory if it doesn't exist.\r\n     * @param dirPath - Relative or absolute path to the directory that should be created.\r\n     */\r\n    createDirectory(dirPath: string): Directory;\r\n    /**\r\n     * Creates a source file, relative to this directory.\r\n     *\r\n     * Note: The file will not be created and saved to the file system until .save() is called on the source file.\r\n     * @param relativeFilePath - Relative file path of the source file to create.\r\n     * @param sourceFileText - Text, structure, or writer function to create the source file text with.\r\n     * @param options - Options.\r\n     * @throws - InvalidOperationError if a source file already exists at the provided file name.\r\n     */\r\n    createSourceFile(relativeFilePath: string, sourceFileText?: string | SourceFileStructure | WriterFunction, options?: SourceFileCreateOptions): SourceFile;\r\n    /**\r\n     * Adds an existing source file, relative to this directory, or returns undefined.\r\n     *\r\n     * Will return the source file if it was already added.\r\n     * @param relativeFilePath - Relative file path to add.\r\n     */\r\n    addExistingSourceFileIfExists(relativeFilePath: string): SourceFile | undefined;\r\n    /**\r\n     * Adds an existing source file, relative to this directory, or throws if it doesn't exist.\r\n     *\r\n     * Will return the source file if it was already added.\r\n     * @param relativeFilePath - Relative file path to add.\r\n     * @throws FileNotFoundError when the file doesn't exist.\r\n     */\r\n    addExistingSourceFile(relativeFilePath: string): SourceFile;\r\n    /**\r\n     * Emits the files in the directory.\r\n     * @param options - Options for emitting.\r\n     */\r\n    emit(options?: {\r\n        emitOnlyDtsFiles?: boolean;\r\n        outDir?: string;\r\n        declarationDir?: string;\r\n    }): Promise<DirectoryEmitResult>;\r\n    /**\r\n     * Emits the files in the directory synchronously.\r\n     *\r\n     * Remarks: This might be very slow compared to the asynchronous version if there are a lot of files.\r\n     * @param options - Options for emitting.\r\n     */\r\n    emitSync(options?: {\r\n        emitOnlyDtsFiles?: boolean;\r\n        outDir?: string;\r\n        declarationDir?: string;\r\n    }): DirectoryEmitResult;\r\n    private _emitInternal;\r\n    /**\r\n     * Copies the directory to a subdirectory of the specified directory.\r\n     * @param dirPathOrDirectory Directory path or directory object to copy the directory to.\r\n     * @param options Options for copying.\r\n     * @returns The new copied directory.\r\n     */\r\n    copyToDirectory(dirPathOrDirectory: string | Directory, options?: DirectoryCopyOptions): Directory;\r\n    /**\r\n     * Copies the directory to a new directory.\r\n     * @param relativeOrAbsolutePath - The relative or absolute path to the new directory.\r\n     * @param options - Options.\r\n     * @returns The directory the copy was made to.\r\n     */\r\n    copy(relativeOrAbsolutePath: string, options?: DirectoryCopyOptions): Directory;\r\n    /**\r\n     * Immediately copies the directory to the specified path asynchronously.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     * @remarks If includeTrackedFiles is true, then it will execute the pending operations in the current directory.\r\n     */\r\n    copyImmediately(relativeOrAbsolutePath: string, options?: DirectoryCopyOptions): Promise<Directory>;\r\n    /**\r\n     * Immediately copies the directory to the specified path synchronously.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     * @remarks If includeTrackedFiles is true, then it will execute the pending operations in the current directory.\r\n     */\r\n    copyImmediatelySync(relativeOrAbsolutePath: string, options?: DirectoryCopyOptions): Directory;\r\n    /**\r\n     * Moves the directory to a subdirectory of the specified directory.\r\n     * @param dirPathOrDirectory Directory path or directory object to move the directory to.\r\n     * @param options Options for moving.\r\n     */\r\n    moveToDirectory(dirPathOrDirectory: string | Directory, options?: DirectoryMoveOptions): this;\r\n    /**\r\n     * Moves the directory to a new path.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     */\r\n    move(relativeOrAbsolutePath: string, options?: DirectoryMoveOptions): this;\r\n    /**\r\n     * Immediately moves the directory to a new path asynchronously.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     */\r\n    moveImmediately(relativeOrAbsolutePath: string, options?: DirectoryMoveOptions): Promise<this>;\r\n    /**\r\n     * Immediately moves the directory to a new path synchronously.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     */\r\n    moveImmediatelySync(relativeOrAbsolutePath: string, options?: DirectoryMoveOptions): this;\r\n    /**\r\n     * Queues a deletion of the directory to the file system.\r\n     *\r\n     * The directory will be deleted when calling ast.save(). If you wish to delete the file immediately, then use deleteImmediately().\r\n     */\r\n    delete(): void;\r\n    /**\r\n     * Asyncronously deletes the directory and all its descendants from the file system.\r\n     */\r\n    deleteImmediately(): Promise<void>;\r\n    /**\r\n     * Synchronously deletes the directory and all its descendants from the file system.\r\n     */\r\n    deleteImmediatelySync(): void;\r\n    /**\r\n     * Forgets the directory and all its descendants from the Project.\r\n     *\r\n     * Note: Does not delete the directory from the file system.\r\n     */\r\n    forget(): void;\r\n    /**\r\n     * Asynchronously saves the directory and all the unsaved source files to the disk.\r\n     */\r\n    save(): Promise<void>;\r\n    /**\r\n     * Synchronously saves the directory and all the unsaved source files to the disk.\r\n     */\r\n    saveSync(): void;\r\n    /**\r\n     * Gets the relative path to another source file.\r\n     * @param sourceFile - Source file.\r\n     */\r\n    getRelativePathTo(sourceFile: SourceFile): string;\r\n    /**\r\n     * Gets the relative path to another directory.\r\n     * @param directory - Directory.\r\n     */\r\n    getRelativePathTo(directory: Directory): string;\r\n    /**\r\n     * Gets the relative path to the specified source file as a module specifier.\r\n     * @param sourceFile - Source file.\r\n     */\r\n    getRelativePathAsModuleSpecifierTo(sourceFile: SourceFile): string;\r\n    /**\r\n     * Gets the relative path to the specified directory as a module specifier.\r\n     * @param directory - Directory.\r\n     */\r\n    getRelativePathAsModuleSpecifierTo(directory: Directory): string;\r\n    /**\r\n     * Gets if the directory was forgotten.\r\n     */\r\n    wasForgotten(): boolean;\r\n}\r\n\r\nexport interface DirectoryAddOptions {\r\n    /**\r\n     * Whether to also recursively add all the directory's descendant directories.\r\n     * @remarks Defaults to false.\r\n     */\r\n    recursive?: boolean;\r\n}\r\n\r\nexport interface DirectoryCopyOptions extends SourceFileCopyOptions {\r\n    /**\r\n     * Includes all the files in the directory and sub-directory when copying.\r\n     * @remarks - Defaults to true.\r\n     */\r\n    includeUntrackedFiles?: boolean;\r\n}\r\nexport declare class DirectoryEmitResult {\r\n    private readonly _emitSkipped;\r\n    private readonly _outputFilePaths;\r\n    private constructor();\r\n    /**\r\n     * Gets if the emit was skipped.\r\n     */\r\n    getEmitSkipped(): boolean;\r\n    /**\r\n     * Gets the output file paths.\r\n     */\r\n    getOutputFilePaths(): string[];\r\n}\r\n\r\nexport interface DirectoryMoveOptions extends SourceFileMoveOptions {\r\n}\r\nexport interface FileSystemHost {\r\n    delete(path: string): Promise<void>;\r\n    deleteSync(path: string): void;\r\n    readDirSync(dirPath: string): string[];\r\n    readFile(filePath: string, encoding?: string): Promise<string>;\r\n    readFileSync(filePath: string, encoding?: string): string;\r\n    writeFile(filePath: string, fileText: string): Promise<void>;\r\n    writeFileSync(filePath: string, fileText: string): void;\r\n    mkdir(dirPath: string): Promise<void>;\r\n    mkdirSync(dirPath: string): void;\r\n    move(srcPath: string, destPath: string): Promise<void>;\r\n    moveSync(srcPath: string, destPath: string): void;\r\n    copy(srcPath: string, destPath: string): Promise<void>;\r\n    copySync(srcPath: string, destPath: string): void;\r\n    fileExists(filePath: string): Promise<boolean>;\r\n    fileExistsSync(filePath: string): boolean;\r\n    directoryExists(dirPath: string): Promise<boolean>;\r\n    directoryExistsSync(dirPath: string): boolean;\r\n    getCurrentDirectory(): string;\r\n    glob(patterns: ReadonlyArray<string>): string[];\r\n    /** Gets if this file system is case sensitive. Defaults to true if not implemented. */\r\n    isCaseSensitive?(): boolean;\r\n}\r\n\r\nexport interface ProjectOptions {\r\n    /** Compiler options */\r\n    compilerOptions?: CompilerOptions;\r\n    /** File path to the tsconfig.json file */\r\n    tsConfigFilePath?: string;\r\n    /** Whether to add the source files from the specified tsconfig.json or not. Defaults to true. */\r\n    addFilesFromTsConfig?: boolean;\r\n    /** Manipulation settings */\r\n    manipulationSettings?: Partial<ManipulationSettings>;\r\n    /** Skip resolving file dependencies when providing a ts config file path and adding the files from tsconfig. */\r\n    skipFileDependencyResolution?: boolean;\r\n    /** Whether to use a virtual file system. */\r\n    useVirtualFileSystem?: boolean;\r\n    /**\r\n     * Optional file system host. Useful for mocking access to the file system.\r\n     * @remarks Consider using `useVirtualFileSystem` instead.\r\n     */\r\n    fileSystem?: FileSystemHost;\r\n}\r\n\r\n/**\r\n * Project that holds source files.\r\n */\r\nexport declare class Project {\r\n    /**\r\n     * Initializes a new instance.\r\n     * @param options - Optional options.\r\n     */\r\n    constructor(options?: ProjectOptions);\r\n    /** Gets the manipulation settings. */\r\n    readonly manipulationSettings: ManipulationSettingsContainer;\r\n    /** Gets the compiler options for modification. */\r\n    readonly compilerOptions: CompilerOptionsContainer;\r\n    /**\r\n     * Adds the source files the project's source files depend on to the project.\r\n     * @returns The added source files.\r\n     * @remarks\r\n     * * This should be done after source files are added to the project, preferably once to\r\n     * avoid doing more work than necessary.\r\n     * * This is done by default when creating a Project and providing a tsconfig.json and\r\n     * not specifying to not add the source files.\r\n     */\r\n    resolveSourceFileDependencies(): SourceFile[];\r\n    /**\r\n     * Adds an existing directory from the path or returns undefined if it doesn't exist.\r\n     *\r\n     * Will return the directory if it was already added.\r\n     * @param dirPath - Path to add the directory at.\r\n     * @param options - Options.\r\n     */\r\n    addExistingDirectoryIfExists(dirPath: string, options?: DirectoryAddOptions): Directory | undefined;\r\n    /**\r\n     * Adds an existing directory from the path or throws if it doesn't exist.\r\n     *\r\n     * Will return the directory if it was already added.\r\n     * @param dirPath - Path to add the directory at.\r\n     * @param options - Options.\r\n     * @throws DirectoryNotFoundError when the directory does not exist.\r\n     */\r\n    addExistingDirectory(dirPath: string, options?: DirectoryAddOptions): Directory;\r\n    /**\r\n     * Creates a directory at the specified path.\r\n     * @param dirPath - Path to create the directory at.\r\n     */\r\n    createDirectory(dirPath: string): Directory;\r\n    /**\r\n     * Gets a directory by the specified path or throws if it doesn't exist.\r\n     * @param dirPath - Path to create the directory at.\r\n     */\r\n    getDirectoryOrThrow(dirPath: string): Directory;\r\n    /**\r\n     * Gets a directory by the specified path or returns undefined if it doesn't exist.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    getDirectory(dirPath: string): Directory | undefined;\r\n    /**\r\n     * Gets all the directories.\r\n     */\r\n    getDirectories(): Directory[];\r\n    /**\r\n     * Gets the directories without a parent.\r\n     */\r\n    getRootDirectories(): Directory[];\r\n    /**\r\n     * Adds source files based on file globs.\r\n     * @param fileGlobs - File glob or globs to add files based on.\r\n     * @returns The matched source files.\r\n     */\r\n    addExistingSourceFiles(fileGlobs: string | ReadonlyArray<string>): SourceFile[];\r\n    /**\r\n     * Adds a source file from a file path if it exists or returns undefined.\r\n     *\r\n     * Will return the source file if it was already added.\r\n     * @param filePath - File path to get the file from.\r\n     */\r\n    addExistingSourceFileIfExists(filePath: string): SourceFile | undefined;\r\n    /**\r\n     * Adds an existing source file from a file path or throws if it doesn't exist.\r\n     *\r\n     * Will return the source file if it was already added.\r\n     * @param filePath - File path to get the file from.\r\n     * @throws FileNotFoundError when the file is not found.\r\n     */\r\n    addExistingSourceFile(filePath: string): SourceFile;\r\n    /**\r\n     * Adds all the source files from the specified tsconfig.json.\r\n     *\r\n     * Note that this is done by default when specifying a tsconfig file in the constructor and not explicitly setting the\r\n     * addFilesFromTsConfig option to false.\r\n     * @param tsConfigFilePath - File path to the tsconfig.json file.\r\n     */\r\n    addSourceFilesFromTsConfig(tsConfigFilePath: string): SourceFile[];\r\n    /**\r\n     * Creates a source file at the specified file path with the specified text.\r\n     *\r\n     * Note: The file will not be created and saved to the file system until .save() is called on the source file.\r\n     * @param filePath - File path of the source file.\r\n     * @param sourceFileText - Text, structure, or writer function for the source file text.\r\n     * @param options - Options.\r\n     * @throws - InvalidOperationError if a source file already exists at the provided file path.\r\n     */\r\n    createSourceFile(filePath: string, sourceFileText?: string | SourceFileStructure | WriterFunction, options?: SourceFileCreateOptions): SourceFile;\r\n    /**\r\n     * Removes a source file from the AST.\r\n     * @param sourceFile - Source file to remove.\r\n     * @returns True if removed.\r\n     */\r\n    removeSourceFile(sourceFile: SourceFile): boolean;\r\n    /**\r\n     * Gets a source file by a file name or file path. Throws an error if it doesn't exist.\r\n     * @param fileNameOrPath - File name or path that the path could end with or equal.\r\n     */\r\n    getSourceFileOrThrow(fileNameOrPath: string): SourceFile;\r\n    /**\r\n     * Gets a source file by a search function. Throws an erorr if it doesn't exist.\r\n     * @param searchFunction - Search function.\r\n     */\r\n    getSourceFileOrThrow(searchFunction: (file: SourceFile) => boolean): SourceFile;\r\n    /**\r\n     * Gets a source file by a file name or file path. Returns undefined if none exists.\r\n     * @param fileNameOrPath - File name or path that the path could end with or equal.\r\n     */\r\n    getSourceFile(fileNameOrPath: string): SourceFile | undefined;\r\n    /**\r\n     * Gets a source file by a search function. Returns undefined if none exists.\r\n     * @param searchFunction - Search function.\r\n     */\r\n    getSourceFile(searchFunction: (file: SourceFile) => boolean): SourceFile | undefined;\r\n    /**\r\n     * Gets all the source files added to the project.\r\n     * @param globPattern - Glob pattern for filtering out the source files.\r\n     */\r\n    getSourceFiles(): SourceFile[];\r\n    /**\r\n     * Gets all the source files added to the project that match a pattern.\r\n     * @param globPattern - Glob pattern for filtering out the source files.\r\n     */\r\n    getSourceFiles(globPattern: string): SourceFile[];\r\n    /**\r\n     * Gets all the source files added to the project that match the passed in patterns.\r\n     * @param globPatterns - Glob patterns for filtering out the source files.\r\n     */\r\n    getSourceFiles(globPatterns: ReadonlyArray<string>): SourceFile[];\r\n    /**\r\n     * Gets the specified ambient module symbol or returns undefined if not found.\r\n     * @param moduleName - The ambient module name with or without quotes.\r\n     */\r\n    getAmbientModule(moduleName: string): Symbol | undefined;\r\n    /**\r\n     * Gets the specified ambient module symbol or throws if not found.\r\n     * @param moduleName - The ambient module name with or without quotes.\r\n     */\r\n    getAmbientModuleOrThrow(moduleName: string): Symbol;\r\n    /**\r\n     * Gets the ambient module symbols (ex. modules in the @types folder or node_modules).\r\n     */\r\n    getAmbientModules(): Symbol[];\r\n    /**\r\n     * Saves all the unsaved source files to the file system and deletes all deleted files.\r\n     */\r\n    save(): Promise<void>;\r\n    /**\r\n     * Synchronously saves all the unsaved source files to the file system and deletes all deleted files.\r\n     *\r\n     * Remarks: This might be very slow compared to the asynchronous version if there are a lot of files.\r\n     */\r\n    saveSync(): void;\r\n    /**\r\n     * Enables logging to the console.\r\n     * @param enabled - Enabled.\r\n     */\r\n    enableLogging(enabled?: boolean): void;\r\n    private _getUnsavedSourceFiles;\r\n    /**\r\n     * Gets the pre-emit diagnostics.\r\n     */\r\n    getPreEmitDiagnostics(): Diagnostic[];\r\n    /**\r\n     * Gets the language service.\r\n     */\r\n    getLanguageService(): LanguageService;\r\n    /**\r\n     * Gets the program.\r\n     */\r\n    getProgram(): Program;\r\n    /**\r\n     * Gets the type checker.\r\n     */\r\n    getTypeChecker(): TypeChecker;\r\n    /**\r\n     * Gets the file system.\r\n     */\r\n    getFileSystem(): FileSystemHost;\r\n    /**\r\n     * Emits all the source files.\r\n     * @param emitOptions - Optional emit options.\r\n     */\r\n    emit(emitOptions?: EmitOptions): EmitResult;\r\n    /**\r\n     * Emits all the source files to memory.\r\n     * @param emitOptions - Optional emit options.\r\n     */\r\n    emitToMemory(emitOptions?: EmitOptions): MemoryEmitResult;\r\n    /**\r\n     * Gets the compiler options.\r\n     */\r\n    getCompilerOptions(): CompilerOptions;\r\n    /**\r\n     * Creates a writer with the current manipulation settings.\r\n     * @remarks Generally it's best to use a provided writer, but this may be useful in some scenarios.\r\n     */\r\n    createWriter(): CodeBlockWriter;\r\n    /**\r\n     * Forgets the nodes created in the scope of the passed in block.\r\n     *\r\n     * This is an advanced method that can be used to easily \"forget\" all the nodes created within the scope of the block.\r\n     * @param block - Block of code to run.\r\n     */\r\n    forgetNodesCreatedInBlock(block: (remember: (...node: Node[]) => void) => void): void;\r\n    /**\r\n     * Forgets the nodes created in the scope of the passed in block asynchronously.\r\n     *\r\n     * This is an advanced method that can be used to easily \"forget\" all the nodes created within the scope of the block.\r\n     * @param block - Block of code to run.\r\n     */\r\n    forgetNodesCreatedInBlock(block: (remember: (...node: Node[]) => void) => Promise<void>): void;\r\n    /**\r\n     * Formats an array of diagnostics with their color and context into a string.\r\n     * @param diagnostics - Diagnostics to get a string of.\r\n     * @param options - Collection of options. For exmaple, the new line character to use (defaults to the OS' new line character).\r\n     */\r\n    formatDiagnosticsWithColorAndContext(diagnostics: ReadonlyArray<Diagnostic>, opts?: {\r\n        newLineChar?: \"\\n\" | \"\\r\\n\";\r\n    }): string;\r\n    /**\r\n     * Applies the given file text changes to this project. This modifies and possibly creates new SourceFiles.\r\n     *\r\n     * WARNING: This will forget any previously navigated descendant nodes of changed files. It's best to do\r\n     * this when you're all done.\r\n     * @param fileTextChanges - Collections of file changes to apply to this project.\r\n     * @param options - Options for applying the text changes.\r\n     */\r\n    applyFileTextChanges(fileTextChanges: ReadonlyArray<FileTextChanges>, options?: {\r\n        overwrite?: boolean;\r\n    }): void;\r\n}\r\n\r\nexport interface SourceFileCreateOptions {\r\n    overwrite?: boolean;\r\n}\r\n\r\nexport declare type Constructor<T> = new (...args: any[]) => T;\r\n\r\nexport declare type WriterFunction = (writer: CodeBlockWriter) => void;\r\n\r\n/**\r\n * Creates a wrapped node from a compiler node.\r\n * @param node - Node to create a wrapped node from.\r\n * @param info - Info for creating the wrapped node.\r\n */\r\nexport declare function createWrappedNode<T extends ts.Node = ts.Node>(node: T, opts?: CreateWrappedNodeOptions): CompilerNodeToWrappedType<T>;\r\n\r\nexport interface CreateWrappedNodeOptions {\r\n    /**\r\n     * Compiler options.\r\n     */\r\n    compilerOptions?: CompilerOptions;\r\n    /**\r\n     * Optional source file of the node. Will make it not bother going up the tree to find the source file.\r\n     */\r\n    sourceFile?: ts.SourceFile;\r\n    /**\r\n     * Type checker.\r\n     */\r\n    typeChecker?: ts.TypeChecker;\r\n}\r\n\r\n/**\r\n * Prints the provided node using the compiler's printer.\r\n * @param node - Compiler node.\r\n * @param options - Options.\r\n * @remarks If the node was not constructed with the compiler API factory methods and the node\r\n * does not have parents set, then use the other overload that accepts a source file.\r\n */\r\nexport declare function printNode(node: ts.Node, options?: PrintNodeOptions): string;\r\n\r\n/**\r\n * Prints the provided node using the compiler's printer.\r\n * @param node - Compiler node.\r\n * @param sourceFile - Compiler source file.\r\n * @param options - Options.\r\n */\r\nexport declare function printNode(node: ts.Node, sourceFile: ts.SourceFile, options?: PrintNodeOptions): string;\r\n\r\n/**\r\n * Options for printing a node.\r\n */\r\nexport interface PrintNodeOptions {\r\n    /**\r\n     * Whether to remove comments or not.\r\n     */\r\n    removeComments?: boolean;\r\n    /**\r\n     * New line kind.\r\n     *\r\n     * Defaults to line feed.\r\n     */\r\n    newLineKind?: NewLineKind;\r\n    /**\r\n     * From the compiler api: \"A value indicating the purpose of a node. This is primarily used to\r\n     * distinguish between an `Identifier` used in an expression position, versus an\r\n     * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you\r\n     * should just pass `Unspecified`.\"\r\n     *\r\n     * Defaults to `Unspecified`.\r\n     */\r\n    emitHint?: EmitHint;\r\n    /**\r\n     * The script kind.\r\n     *\r\n     * @remarks This is only useful when passing in a compiler node that was constructed\r\n     * with the compiler API factory methods.\r\n     *\r\n     * Defaults to TSX.\r\n     */\r\n    scriptKind?: ScriptKind;\r\n}\r\n\r\nexport declare type SourceFileReferencingNodes = ImportDeclaration | ExportDeclaration | ImportEqualsDeclaration | CallExpression;\r\n\r\nexport interface CompilerOptionsFromTsConfigOptions {\r\n    encoding?: string;\r\n    fileSystem?: FileSystemHost;\r\n}\r\n\r\nexport interface CompilerOptionsFromTsConfigResult {\r\n    options: CompilerOptions;\r\n    errors: Diagnostic[];\r\n}\r\n\r\n/**\r\n * Gets the compiler options from a specified tsconfig.json\r\n * @param filePath - File path to the tsconfig.json.\r\n * @param options - Options.\r\n */\r\nexport declare function getCompilerOptionsFromTsConfig(filePath: string, options?: CompilerOptionsFromTsConfigOptions): CompilerOptionsFromTsConfigResult;\r\n\r\n/**\r\n * Type guards for checking the type of a node.\r\n */\r\nexport declare class TypeGuards {\r\n    private constructor();\r\n    /**\r\n     * Gets if the node has an expression.\r\n     * @param node - Node to check.\r\n     */\r\n    static hasExpression(node: Node): node is Node & {\r\n        getExpression(): Expression;\r\n    };\r\n    /**\r\n     * Gets if the node has a name.\r\n     * @param node - Node to check.\r\n     */\r\n    static hasName(node: Node): node is Node & {\r\n        getName(): string;\r\n        getNameNode(): Node;\r\n    };\r\n    /**\r\n     * Gets if the node has a body.\r\n     * @param node - Node to check.\r\n     */\r\n    static hasBody(node: Node): node is Node & {\r\n        getBody(): Node;\r\n    };\r\n    /**\r\n     * Gets if the node is an AbstractableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isAbstractableNode(node: Node): node is AbstractableNode & AbstractableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an AmbientableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isAmbientableNode(node: Node): node is AmbientableNode & AmbientableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an AnyKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isAnyKeyword(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is an ArgumentedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isArgumentedNode(node: Node): node is ArgumentedNode & ArgumentedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an ArrayBindingPattern.\r\n     * @param node - Node to check.\r\n     */\r\n    static isArrayBindingPattern(node: Node): node is ArrayBindingPattern;\r\n    /**\r\n     * Gets if the node is an ArrayLiteralExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;\r\n    /**\r\n     * Gets if the node is an ArrayTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isArrayTypeNode(node: Node): node is ArrayTypeNode;\r\n    /**\r\n     * Gets if the node is an ArrowFunction.\r\n     * @param node - Node to check.\r\n     */\r\n    static isArrowFunction(node: Node): node is ArrowFunction;\r\n    /**\r\n     * Gets if the node is an AsExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isAsExpression(node: Node): node is AsExpression;\r\n    /**\r\n     * Gets if the node is an AsyncableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isAsyncableNode(node: Node): node is AsyncableNode & AsyncableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an AwaitExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isAwaitExpression(node: Node): node is AwaitExpression;\r\n    /**\r\n     * Gets if the node is an AwaitableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isAwaitableNode(node: Node): node is AwaitableNode & AwaitableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a BinaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBinaryExpression(node: Node): node is BinaryExpression;\r\n    /**\r\n     * Gets if the node is a BindingElement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBindingElement(node: Node): node is BindingElement;\r\n    /**\r\n     * Gets if the node is a BindingNamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBindingNamedNode(node: Node): node is BindingNamedNode & BindingNamedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a Block.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBlock(node: Node): node is Block;\r\n    /**\r\n     * Gets if the node is a BodiedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBodiedNode(node: Node): node is BodiedNode & BodiedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a BodyableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBodyableNode(node: Node): node is BodyableNode & BodyableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a BooleanKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBooleanKeyword(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is a BooleanLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBooleanLiteral(node: Node): node is BooleanLiteral;\r\n    /**\r\n     * Gets if the node is a BreakStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isBreakStatement(node: Node): node is BreakStatement;\r\n    /**\r\n     * Gets if the node is a CallExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isCallExpression(node: Node): node is CallExpression;\r\n    /**\r\n     * Gets if the node is a CallSignatureDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;\r\n    /**\r\n     * Gets if the node is a CaseBlock.\r\n     * @param node - Node to check.\r\n     */\r\n    static isCaseBlock(node: Node): node is CaseBlock;\r\n    /**\r\n     * Gets if the node is a CaseClause.\r\n     * @param node - Node to check.\r\n     */\r\n    static isCaseClause(node: Node): node is CaseClause;\r\n    /**\r\n     * Gets if the node is a CatchClause.\r\n     * @param node - Node to check.\r\n     */\r\n    static isCatchClause(node: Node): node is CatchClause;\r\n    /**\r\n     * Gets if the node is a ChildOrderableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isChildOrderableNode(node: Node): node is ChildOrderableNode & ChildOrderableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ClassDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isClassDeclaration(node: Node): node is ClassDeclaration;\r\n    /**\r\n     * Gets if the node is a ClassExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isClassExpression(node: Node): node is ClassExpression;\r\n    /**\r\n     * Gets if the node is a ClassLikeDeclarationBase.\r\n     * @param node - Node to check.\r\n     */\r\n    static isClassLikeDeclarationBase(node: Node): node is ClassLikeDeclarationBase & ClassLikeDeclarationBaseExtensionType;\r\n    /**\r\n     * Gets if the node is a CommaListExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isCommaListExpression(node: Node): node is CommaListExpression;\r\n    /**\r\n     * Gets if the node is a ComputedPropertyName.\r\n     * @param node - Node to check.\r\n     */\r\n    static isComputedPropertyName(node: Node): node is ComputedPropertyName;\r\n    /**\r\n     * Gets if the node is a ConditionalExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isConditionalExpression(node: Node): node is ConditionalExpression;\r\n    /**\r\n     * Gets if the node is a ConstructSignatureDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;\r\n    /**\r\n     * Gets if the node is a ConstructorDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isConstructorDeclaration(node: Node): node is ConstructorDeclaration;\r\n    /**\r\n     * Gets if the node is a ConstructorTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isConstructorTypeNode(node: Node): node is ConstructorTypeNode;\r\n    /**\r\n     * Gets if the node is a ContinueStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isContinueStatement(node: Node): node is ContinueStatement;\r\n    /**\r\n     * Gets if the node is a DebuggerStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isDebuggerStatement(node: Node): node is DebuggerStatement;\r\n    /**\r\n     * Gets if the node is a DeclarationNamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isDeclarationNamedNode(node: Node): node is DeclarationNamedNode & DeclarationNamedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a DecoratableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isDecoratableNode(node: Node): node is DecoratableNode & DecoratableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a Decorator.\r\n     * @param node - Node to check.\r\n     */\r\n    static isDecorator(node: Node): node is Decorator;\r\n    /**\r\n     * Gets if the node is a DefaultClause.\r\n     * @param node - Node to check.\r\n     */\r\n    static isDefaultClause(node: Node): node is DefaultClause;\r\n    /**\r\n     * Gets if the node is a DeleteExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isDeleteExpression(node: Node): node is DeleteExpression;\r\n    /**\r\n     * Gets if the node is a DoStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isDoStatement(node: Node): node is DoStatement;\r\n    /**\r\n     * Gets if the node is an ElementAccessExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isElementAccessExpression(node: Node): node is ElementAccessExpression;\r\n    /**\r\n     * Gets if the node is an EmptyStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isEmptyStatement(node: Node): node is EmptyStatement;\r\n    /**\r\n     * Gets if the node is an EnumDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isEnumDeclaration(node: Node): node is EnumDeclaration;\r\n    /**\r\n     * Gets if the node is an EnumMember.\r\n     * @param node - Node to check.\r\n     */\r\n    static isEnumMember(node: Node): node is EnumMember;\r\n    /**\r\n     * Gets if the node is an ExclamationTokenableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExclamationTokenableNode(node: Node): node is ExclamationTokenableNode & ExclamationTokenableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an ExportAssignment.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExportAssignment(node: Node): node is ExportAssignment;\r\n    /**\r\n     * Gets if the node is an ExportDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExportDeclaration(node: Node): node is ExportDeclaration;\r\n    /**\r\n     * Gets if the node is an ExportGetableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExportGetableNode(node: Node): node is ExportGetableNode & ExportGetableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an ExportSpecifier.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExportSpecifier(node: Node): node is ExportSpecifier;\r\n    /**\r\n     * Gets if the node is an ExportableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExportableNode(node: Node): node is ExportableNode & ExportableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an Expression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExpression(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is an ExpressionStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExpressionStatement(node: Node): node is ExpressionStatement;\r\n    /**\r\n     * Gets if the node is an ExpressionWithTypeArguments.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;\r\n    /**\r\n     * Gets if the node is an ExpressionedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExpressionedNode(node: Node): node is ExpressionedNode & ExpressionedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an ExtendsClauseableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExtendsClauseableNode(node: Node): node is ExtendsClauseableNode & ExtendsClauseableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is an ExternalModuleReference.\r\n     * @param node - Node to check.\r\n     */\r\n    static isExternalModuleReference(node: Node): node is ExternalModuleReference;\r\n    /**\r\n     * Gets if the node is a FalseKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isFalseKeyword(node: Node): node is BooleanLiteral;\r\n    /**\r\n     * Gets if the node is a ForInStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isForInStatement(node: Node): node is ForInStatement;\r\n    /**\r\n     * Gets if the node is a ForOfStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isForOfStatement(node: Node): node is ForOfStatement;\r\n    /**\r\n     * Gets if the node is a ForStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isForStatement(node: Node): node is ForStatement;\r\n    /**\r\n     * Gets if the node is a FunctionDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isFunctionDeclaration(node: Node): node is FunctionDeclaration;\r\n    /**\r\n     * Gets if the node is a FunctionExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isFunctionExpression(node: Node): node is FunctionExpression;\r\n    /**\r\n     * Gets if the node is a FunctionLikeDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isFunctionLikeDeclaration(node: Node): node is FunctionLikeDeclaration & FunctionLikeDeclarationExtensionType;\r\n    /**\r\n     * Gets if the node is a FunctionOrConstructorTypeNodeBase.\r\n     * @param node - Node to check.\r\n     */\r\n    static isFunctionOrConstructorTypeNodeBase(node: Node): node is FunctionOrConstructorTypeNodeBase;\r\n    /**\r\n     * Gets if the node is a FunctionTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isFunctionTypeNode(node: Node): node is FunctionTypeNode;\r\n    /**\r\n     * Gets if the node is a GeneratorableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isGeneratorableNode(node: Node): node is GeneratorableNode & GeneratorableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a GetAccessorDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;\r\n    /**\r\n     * Gets if the node is a HeritageClause.\r\n     * @param node - Node to check.\r\n     */\r\n    static isHeritageClause(node: Node): node is HeritageClause;\r\n    /**\r\n     * Gets if the node is a HeritageClauseableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isHeritageClauseableNode(node: Node): node is HeritageClauseableNode & HeritageClauseableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a Identifier.\r\n     * @param node - Node to check.\r\n     */\r\n    static isIdentifier(node: Node): node is Identifier;\r\n    /**\r\n     * Gets if the node is a IfStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isIfStatement(node: Node): node is IfStatement;\r\n    /**\r\n     * Gets if the node is a ImplementsClauseableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isImplementsClauseableNode(node: Node): node is ImplementsClauseableNode & ImplementsClauseableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ImportClause.\r\n     * @param node - Node to check.\r\n     */\r\n    static isImportClause(node: Node): node is ImportClause;\r\n    /**\r\n     * Gets if the node is a ImportDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isImportDeclaration(node: Node): node is ImportDeclaration;\r\n    /**\r\n     * Gets if the node is a ImportEqualsDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;\r\n    /**\r\n     * Gets if the node is a ImportExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isImportExpression(node: Node): node is ImportExpression;\r\n    /**\r\n     * Gets if the node is a ImportSpecifier.\r\n     * @param node - Node to check.\r\n     */\r\n    static isImportSpecifier(node: Node): node is ImportSpecifier;\r\n    /**\r\n     * Gets if the node is a ImportTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isImportTypeNode(node: Node): node is ImportTypeNode;\r\n    /**\r\n     * Gets if the node is a IndexSignatureDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;\r\n    /**\r\n     * Gets if the node is a IndexedAccessTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;\r\n    /**\r\n     * Gets if the node is a InitializerExpressionableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isInitializerExpressionableNode(node: Node): node is InitializerExpressionableNode & InitializerExpressionableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a InitializerGetExpressionableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isInitializerGetExpressionableNode(node: Node): node is InitializerGetExpressionableNode & InitializerGetExpressionableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a InitializerSetExpressionableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isInitializerSetExpressionableNode(node: Node): node is InitializerSetExpressionableNode & InitializerSetExpressionableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a InterfaceDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;\r\n    /**\r\n     * Gets if the node is a IntersectionTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;\r\n    /**\r\n     * Gets if the node is a IterationStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isIterationStatement(node: Node): node is IterationStatement;\r\n    /**\r\n     * Gets if the node is a JSDoc.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDoc(node: Node): node is JSDoc;\r\n    /**\r\n     * Gets if the node is a JSDocAugmentsTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;\r\n    /**\r\n     * Gets if the node is a JSDocClassTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocClassTag(node: Node): node is JSDocClassTag;\r\n    /**\r\n     * Gets if the node is a JSDocFunctionType.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocFunctionType(node: Node): node is JSDocFunctionType;\r\n    /**\r\n     * Gets if the node is a JSDocParameterTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocParameterTag(node: Node): node is JSDocParameterTag;\r\n    /**\r\n     * Gets if the node is a JSDocPropertyLikeTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag & JSDocPropertyLikeTagExtensionType;\r\n    /**\r\n     * Gets if the node is a JSDocPropertyTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;\r\n    /**\r\n     * Gets if the node is a JSDocReturnTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocReturnTag(node: Node): node is JSDocReturnTag;\r\n    /**\r\n     * Gets if the node is a JSDocSignature.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocSignature(node: Node): node is JSDocSignature;\r\n    /**\r\n     * Gets if the node is a JSDocTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocTag(node: Node): node is JSDocTag;\r\n    /**\r\n     * Gets if the node is a JSDocType.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocType(node: Node): node is JSDocType;\r\n    /**\r\n     * Gets if the node is a JSDocTypeExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;\r\n    /**\r\n     * Gets if the node is a JSDocTypeTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocTypeTag(node: Node): node is JSDocTypeTag;\r\n    /**\r\n     * Gets if the node is a JSDocTypedefTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;\r\n    /**\r\n     * Gets if the node is a JSDocUnknownTag.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;\r\n    /**\r\n     * Gets if the node is a JSDocableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJSDocableNode(node: Node): node is JSDocableNode & JSDocableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a JsxAttribute.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxAttribute(node: Node): node is JsxAttribute;\r\n    /**\r\n     * Gets if the node is a JsxAttributedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxAttributedNode(node: Node): node is JsxAttributedNode & JsxAttributedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a JsxClosingElement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxClosingElement(node: Node): node is JsxClosingElement;\r\n    /**\r\n     * Gets if the node is a JsxClosingFragment.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxClosingFragment(node: Node): node is JsxClosingFragment;\r\n    /**\r\n     * Gets if the node is a JsxElement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxElement(node: Node): node is JsxElement;\r\n    /**\r\n     * Gets if the node is a JsxExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxExpression(node: Node): node is JsxExpression;\r\n    /**\r\n     * Gets if the node is a JsxFragment.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxFragment(node: Node): node is JsxFragment;\r\n    /**\r\n     * Gets if the node is a JsxOpeningElement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxOpeningElement(node: Node): node is JsxOpeningElement;\r\n    /**\r\n     * Gets if the node is a JsxOpeningFragment.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;\r\n    /**\r\n     * Gets if the node is a JsxSelfClosingElement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;\r\n    /**\r\n     * Gets if the node is a JsxSpreadAttribute.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;\r\n    /**\r\n     * Gets if the node is a JsxTagNamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxTagNamedNode(node: Node): node is JsxTagNamedNode & JsxTagNamedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a JsxText.\r\n     * @param node - Node to check.\r\n     */\r\n    static isJsxText(node: Node): node is JsxText;\r\n    /**\r\n     * Gets if the node is a LabeledStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isLabeledStatement(node: Node): node is LabeledStatement;\r\n    /**\r\n     * Gets if the node is a LeftHandSideExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isLeftHandSideExpression(node: Node): node is LeftHandSideExpression;\r\n    /**\r\n     * Gets if the node is a LeftHandSideExpressionedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isLeftHandSideExpressionedNode(node: Node): node is LeftHandSideExpressionedNode & LeftHandSideExpressionedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a LiteralExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isLiteralExpression(node: Node): node is LiteralExpression;\r\n    /**\r\n     * Gets if the node is a LiteralLikeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isLiteralLikeNode(node: Node): node is LiteralLikeNode & LiteralLikeNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a LiteralTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isLiteralTypeNode(node: Node): node is LiteralTypeNode;\r\n    /**\r\n     * Gets if the node is a MemberExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isMemberExpression(node: Node): node is MemberExpression;\r\n    /**\r\n     * Gets if the node is a MetaProperty.\r\n     * @param node - Node to check.\r\n     */\r\n    static isMetaProperty(node: Node): node is MetaProperty;\r\n    /**\r\n     * Gets if the node is a MethodDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isMethodDeclaration(node: Node): node is MethodDeclaration;\r\n    /**\r\n     * Gets if the node is a MethodSignature.\r\n     * @param node - Node to check.\r\n     */\r\n    static isMethodSignature(node: Node): node is MethodSignature;\r\n    /**\r\n     * Gets if the node is a ModifierableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isModifierableNode(node: Node): node is ModifierableNode & ModifierableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ModuleBlock.\r\n     * @param node - Node to check.\r\n     */\r\n    static isModuleBlock(node: Node): node is ModuleBlock;\r\n    /**\r\n     * Gets if the node is a ModuledNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isModuledNode(node: Node): node is ModuledNode & ModuledNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a NameableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNameableNode(node: Node): node is NameableNode & NameableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a NamedExports.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNamedExports(node: Node): node is NamedExports;\r\n    /**\r\n     * Gets if the node is a NamedImports.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNamedImports(node: Node): node is NamedImports;\r\n    /**\r\n     * Gets if the node is a NamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNamedNode(node: Node): node is NamedNode & NamedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a NamespaceChildableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNamespaceChildableNode(node: Node): node is NamespaceChildableNode & NamespaceChildableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a NamespaceDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNamespaceDeclaration(node: Node): node is NamespaceDeclaration;\r\n    /**\r\n     * Gets if the node is a NamespaceImport.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNamespaceImport(node: Node): node is NamespaceImport;\r\n    /**\r\n     * Gets if the node is a NeverKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNeverKeyword(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is a NewExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNewExpression(node: Node): node is NewExpression;\r\n    /**\r\n     * Gets if the node is a NoSubstitutionTemplateLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;\r\n    /**\r\n     * Gets if the node is a NonNullExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNonNullExpression(node: Node): node is NonNullExpression;\r\n    /**\r\n     * Gets if the node is a NotEmittedStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNotEmittedStatement(node: Node): node is NotEmittedStatement;\r\n    /**\r\n     * Gets if the node is a NullLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNullLiteral(node: Node): node is NullLiteral;\r\n    /**\r\n     * Gets if the node is a NumberKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNumberKeyword(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is a NumericLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    static isNumericLiteral(node: Node): node is NumericLiteral;\r\n    /**\r\n     * Gets if the node is a ObjectBindingPattern.\r\n     * @param node - Node to check.\r\n     */\r\n    static isObjectBindingPattern(node: Node): node is ObjectBindingPattern;\r\n    /**\r\n     * Gets if the node is a ObjectKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isObjectKeyword(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is a ObjectLiteralExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;\r\n    /**\r\n     * Gets if the node is a OmittedExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isOmittedExpression(node: Node): node is OmittedExpression;\r\n    /**\r\n     * Gets if the node is a OverloadableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isOverloadableNode(node: Node): node is OverloadableNode & OverloadableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ParameterDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isParameterDeclaration(node: Node): node is ParameterDeclaration;\r\n    /**\r\n     * Gets if the node is a ParameteredNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isParameteredNode(node: Node): node is ParameteredNode & ParameteredNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ParenthesizedExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isParenthesizedExpression(node: Node): node is ParenthesizedExpression;\r\n    /**\r\n     * Gets if the node is a ParenthesizedTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;\r\n    /**\r\n     * Gets if the node is a PartiallyEmittedExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;\r\n    /**\r\n     * Gets if the node is a PostfixUnaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;\r\n    /**\r\n     * Gets if the node is a PrefixUnaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;\r\n    /**\r\n     * Gets if the node is a PrimaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPrimaryExpression(node: Node): node is PrimaryExpression;\r\n    /**\r\n     * Gets if the node is a PropertyAccessExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;\r\n    /**\r\n     * Gets if the node is a PropertyAssignment.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPropertyAssignment(node: Node): node is PropertyAssignment;\r\n    /**\r\n     * Gets if the node is a PropertyDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPropertyDeclaration(node: Node): node is PropertyDeclaration;\r\n    /**\r\n     * Gets if the node is a PropertyNamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPropertyNamedNode(node: Node): node is PropertyNamedNode & PropertyNamedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a PropertySignature.\r\n     * @param node - Node to check.\r\n     */\r\n    static isPropertySignature(node: Node): node is PropertySignature;\r\n    /**\r\n     * Gets if the node is a QualifiedName.\r\n     * @param node - Node to check.\r\n     */\r\n    static isQualifiedName(node: Node): node is QualifiedName;\r\n    /**\r\n     * Gets if the node is a QuestionTokenableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isQuestionTokenableNode(node: Node): node is QuestionTokenableNode & QuestionTokenableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ReadonlyableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isReadonlyableNode(node: Node): node is ReadonlyableNode & ReadonlyableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ReferenceFindableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isReferenceFindableNode(node: Node): node is ReferenceFindableNode & ReferenceFindableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a RegularExpressionLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    static isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;\r\n    /**\r\n     * Gets if the node is a RenameableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isRenameableNode(node: Node): node is RenameableNode & RenameableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ReturnStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isReturnStatement(node: Node): node is ReturnStatement;\r\n    /**\r\n     * Gets if the node is a ReturnTypedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isReturnTypedNode(node: Node): node is ReturnTypedNode & ReturnTypedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ScopeableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isScopeableNode(node: Node): node is ScopeableNode & ScopeableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ScopedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isScopedNode(node: Node): node is ScopedNode & ScopedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a SemicolonToken.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSemicolonToken(node: Node): node is Node;\r\n    /**\r\n     * Gets if the node is a SetAccessorDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;\r\n    /**\r\n     * Gets if the node is a ShorthandPropertyAssignment.\r\n     * @param node - Node to check.\r\n     */\r\n    static isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;\r\n    /**\r\n     * Gets if the node is a SignaturedDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSignaturedDeclaration(node: Node): node is SignaturedDeclaration & SignaturedDeclarationExtensionType;\r\n    /**\r\n     * Gets if the node is a SourceFile.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSourceFile(node: Node): node is SourceFile;\r\n    /**\r\n     * Gets if the node is a SpreadAssignment.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSpreadAssignment(node: Node): node is SpreadAssignment;\r\n    /**\r\n     * Gets if the node is a SpreadElement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSpreadElement(node: Node): node is SpreadElement;\r\n    /**\r\n     * Gets if the node is a Statement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isStatement(node: Node): node is Statement;\r\n    /**\r\n     * Gets if the node is a StatementedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isStatementedNode(node: Node): node is StatementedNode & StatementedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a StaticableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isStaticableNode(node: Node): node is StaticableNode & StaticableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a StringKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isStringKeyword(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is a StringLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    static isStringLiteral(node: Node): node is StringLiteral;\r\n    /**\r\n     * Gets if the node is a SuperExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSuperExpression(node: Node): node is SuperExpression;\r\n    /**\r\n     * Gets if the node is a SwitchStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSwitchStatement(node: Node): node is SwitchStatement;\r\n    /**\r\n     * Gets if the node is a SymbolKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSymbolKeyword(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is a SyntaxList.\r\n     * @param node - Node to check.\r\n     */\r\n    static isSyntaxList(node: Node): node is SyntaxList;\r\n    /**\r\n     * Gets if the node is a TaggedTemplateExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;\r\n    /**\r\n     * Gets if the node is a TemplateExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTemplateExpression(node: Node): node is TemplateExpression;\r\n    /**\r\n     * Gets if the node is a TemplateHead.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTemplateHead(node: Node): node is TemplateHead;\r\n    /**\r\n     * Gets if the node is a TemplateMiddle.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTemplateMiddle(node: Node): node is TemplateMiddle;\r\n    /**\r\n     * Gets if the node is a TemplateSpan.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTemplateSpan(node: Node): node is TemplateSpan;\r\n    /**\r\n     * Gets if the node is a TemplateTail.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTemplateTail(node: Node): node is TemplateTail;\r\n    /**\r\n     * Gets if the node is a TextInsertableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTextInsertableNode(node: Node): node is TextInsertableNode & TextInsertableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a ThisExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isThisExpression(node: Node): node is ThisExpression;\r\n    /**\r\n     * Gets if the node is a ThrowStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isThrowStatement(node: Node): node is ThrowStatement;\r\n    /**\r\n     * Gets if the node is a TrueKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTrueKeyword(node: Node): node is BooleanLiteral;\r\n    /**\r\n     * Gets if the node is a TryStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTryStatement(node: Node): node is TryStatement;\r\n    /**\r\n     * Gets if the node is a TupleTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTupleTypeNode(node: Node): node is TupleTypeNode;\r\n    /**\r\n     * Gets if the node is a TypeAliasDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;\r\n    /**\r\n     * Gets if the node is a TypeArgumentedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeArgumentedNode(node: Node): node is TypeArgumentedNode & TypeArgumentedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a TypeAssertion.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeAssertion(node: Node): node is TypeAssertion;\r\n    /**\r\n     * Gets if the node is a TypeElement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeElement(node: Node): node is TypeElement;\r\n    /**\r\n     * Gets if the node is a TypeElementMemberedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeElementMemberedNode(node: Node): node is TypeElementMemberedNode & TypeElementMemberedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a TypeLiteralNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeLiteralNode(node: Node): node is TypeLiteralNode;\r\n    /**\r\n     * Gets if the node is a TypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeNode(node: Node): node is TypeNode;\r\n    /**\r\n     * Gets if the node is a TypeOfExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeOfExpression(node: Node): node is TypeOfExpression;\r\n    /**\r\n     * Gets if the node is a TypeParameterDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;\r\n    /**\r\n     * Gets if the node is a TypeParameteredNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeParameteredNode(node: Node): node is TypeParameteredNode & TypeParameteredNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a TypeReferenceNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypeReferenceNode(node: Node): node is TypeReferenceNode;\r\n    /**\r\n     * Gets if the node is a TypedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isTypedNode(node: Node): node is TypedNode & TypedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a UnaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isUnaryExpression(node: Node): node is UnaryExpression;\r\n    /**\r\n     * Gets if the node is a UnaryExpressionedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isUnaryExpressionedNode(node: Node): node is UnaryExpressionedNode & UnaryExpressionedNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a UndefinedKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    static isUndefinedKeyword(node: Node): node is Expression;\r\n    /**\r\n     * Gets if the node is a UnionTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isUnionTypeNode(node: Node): node is UnionTypeNode;\r\n    /**\r\n     * Gets if the node is a UnwrappableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    static isUnwrappableNode(node: Node): node is UnwrappableNode & UnwrappableNodeExtensionType;\r\n    /**\r\n     * Gets if the node is a UpdateExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isUpdateExpression(node: Node): node is UpdateExpression;\r\n    /**\r\n     * Gets if the node is a VariableDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    static isVariableDeclaration(node: Node): node is VariableDeclaration;\r\n    /**\r\n     * Gets if the node is a VariableDeclarationList.\r\n     * @param node - Node to check.\r\n     */\r\n    static isVariableDeclarationList(node: Node): node is VariableDeclarationList;\r\n    /**\r\n     * Gets if the node is a VariableStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isVariableStatement(node: Node): node is VariableStatement;\r\n    /**\r\n     * Gets if the node is a VoidExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isVoidExpression(node: Node): node is VoidExpression;\r\n    /**\r\n     * Gets if the node is a WhileStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isWhileStatement(node: Node): node is WhileStatement;\r\n    /**\r\n     * Gets if the node is a WithStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    static isWithStatement(node: Node): node is WithStatement;\r\n    /**\r\n     * Gets if the node is a YieldExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    static isYieldExpression(node: Node): node is YieldExpression;\r\n}\r\n\r\n/**\r\n * Writer functions.\r\n * @remarks These functions are currently very experimental.\r\n */\r\nexport declare class WriterFunctions {\r\n    private constructor();\r\n    /**\r\n     * Gets a writer function for writing the provided object as an object literal expression.\r\n     * @param obj - Object to write.\r\n     */\r\n    static object(obj: {\r\n        [key: string]: WriterFunctionOrValue | undefined;\r\n    }): WriterFunction;\r\n    /** Gets a writer function for writing an object type. */\r\n    static objectType(structure: TypeElementMemberedNodeStructure): WriterFunction;\r\n    /** Gets a writer function for writing a union type. */\r\n    static unionType(firstType: WriterFunctionOrValue, secondType: WriterFunctionOrValue, ...additionalTypes: WriterFunctionOrValue[]): (writer: CodeBlockWriter) => void;\r\n    /** Gets a writer function for writing an intersection type. */\r\n    static intersectionType(firstType: WriterFunctionOrValue, secondType: WriterFunctionOrValue, ...additionalTypes: WriterFunctionOrValue[]): (writer: CodeBlockWriter) => void;\r\n}\r\n\r\nexport declare type WriterFunctionOrValue = string | number | WriterFunction;\r\n\r\nexport declare type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName;\r\n\r\nexport declare type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;\r\n\r\nexport declare type ArrayBindingElement = BindingElement | OmittedExpression;\r\n\r\nexport declare type BindingName = Identifier | BindingPattern;\r\n\r\nexport declare type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;\r\n\r\nexport declare type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxOpeningLikeElement;\r\n\r\nexport declare type EntityName = Identifier | QualifiedName;\r\n\r\nexport declare type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;\r\n\r\nexport declare type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;\r\n\r\nexport declare type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;\r\n\r\nexport declare type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess;\r\n\r\nexport interface JsxTagNamePropertyAccess extends PropertyAccessExpression {\r\n    getExpression(): JsxTagNameExpression;\r\n}\r\n\r\nexport declare type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;\r\n\r\nexport declare type CaseOrDefaultClause = CaseClause | DefaultClause;\r\n\r\nexport declare type ModuleReference = EntityName | ExternalModuleReference;\r\n\r\nexport declare type TypeElementTypes = PropertySignature | MethodSignature | ConstructSignatureDeclaration | CallSignatureDeclaration | IndexSignatureDeclaration;\r\n\r\nexport declare type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;\r\n\r\nexport declare function AmbientableNode<T extends Constructor<AmbientableNodeExtensionType>>(Base: T): Constructor<AmbientableNode> & T;\r\n\r\nexport interface AmbientableNode {\r\n    /**\r\n     * If the node has the declare keyword.\r\n     */\r\n    hasDeclareKeyword(): boolean;\r\n    /**\r\n     * Gets the declare keyword or undefined if none exists.\r\n     */\r\n    getDeclareKeyword(): Node | undefined;\r\n    /**\r\n     * Gets the declare keyword or throws if it doesn't exist.\r\n     */\r\n    getDeclareKeywordOrThrow(): Node;\r\n    /**\r\n     * Gets if the node is ambient.\r\n     */\r\n    isAmbient(): boolean;\r\n    /**\r\n     * Sets if this node has a declare keyword.\r\n     * @param value - To add the declare keyword or not.\r\n     */\r\n    setHasDeclareKeyword(value?: boolean): this;\r\n}\r\n\r\ndeclare type AmbientableNodeExtensionType = Node & ModifierableNode;\r\n\r\nexport declare function ArgumentedNode<T extends Constructor<ArgumentedNodeExtensionType>>(Base: T): Constructor<ArgumentedNode> & T;\r\n\r\nexport interface ArgumentedNode {\r\n    /**\r\n     * Gets all the arguments of the node.\r\n     */\r\n    getArguments(): Node[];\r\n    /**\r\n     * Adds an argument.\r\n     * @param argumentText - Argument text to add.\r\n     */\r\n    addArgument(argumentText: string | WriterFunction): Node;\r\n    /**\r\n     * Adds arguments.\r\n     * @param argumentTexts - Argument texts to add.\r\n     */\r\n    addArguments(argumentTexts: ReadonlyArray<string | WriterFunction> | WriterFunction): Node[];\r\n    /**\r\n     * Inserts an argument.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentText - Argument text to insert.\r\n     */\r\n    insertArgument(index: number, argumentText: string | WriterFunction): Node;\r\n    /**\r\n     * Inserts arguments.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument texts to insert.\r\n     */\r\n    insertArguments(index: number, argumentTexts: ReadonlyArray<string | WriterFunction> | WriterFunction): Node[];\r\n    /**\r\n     * Removes an argument.\r\n     * @param arg - Argument to remove.\r\n     */\r\n    removeArgument(arg: Node): this;\r\n    /**\r\n     * Removes an argument.\r\n     * @param index - Index to remove.\r\n     */\r\n    removeArgument(index: number): this;\r\n}\r\n\r\ndeclare type ArgumentedNodeExtensionType = Node<ts.Node & {\r\n    arguments: ts.NodeArray<ts.Node>;\r\n}>;\r\n\r\nexport declare function AsyncableNode<T extends Constructor<AsyncableNodeExtensionType>>(Base: T): Constructor<AsyncableNode> & T;\r\n\r\nexport interface AsyncableNode {\r\n    /**\r\n     * If it's async.\r\n     */\r\n    isAsync(): boolean;\r\n    /**\r\n     * Gets the async keyword or undefined if none exists.\r\n     */\r\n    getAsyncKeyword(): Node<ts.Modifier> | undefined;\r\n    /**\r\n     * Gets the async keyword or throws if none exists.\r\n     */\r\n    getAsyncKeywordOrThrow(): Node<ts.Modifier>;\r\n    /**\r\n     * Sets if the node is async.\r\n     * @param value - If it should be async or not.\r\n     */\r\n    setIsAsync(value: boolean): this;\r\n}\r\n\r\ndeclare type AsyncableNodeExtensionType = Node & ModifierableNode;\r\n\r\nexport declare function AwaitableNode<T extends Constructor<AwaitableNodeExtensionType>>(Base: T): Constructor<AwaitableNode> & T;\r\n\r\nexport interface AwaitableNode {\r\n    /**\r\n     * If it's an awaited node.\r\n     */\r\n    isAwaited(): boolean;\r\n    /**\r\n     * Gets the await token or undefined if none exists.\r\n     */\r\n    getAwaitKeyword(): Node<ts.AwaitKeywordToken> | undefined;\r\n    /**\r\n     * Gets the await token or throws if none exists.\r\n     */\r\n    getAwaitKeywordOrThrow(): Node<ts.AwaitKeywordToken>;\r\n    /**\r\n     * Sets if the node is awaited.\r\n     * @param value - If it should be awaited or not.\r\n     */\r\n    setIsAwaited(value: boolean): this;\r\n}\r\n\r\ndeclare type AwaitableNodeExtensionType = Node<ts.Node & {\r\n    awaitModifier?: ts.AwaitKeywordToken;\r\n}>;\r\n\r\nexport declare function BodiedNode<T extends Constructor<BodiedNodeExtensionType>>(Base: T): Constructor<BodiedNode> & T;\r\n\r\nexport interface BodiedNode {\r\n    /**\r\n     * Gets the body.\r\n     */\r\n    getBody(): Node;\r\n    /**\r\n     * Sets the body text.\r\n     * @param textOrWriterFunction - Text or writer function to set as the body.\r\n     */\r\n    setBodyText(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Gets the body text without leading whitespace, leading indentation, or trailing whitespace.\r\n     */\r\n    getBodyText(): string;\r\n}\r\n\r\ndeclare type BodiedNodeExtensionType = Node<ts.Node & {\r\n    body: ts.Node;\r\n}>;\r\n\r\nexport declare function BodyableNode<T extends Constructor<BodyableNodeExtensionType>>(Base: T): Constructor<BodyableNode> & T;\r\n\r\nexport interface BodyableNode {\r\n    /**\r\n     * Gets the body or throws an error if it doesn't exist.\r\n     */\r\n    getBodyOrThrow(): Node;\r\n    /**\r\n     * Gets the body if it exists.\r\n     */\r\n    getBody(): Node | undefined;\r\n    /**\r\n     * Gets the body text without leading whitespace, leading indentation, or trailing whitespace. Returns undefined if there is no body.\r\n     */\r\n    getBodyText(): string | undefined;\r\n    /**\r\n     * Gets if the node has a body.\r\n     */\r\n    hasBody(): boolean;\r\n    /**\r\n     * Sets the body text. A body is required to do this operation.\r\n     * @param textOrWriterFunction - Text or writer function to set as the body.\r\n     */\r\n    setBodyText(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Adds a body if it doesn't exists.\r\n     */\r\n    addBody(): this;\r\n    /**\r\n     * Removes the body if it exists.\r\n     */\r\n    removeBody(): this;\r\n}\r\n\r\ndeclare type BodyableNodeExtensionType = Node<ts.Node & {\r\n    body?: ts.Node;\r\n}>;\r\n\r\nexport declare function ChildOrderableNode<T extends Constructor<ChildOrderableNodeExtensionType>>(Base: T): Constructor<ChildOrderableNode> & T;\r\n\r\nexport interface ChildOrderableNode {\r\n    /**\r\n     * Sets the child order of the node within the parent.\r\n     */\r\n    setOrder(order: number): this;\r\n}\r\n\r\ndeclare type ChildOrderableNodeExtensionType = Node;\r\n\r\nexport declare function DecoratableNode<T extends Constructor<DecoratableNodeExtensionType>>(Base: T): Constructor<DecoratableNode> & T;\r\n\r\nexport interface DecoratableNode {\r\n    /**\r\n     * Gets a decorator or undefined if it doesn't exist.\r\n     * @param name - Name of the parameter.\r\n     */\r\n    getDecorator(name: string): Decorator | undefined;\r\n    /**\r\n     * Gets a decorator or undefined if it doesn't exist.\r\n     * @param findFunction - Function to use to find the parameter.\r\n     */\r\n    getDecorator(findFunction: (declaration: Decorator) => boolean): Decorator | undefined;\r\n    /**\r\n     * Gets a decorator or throws if it doesn't exist.\r\n     * @param name - Name of the parameter.\r\n     */\r\n    getDecoratorOrThrow(name: string): Decorator;\r\n    /**\r\n     * Gets a decorator or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the parameter.\r\n     */\r\n    getDecoratorOrThrow(findFunction: (declaration: Decorator) => boolean): Decorator;\r\n    /**\r\n     * Gets all the decorators of the node.\r\n     */\r\n    getDecorators(): Decorator[];\r\n    /**\r\n     * Adds a decorator.\r\n     * @param structure - Structure of the decorator.\r\n     */\r\n    addDecorator(structure: DecoratorStructure): Decorator;\r\n    /**\r\n     * Adds decorators.\r\n     * @param structures - Structures of the decorators.\r\n     */\r\n    addDecorators(structures: ReadonlyArray<DecoratorStructure>): Decorator[];\r\n    /**\r\n     * Inserts a decorator.\r\n     * @param index - Child index to insert at. Specify a negative index to insert from the reverse.\r\n     * @param structure - Structure of the decorator.\r\n     */\r\n    insertDecorator(index: number, structure: DecoratorStructure): Decorator;\r\n    /**\r\n     * Insert decorators.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures to insert.\r\n     */\r\n    insertDecorators(index: number, structures: ReadonlyArray<DecoratorStructure>): Decorator[];\r\n}\r\n\r\ndeclare type DecoratableNodeExtensionType = Node<ts.Node>;\r\n\r\nexport declare function ExclamationTokenableNode<T extends Constructor<ExclamationTokenableNodeExtensionType>>(Base: T): Constructor<ExclamationTokenableNode> & T;\r\n\r\nexport interface ExclamationTokenableNode {\r\n    /**\r\n     * If it has a exclamation token.\r\n     */\r\n    hasExclamationToken(): boolean;\r\n    /**\r\n     * Gets the exclamation token node or returns undefined if it doesn't exist.\r\n     */\r\n    getExclamationTokenNode(): Node<ts.ExclamationToken> | undefined;\r\n    /**\r\n     * Gets the exclamation token node or throws.\r\n     */\r\n    getExclamationTokenNodeOrThrow(): Node<ts.ExclamationToken>;\r\n    /**\r\n     * Sets if this node has a exclamation token.\r\n     * @param value - If it should have a exclamation token or not.\r\n     */\r\n    setHasExclamationToken(value: boolean): this;\r\n}\r\n\r\ndeclare type ExclamationTokenableNodeExtensionType = Node<ts.Node & {\r\n    exclamationToken?: ts.ExclamationToken;\r\n}>;\r\n\r\nexport declare function ExportableNode<T extends Constructor<ExportableNodeExtensionType>>(Base: T): Constructor<ExportableNode> & T;\r\n\r\nexport interface ExportableNode extends ExportGetableNode {\r\n    /**\r\n     * Sets if this node is a default export of a file.\r\n     * @param value - If it should be a default export or not.\r\n     */\r\n    setIsDefaultExport(value: boolean): this;\r\n    /**\r\n     * Sets if the node is exported.\r\n     *\r\n     * Note: Will remove the default keyword if set.\r\n     * @param value - If it should be exported or not.\r\n     */\r\n    setIsExported(value: boolean): this;\r\n}\r\n\r\ndeclare type ExportableNodeExtensionType = Node & ModifierableNode;\r\n\r\nexport declare function ExportGetableNode<T extends Constructor<ExportGetableNodeExtensionType>>(Base: T): Constructor<ExportGetableNode> & T;\r\n\r\nexport interface ExportGetableNode {\r\n    /**\r\n     * If the node has the export keyword.\r\n     */\r\n    hasExportKeyword(): boolean;\r\n    /**\r\n     * Gets the export keyword or undefined if none exists.\r\n     */\r\n    getExportKeyword(): Node | undefined;\r\n    /**\r\n     * Gets the export keyword or throws if none exists.\r\n     */\r\n    getExportKeywordOrThrow(): Node;\r\n    /**\r\n     * If the node has the default keyword.\r\n     */\r\n    hasDefaultKeyword(): boolean;\r\n    /**\r\n     * Gets the default keyword or undefined if none exists.\r\n     */\r\n    getDefaultKeyword(): Node | undefined;\r\n    /**\r\n     * Gets the default keyword or throws if none exists.\r\n     */\r\n    getDefaultKeywordOrThrow(): Node;\r\n    /**\r\n     * Gets if the node is exported from a namespace, is a default export, or is a named export.\r\n     */\r\n    isExported(): boolean;\r\n    /**\r\n     * Gets if this node is a default export of a file.\r\n     */\r\n    isDefaultExport(): boolean;\r\n    /**\r\n     * Gets if this node is a named export of a file.\r\n     */\r\n    isNamedExport(): boolean;\r\n}\r\n\r\ndeclare type ExportGetableNodeExtensionType = Node;\r\n\r\nexport declare function ExtendsClauseableNode<T extends Constructor<ExtendsClauseableNodeExtensionType>>(Base: T): Constructor<ExtendsClauseableNode> & T;\r\n\r\nexport interface ExtendsClauseableNode {\r\n    /**\r\n     * Gets the extends clauses.\r\n     */\r\n    getExtends(): ExpressionWithTypeArguments[];\r\n    /**\r\n     * Adds multiple extends clauses.\r\n     * @param texts - Texts to add for the extends clause.\r\n     */\r\n    addExtends(texts: ReadonlyArray<string | WriterFunction> | WriterFunction): ExpressionWithTypeArguments[];\r\n    /**\r\n     * Adds an extends clause.\r\n     * @param text - Text to add for the extends clause.\r\n     */\r\n    addExtends(text: string): ExpressionWithTypeArguments;\r\n    /**\r\n     * Inserts multiple extends clauses.\r\n     * @param texts - Texts to insert for the extends clause.\r\n     */\r\n    insertExtends(index: number, texts: ReadonlyArray<string | WriterFunction> | WriterFunction): ExpressionWithTypeArguments[];\r\n    /**\r\n     * Inserts an extends clause.\r\n     * @param text - Text to insert for the extends clause.\r\n     */\r\n    insertExtends(index: number, text: string): ExpressionWithTypeArguments;\r\n    /**\r\n     * Removes the extends at the specified index.\r\n     * @param index - Index to remove.\r\n     */\r\n    removeExtends(index: number): this;\r\n    /**\r\n     * Removes the specified extends.\r\n     * @param extendsNode - Node of the extend to remove.\r\n     */\r\n    removeExtends(extendsNode: ExpressionWithTypeArguments): this;\r\n}\r\n\r\ndeclare type ExtendsClauseableNodeExtensionType = Node & HeritageClauseableNode;\r\n\r\nexport declare function GeneratorableNode<T extends Constructor<GeneratorableNodeExtensionType>>(Base: T): Constructor<GeneratorableNode> & T;\r\n\r\nexport interface GeneratorableNode {\r\n    /**\r\n     * If it's a generator function.\r\n     */\r\n    isGenerator(): boolean;\r\n    /**\r\n     * Gets the asterisk token or undefined if none exists.\r\n     */\r\n    getAsteriskToken(): Node<ts.AsteriskToken> | undefined;\r\n    /**\r\n     * Gets the asterisk token or throws if none exists.\r\n     */\r\n    getAsteriskTokenOrThrow(): Node<ts.AsteriskToken>;\r\n    /**\r\n     * Sets if the node is a generator.\r\n     * @param value - If it should be a generator or not.\r\n     */\r\n    setIsGenerator(value: boolean): this;\r\n}\r\n\r\ndeclare type GeneratorableNodeExtensionType = Node<ts.Node & {\r\n    asteriskToken?: ts.AsteriskToken;\r\n}>;\r\n\r\nexport declare function HeritageClauseableNode<T extends Constructor<HeritageClauseableNodeExtensionType>>(Base: T): Constructor<HeritageClauseableNode> & T;\r\n\r\nexport interface HeritageClauseableNode {\r\n    /**\r\n     * Gets the heritage clauses of the node.\r\n     */\r\n    getHeritageClauses(): HeritageClause[];\r\n    /**\r\n     * Gets the heritage clause by kind.\r\n     * @kind - Kind of heritage clause.\r\n     */\r\n    getHeritageClauseByKind(kind: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword): HeritageClause | undefined;\r\n    /**\r\n     * Gets the heritage clause by kind or throws if it doesn't exist.\r\n     * @kind - Kind of heritage clause.\r\n     */\r\n    getHeritageClauseByKindOrThrow(kind: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword): HeritageClause;\r\n}\r\n\r\ndeclare type HeritageClauseableNodeExtensionType = Node<ts.Node & {\r\n    heritageClauses?: ts.NodeArray<ts.HeritageClause>;\r\n}>;\r\n\r\nexport declare function ImplementsClauseableNode<T extends Constructor<ImplementsClauseableNodeExtensionType>>(Base: T): Constructor<ImplementsClauseableNode> & T;\r\n\r\nexport interface ImplementsClauseableNode {\r\n    /**\r\n     * Gets the implements clauses.\r\n     */\r\n    getImplements(): ExpressionWithTypeArguments[];\r\n    /**\r\n     * Adds an implements clause.\r\n     * @param text - Text to add for the implements clause.\r\n     */\r\n    addImplements(text: string): ExpressionWithTypeArguments;\r\n    /**\r\n     * Adds multiple implements clauses.\r\n     * @param text - Texts to add for the implements clause.\r\n     */\r\n    addImplements(text: ReadonlyArray<string | WriterFunction> | WriterFunction): ExpressionWithTypeArguments[];\r\n    /**\r\n     * Inserts an implements clause.\r\n     * @param text - Text to insert for the implements clause.\r\n     */\r\n    insertImplements(index: number, texts: ReadonlyArray<string | WriterFunction> | WriterFunction): ExpressionWithTypeArguments[];\r\n    /**\r\n     * Inserts multiple implements clauses.\r\n     * @param text - Texts to insert for the implements clause.\r\n     */\r\n    insertImplements(index: number, text: string): ExpressionWithTypeArguments;\r\n    /**\r\n     * Removes the implements at the specified index.\r\n     * @param index - Index to remove.\r\n     */\r\n    removeImplements(index: number): this;\r\n    /**\r\n     * Removes the specified implements.\r\n     * @param implementsNode - Node of the implements to remove.\r\n     */\r\n    removeImplements(implementsNode: ExpressionWithTypeArguments): this;\r\n}\r\n\r\ndeclare type ImplementsClauseableNodeExtensionType = Node & HeritageClauseableNode;\r\n\r\nexport declare function InitializerExpressionableNode<T extends Constructor<InitializerExpressionableNodeExtensionType>>(Base: T): Constructor<InitializerExpressionableNode> & T;\r\n\r\nexport interface InitializerExpressionableNode extends InitializerGetExpressionableNode, InitializerSetExpressionableNode {\r\n}\r\n\r\ndeclare type InitializerExpressionableNodeExtensionType = Node<ts.Node & {\r\n    initializer?: ts.Expression;\r\n}>;\r\n\r\nexport declare function InitializerGetExpressionableNode<T extends Constructor<InitializerGetExpressionableNodeExtensionType>>(Base: T): Constructor<InitializerGetExpressionableNode> & T;\r\n\r\nexport interface InitializerGetExpressionableNode {\r\n    /**\r\n     * Gets if node has an initializer.\r\n     */\r\n    hasInitializer(): boolean;\r\n    /**\r\n     * Gets the initializer.\r\n     */\r\n    getInitializer(): Expression | undefined;\r\n    /**\r\n     * Gets the initializer if it's a certain kind or throws.\r\n     */\r\n    getInitializerIfKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToExpressionMappings[TKind];\r\n    /**\r\n     * Gets the initializer if it's a certain kind.\r\n     */\r\n    getInitializerIfKind<TKind extends SyntaxKind>(kind: TKind): KindToExpressionMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the initializer or throw.\r\n     */\r\n    getInitializerOrThrow(): Expression;\r\n}\r\n\r\ndeclare type InitializerGetExpressionableNodeExtensionType = Node<ts.Node & {\r\n    initializer?: ts.Expression;\r\n}>;\r\n\r\nexport declare function InitializerSetExpressionableNode<T extends Constructor<InitializerSetExpressionableNodeExtensionType>>(Base: T): Constructor<InitializerSetExpressionableNode> & T;\r\n\r\nexport interface InitializerSetExpressionableNode {\r\n    /**\r\n     * Removes the initailizer.\r\n     */\r\n    removeInitializer(): this;\r\n    /**\r\n     * Sets the initializer.\r\n     * @param text - Text or writer function to set for the initializer.\r\n     */\r\n    setInitializer(textOrWriterFunction: string | WriterFunction): this;\r\n}\r\n\r\ndeclare type InitializerSetExpressionableNodeExtensionType = Node<ts.Node & {\r\n    initializer?: ts.Expression;\r\n}> & InitializerGetExpressionableNode;\r\n\r\nexport declare function JSDocableNode<T extends Constructor<JSDocableNodeExtensionType>>(Base: T): Constructor<JSDocableNode> & T;\r\n\r\nexport interface JSDocableNode {\r\n    /**\r\n     * Gets the JS doc nodes.\r\n     */\r\n    getJsDocs(): JSDoc[];\r\n    /**\r\n     * Adds a JS doc.\r\n     * @param structure - Structure to add.\r\n     */\r\n    addJsDoc(structure: JSDocStructure | string | WriterFunction): JSDoc;\r\n    /**\r\n     * Adds JS docs.\r\n     * @param structures - Structures to add.\r\n     */\r\n    addJsDocs(structures: ReadonlyArray<JSDocStructure | string | WriterFunction>): JSDoc[];\r\n    /**\r\n     * Inserts a JS doc.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure to insert.\r\n     */\r\n    insertJsDoc(index: number, structure: JSDocStructure | string | WriterFunction): JSDoc;\r\n    /**\r\n     * Inserts JS docs.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures to insert.\r\n     */\r\n    insertJsDocs(index: number, structures: ReadonlyArray<JSDocStructure | string | WriterFunction>): JSDoc[];\r\n}\r\n\r\ndeclare type JSDocableNodeExtensionType = Node<ts.Node & {\r\n    jsDoc?: ts.NodeArray<ts.JSDoc>;\r\n}>;\r\n\r\nexport declare function LiteralLikeNode<T extends Constructor<LiteralLikeNodeExtensionType>>(Base: T): Constructor<LiteralLikeNode> & T;\r\n\r\nexport interface LiteralLikeNode {\r\n    /**\r\n     * Get text of the literal.\r\n     */\r\n    getLiteralText(): string;\r\n    /**\r\n     * Gets if the literal is terminated.\r\n     */\r\n    isTerminated(): boolean;\r\n    /**\r\n     * Gets if the literal has an extended unicode escape.\r\n     */\r\n    hasExtendedUnicodeEscape(): boolean;\r\n}\r\n\r\ndeclare type LiteralLikeNodeExtensionType = Node<ts.LiteralLikeNode>;\r\n\r\nexport declare function ModifierableNode<T extends Constructor<ModifierableNodeExtensionType>>(Base: T): Constructor<ModifierableNode> & T;\r\n\r\nexport interface ModifierableNode {\r\n    /**\r\n     * Gets the node's modifiers.\r\n     */\r\n    getModifiers(): Node[];\r\n    /**\r\n     * Gets the first modifier of the specified syntax kind or throws if none found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstModifierByKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the first modifier of the specified syntax kind or undefined if none found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstModifierByKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets if it has the specified modifier.\r\n     * @param kind - Syntax kind to check for.\r\n     */\r\n    hasModifier(kind: SyntaxKind): boolean;\r\n    /**\r\n     * Gets if it has the specified modifier.\r\n     * @param text - Text to check for.\r\n     */\r\n    hasModifier(text: ModifierTexts): boolean;\r\n    /**\r\n     * Toggles a modifier.\r\n     * @param text - Text to toggle the modifier for.\r\n     * @param value - Optional toggling value.\r\n     */\r\n    toggleModifier(text: ModifierTexts, value?: boolean): this;\r\n}\r\n\r\ndeclare type ModifierableNodeExtensionType = Node;\r\n\r\nexport declare type ModifierTexts = \"export\" | \"default\" | \"declare\" | \"abstract\" | \"public\" | \"protected\" | \"private\" | \"readonly\" | \"static\" | \"async\" | \"const\";\r\n\r\nexport declare function ModuledNode<T extends Constructor<ModuledNodeExtensionType>>(Base: T): Constructor<ModuledNode> & T;\r\n\r\nexport interface ModuledNode {\r\n    /**\r\n     * Adds an import.\r\n     * @param structure - Structure that represents the import.\r\n     */\r\n    addImportDeclaration(structure: ImportDeclarationStructure): ImportDeclaration;\r\n    /**\r\n     * Adds imports.\r\n     * @param structures - Structures that represent the imports.\r\n     */\r\n    addImportDeclarations(structures: ReadonlyArray<ImportDeclarationStructure>): ImportDeclaration[];\r\n    /**\r\n     * Insert an import.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the import.\r\n     */\r\n    insertImportDeclaration(index: number, structure: ImportDeclarationStructure): ImportDeclaration;\r\n    /**\r\n     * Inserts imports.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the imports to insert.\r\n     */\r\n    insertImportDeclarations(index: number, structures: ReadonlyArray<ImportDeclarationStructure>): ImportDeclaration[];\r\n    /**\r\n     * Gets the first import declaration that matches a condition, or undefined if it doesn't exist.\r\n     * @param condition - Condition to get the import declaration by.\r\n     */\r\n    getImportDeclaration(condition: (importDeclaration: ImportDeclaration) => boolean): ImportDeclaration | undefined;\r\n    /**\r\n     * Gets the first import declaration that matches a module specifier, or undefined if it doesn't exist.\r\n     * @param module - Module specifier to get the import declaration by.\r\n     */\r\n    getImportDeclaration(moduleSpecifier: string): ImportDeclaration | undefined;\r\n    /**\r\n     * Gets the first import declaration that matches a condition, or throws if it doesn't exist.\r\n     * @param condition - Condition to get the import declaration by.\r\n     */\r\n    getImportDeclarationOrThrow(condition: (importDeclaration: ImportDeclaration) => boolean): ImportDeclaration;\r\n    /**\r\n     * Gets the first import declaration that matches a module specifier, or throws if it doesn't exist.\r\n     * @param module - Module specifier to get the import declaration by.\r\n     */\r\n    getImportDeclarationOrThrow(moduleSpecifier: string): ImportDeclaration;\r\n    /**\r\n     * Get the module's import declarations.\r\n     */\r\n    getImportDeclarations(): ImportDeclaration[];\r\n    /**\r\n     * Add export declarations.\r\n     * @param structure - Structure that represents the export.\r\n     */\r\n    addExportDeclaration(structure: ExportDeclarationStructure): ExportDeclaration;\r\n    /**\r\n     * Add export declarations.\r\n     * @param structures - Structures that represent the exports.\r\n     */\r\n    addExportDeclarations(structures: ReadonlyArray<ExportDeclarationStructure>): ExportDeclaration[];\r\n    /**\r\n     * Insert an export declaration.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the export.\r\n     */\r\n    insertExportDeclaration(index: number, structure: ExportDeclarationStructure): ExportDeclaration;\r\n    /**\r\n     * Insert export declarations.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the exports to insert.\r\n     */\r\n    insertExportDeclarations(index: number, structures: ReadonlyArray<ExportDeclarationStructure>): ExportDeclaration[];\r\n    getExportDeclaration(condition: (exportDeclaration: ExportDeclaration) => boolean): ExportDeclaration | undefined;\r\n    /**\r\n     * Gets the first export declaration that matches a module specifier, or undefined if it doesn't exist.\r\n     * @param module - Module specifier to get the export declaration by.\r\n     */\r\n    getExportDeclaration(moduleSpecifier: string): ExportDeclaration | undefined;\r\n    /**\r\n     * Gets the first export declaration that matches a condition, or throws if it doesn't exist.\r\n     * @param condition - Condition to get the export declaration by.\r\n     */\r\n    getExportDeclarationOrThrow(condition: (exportDeclaration: ExportDeclaration) => boolean): ExportDeclaration;\r\n    /**\r\n     * Gets the first export declaration that matches a module specifier, or throws if it doesn't exist.\r\n     * @param module - Module specifier to get the export declaration by.\r\n     */\r\n    getExportDeclarationOrThrow(moduleSpecifier: string): ExportDeclaration;\r\n    /**\r\n     * Get the export declarations.\r\n     */\r\n    getExportDeclarations(): ExportDeclaration[];\r\n    /**\r\n     * Add export assignments.\r\n     * @param structure - Structure that represents the export.\r\n     */\r\n    addExportAssignment(structure: ExportAssignmentStructure): ExportAssignment;\r\n    /**\r\n     * Add export assignments.\r\n     * @param structures - Structures that represent the exports.\r\n     */\r\n    addExportAssignments(structures: ReadonlyArray<ExportAssignmentStructure>): ExportAssignment[];\r\n    /**\r\n     * Insert an export assignment.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the export.\r\n     */\r\n    insertExportAssignment(index: number, structure: ExportAssignmentStructure): ExportAssignment;\r\n    /**\r\n     * Insert export assignments into a file.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the exports to insert.\r\n     */\r\n    insertExportAssignments(index: number, structures: ReadonlyArray<ExportAssignmentStructure>): ExportAssignment[];\r\n    /**\r\n     * Gets the first export assignment that matches a condition, or undefined if it doesn't exist.\r\n     * @param condition - Condition to get the export assignment by.\r\n     */\r\n    getExportAssignment(condition: (exportAssignment: ExportAssignment) => boolean): ExportAssignment | undefined;\r\n    /**\r\n     * Gets the first export assignment that matches a condition, or throws if it doesn't exist.\r\n     * @param condition - Condition to get the export assignment by.\r\n     */\r\n    getExportAssignmentOrThrow(condition: (exportAssignment: ExportAssignment) => boolean): ExportAssignment;\r\n    /**\r\n     * Get the file's export assignments.\r\n     */\r\n    getExportAssignments(): ExportAssignment[];\r\n    /**\r\n     * Gets the default export symbol.\r\n     */\r\n    getDefaultExportSymbol(): Symbol | undefined;\r\n    /**\r\n     * Gets the default export symbol or throws if it doesn't exist.\r\n     */\r\n    getDefaultExportSymbolOrThrow(): Symbol;\r\n    /**\r\n     * Gets the export symbols.\r\n     */\r\n    getExportSymbols(): Symbol[];\r\n    /**\r\n     * Gets all the declarations that are exported from the module.\r\n     *\r\n     * This will include declarations that are transitively exported from other modules. If you mean to get the export\r\n     * declarations then use `.getExportDeclarations()`.\r\n     */\r\n    getExportedDeclarations(): Node[];\r\n    /**\r\n     * Removes any \"export default\".\r\n     */\r\n    removeDefaultExport(defaultExportSymbol?: Symbol | undefined): this;\r\n}\r\n\r\ndeclare type ModuledNodeExtensionType = Node<ts.SourceFile | ts.NamespaceDeclaration> & StatementedNode;\r\n\r\nexport declare function BindingNamedNode<T extends Constructor<BindingNamedNodeExtensionType>>(Base: T): Constructor<BindingNamedNode> & T;\r\n\r\nexport interface BindingNamedNode extends BindingNamedNodeSpecific, ReferenceFindableNode, RenameableNode {\r\n}\r\n\r\ndeclare type BindingNamedNodeExtensionType = NamedNodeBaseExtensionType<ts.BindingName>;\r\n\r\nexport declare type BindingNamedNodeSpecific = NamedNodeSpecificBase<BindingName>;\r\n\r\nexport declare function DeclarationNamedNode<T extends Constructor<DeclarationNamedNodeExtensionType>>(Base: T): Constructor<DeclarationNamedNode> & T;\r\n\r\nexport interface DeclarationNamedNode extends DeclarationNamedNodeSpecific, ReferenceFindableNode, RenameableNode {\r\n}\r\n\r\ndeclare type DeclarationNamedNodeExtensionType = Node<ts.NamedDeclaration>;\r\n\r\nexport interface DeclarationNamedNodeSpecific {\r\n    /**\r\n     * Gets the name node.\r\n     */\r\n    getNameNode(): Identifier | undefined;\r\n    /**\r\n     * Gets the name node or throws an error if it doesn't exists.\r\n     */\r\n    getNameNodeOrThrow(): Identifier;\r\n    /**\r\n     * Gets the name.\r\n     */\r\n    getName(): string | undefined;\r\n    /**\r\n     * Gets the name or throws if it doens't exist.\r\n     */\r\n    getNameOrThrow(): string;\r\n}\r\n\r\nexport declare function NameableNode<T extends Constructor<NameableNodeExtensionType>>(Base: T): Constructor<NameableNode> & T;\r\n\r\nexport interface NameableNode extends NameableNodeSpecific, ReferenceFindableNode, RenameableNode {\r\n}\r\n\r\ndeclare type NameableNodeExtensionType = Node<ts.Node & {\r\n    name?: ts.Identifier;\r\n}>;\r\n\r\nexport interface NameableNodeSpecific {\r\n    /**\r\n     * Gets the name node if it exists.\r\n     */\r\n    getNameNode(): Identifier | undefined;\r\n    /**\r\n     * Gets the name node if it exists, or throws.\r\n     */\r\n    getNameNodeOrThrow(): Identifier;\r\n    /**\r\n     * Gets the name if it exists.\r\n     */\r\n    getName(): string | undefined;\r\n    /**\r\n     * Gets the name if it exists, or throws.\r\n     */\r\n    getNameOrThrow(): string;\r\n    /**\r\n     * Removes the name from the node.\r\n     */\r\n    removeName(): this;\r\n}\r\n\r\nexport declare function NamedNodeBase<TCompilerNode extends ts.Node, U extends Constructor<NamedNodeBaseExtensionType<TCompilerNode>>>(Base: U): Constructor<NamedNodeSpecificBase<CompilerNodeToWrappedType<TCompilerNode>>> & U;\r\n\r\nexport interface NamedNodeSpecificBase<TNode extends Node> {\r\n    /**\r\n     * Gets the name node.\r\n     */\r\n    getNameNode(): TNode;\r\n    /**\r\n     * Gets the name.\r\n     */\r\n    getName(): string;\r\n}\r\n\r\ndeclare type NamedNodeBaseExtensionType<TCompilerNode extends ts.Node> = Node<ts.Node & {\r\n    name: TCompilerNode;\r\n}>;\r\n\r\nexport declare function NamedNode<T extends Constructor<NamedNodeExtensionType>>(Base: T): Constructor<NamedNode> & T;\r\n\r\nexport interface NamedNode extends NamedNodeSpecific, ReferenceFindableNode, RenameableNode {\r\n}\r\n\r\ndeclare type NamedNodeExtensionType = NamedNodeBaseExtensionType<ts.Identifier>;\r\n\r\nexport declare type NamedNodeSpecific = NamedNodeSpecificBase<Identifier>;\r\n\r\nexport declare function PropertyNamedNode<T extends Constructor<PropertyNamedNodeExtensionType>>(Base: T): Constructor<PropertyNamedNode> & T;\r\n\r\nexport interface PropertyNamedNode extends PropertyNamedNodeSpecific, ReferenceFindableNode, RenameableNode {\r\n}\r\n\r\ndeclare type PropertyNamedNodeExtensionType = NamedNodeBaseExtensionType<ts.PropertyName>;\r\n\r\nexport declare type PropertyNamedNodeSpecific = NamedNodeSpecificBase<PropertyName>;\r\n\r\nexport declare function ReferenceFindableNode<T extends Constructor<ReferenceFindableNodeExtensionType>>(Base: T): Constructor<ReferenceFindableNode> & T;\r\n\r\nexport interface ReferenceFindableNode {\r\n    /**\r\n     * Finds the references of the definition of the node.\r\n     */\r\n    findReferences(): ReferencedSymbol[];\r\n    /**\r\n     * Finds the nodes that reference the definition of the node.\r\n     */\r\n    findReferencesAsNodes(): Node[];\r\n}\r\n\r\ndeclare type ReferenceFindableNodeExtensionType = Node<ts.Node & {\r\n    name?: ts.PropertyName | ts.BindingName | ts.DeclarationName;\r\n}>;\r\n\r\nexport declare function RenameableNode<T extends Constructor<RenameableNodeExtensionType>>(Base: T): Constructor<RenameableNode> & T;\r\n\r\nexport interface RenameableNode {\r\n    /**\r\n     * Renames the name of the node.\r\n     * @param newName - New name.\r\n     * @param options - Options for renaming.\r\n     */\r\n    rename(newName: string, options?: RenameOptions): this;\r\n}\r\n\r\ndeclare type RenameableNodeExtensionType = Node<ts.Node>;\r\n\r\nexport declare function ParameteredNode<T extends Constructor<ParameteredNodeExtensionType>>(Base: T): Constructor<ParameteredNode> & T;\r\n\r\nexport interface ParameteredNode {\r\n    /**\r\n     * Gets a parameter or undefined if it doesn't exist.\r\n     * @param name - Name of the parameter.\r\n     */\r\n    getParameter(name: string): ParameterDeclaration | undefined;\r\n    /**\r\n     * Gets a parameter or undefined if it doesn't exist.\r\n     * @param findFunction - Function to use to find the parameter.\r\n     */\r\n    getParameter(findFunction: (declaration: ParameterDeclaration) => boolean): ParameterDeclaration | undefined;\r\n    /**\r\n     * Gets a parameter or throws if it doesn't exist.\r\n     * @param name - Name of the parameter.\r\n     */\r\n    getParameterOrThrow(name: string): ParameterDeclaration;\r\n    /**\r\n     * Gets a parameter or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the parameter.\r\n     */\r\n    getParameterOrThrow(findFunction: (declaration: ParameterDeclaration) => boolean): ParameterDeclaration;\r\n    /**\r\n     * Gets all the parameters of the node.\r\n     */\r\n    getParameters(): ParameterDeclaration[];\r\n    /**\r\n     * Adds a parameter.\r\n     * @param structure - Structure of the parameter.\r\n     */\r\n    addParameter(structure: ParameterDeclarationStructure): ParameterDeclaration;\r\n    /**\r\n     * Adds parameters.\r\n     * @param structures - Structures of the parameters.\r\n     */\r\n    addParameters(structures: ReadonlyArray<ParameterDeclarationStructure>): ParameterDeclaration[];\r\n    /**\r\n     * Inserts parameters.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Parameters to insert.\r\n     */\r\n    insertParameters(index: number, structures: ReadonlyArray<ParameterDeclarationStructure>): ParameterDeclaration[];\r\n    /**\r\n     * Inserts a parameter.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Parameter to insert.\r\n     */\r\n    insertParameter(index: number, structure: ParameterDeclarationStructure): ParameterDeclaration;\r\n}\r\n\r\ndeclare type ParameteredNodeExtensionType = Node<ts.Node & {\r\n    parameters: ts.NodeArray<ts.ParameterDeclaration>;\r\n}>;\r\n\r\nexport declare function QuestionTokenableNode<T extends Constructor<QuestionTokenableNodeExtensionType>>(Base: T): Constructor<QuestionTokenableNode> & T;\r\n\r\nexport interface QuestionTokenableNode {\r\n    /**\r\n     * If it has a question token.\r\n     */\r\n    hasQuestionToken(): boolean;\r\n    /**\r\n     * Gets the question token node or returns undefined if it doesn't exist.\r\n     */\r\n    getQuestionTokenNode(): Node<ts.QuestionToken> | undefined;\r\n    /**\r\n     * Gets the question token node or throws.\r\n     */\r\n    getQuestionTokenNodeOrThrow(): Node<ts.QuestionToken>;\r\n    /**\r\n     * Sets if this node has a question token.\r\n     * @param value - If it should have a question token or not.\r\n     */\r\n    setHasQuestionToken(value: boolean): this;\r\n}\r\n\r\ndeclare type QuestionTokenableNodeExtensionType = Node<ts.Node & {\r\n    questionToken?: ts.QuestionToken;\r\n}>;\r\n\r\nexport declare function ReadonlyableNode<T extends Constructor<ReadonlyableNodeExtensionType>>(Base: T): Constructor<ReadonlyableNode> & T;\r\n\r\nexport interface ReadonlyableNode {\r\n    /**\r\n     * Gets if it's readonly.\r\n     */\r\n    isReadonly(): boolean;\r\n    /**\r\n     * Gets the readonly keyword, or undefined if none exists.\r\n     */\r\n    getReadonlyKeyword(): Node | undefined;\r\n    /**\r\n     * Gets the readonly keyword, or throws if none exists.\r\n     */\r\n    getReadonlyKeywordOrThrow(): Node;\r\n    /**\r\n     * Sets if this node is readonly.\r\n     * @param value - If readonly or not.\r\n     */\r\n    setIsReadonly(value: boolean): this;\r\n}\r\n\r\ndeclare type ReadonlyableNodeExtensionType = Node & ModifierableNode;\r\n\r\nexport declare function ReturnTypedNode<T extends Constructor<ReturnTypedNodeExtensionType>>(Base: T): Constructor<ReturnTypedNode> & T;\r\n\r\nexport interface ReturnTypedNode {\r\n    /**\r\n     * Gets the return type.\r\n     */\r\n    getReturnType(): Type;\r\n    /**\r\n     * Gets the return type node or undefined if none exists.\r\n     */\r\n    getReturnTypeNode(): TypeNode | undefined;\r\n    /**\r\n     * Gets the return type node or throws if none exists.\r\n     */\r\n    getReturnTypeNodeOrThrow(): TypeNode;\r\n    /**\r\n     * Sets the return type of the node.\r\n     * @param textOrWriterFunction - Text or writer function to set the return type with.\r\n     */\r\n    setReturnType(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Removes the return type.\r\n     */\r\n    removeReturnType(): this;\r\n    /**\r\n     * Gets the signature of the node from the type checker.\r\n     */\r\n    getSignature(): Signature;\r\n}\r\n\r\ndeclare type ReturnTypedNodeExtensionType = Node<ts.SignatureDeclaration>;\r\n\r\nexport declare function ScopeableNode<T extends Constructor<ScopeableNodeExtensionType>>(Base: T): Constructor<ScopeableNode> & T;\r\n\r\nexport interface ScopeableNode {\r\n    /**\r\n     * Gets the scope.\r\n     */\r\n    getScope(): Scope | undefined;\r\n    /**\r\n     * Sets the scope.\r\n     * @param scope - Scope to set to.\r\n     */\r\n    setScope(scope: Scope | undefined): this;\r\n    /**\r\n     * Gets if the node has a scope keyword.\r\n     */\r\n    hasScopeKeyword(): boolean;\r\n}\r\n\r\ndeclare type ScopeableNodeExtensionType = Node & ModifierableNode;\r\n\r\nexport declare function ScopedNode<T extends Constructor<ScopedNodeExtensionType>>(Base: T): Constructor<ScopedNode> & T;\r\n\r\nexport interface ScopedNode {\r\n    /**\r\n     * Gets the scope.\r\n     */\r\n    getScope(): Scope;\r\n    /**\r\n     * Sets the scope.\r\n     * @param scope - Scope to set to.\r\n     */\r\n    setScope(scope: Scope | undefined): this;\r\n    /**\r\n     * Gets if the node has a scope keyword.\r\n     */\r\n    hasScopeKeyword(): boolean;\r\n}\r\n\r\ndeclare type ScopedNodeExtensionType = Node & ModifierableNode;\r\n\r\nexport declare function SignaturedDeclaration<T extends Constructor<SignaturedDeclarationExtensionType>>(Base: T): Constructor<SignaturedDeclaration> & T;\r\n\r\nexport interface SignaturedDeclaration extends ParameteredNode, ReturnTypedNode {\r\n}\r\n\r\ndeclare type SignaturedDeclarationExtensionType = Node<ts.SignatureDeclaration>;\r\n\r\nexport declare function StaticableNode<T extends Constructor<StaticableNodeExtensionType>>(Base: T): Constructor<StaticableNode> & T;\r\n\r\nexport interface StaticableNode {\r\n    /**\r\n     * Gets if it's static.\r\n     */\r\n    isStatic(): boolean;\r\n    /**\r\n     * Gets the static keyword, or undefined if none exists.\r\n     */\r\n    getStaticKeyword(): Node | undefined;\r\n    /**\r\n     * Gets the static keyword, or throws if none exists.\r\n     */\r\n    getStaticKeywordOrThrow(): Node;\r\n    /**\r\n     * Sets if the node is static.\r\n     * @param value - If it should be static or not.\r\n     */\r\n    setIsStatic(value: boolean): this;\r\n}\r\n\r\ndeclare type StaticableNodeExtensionType = Node & ModifierableNode;\r\n\r\nexport declare function TextInsertableNode<T extends Constructor<TextInsertableNodeExtensionType>>(Base: T): Constructor<TextInsertableNode> & T;\r\n\r\nexport interface TextInsertableNode {\r\n    /**\r\n     * Inserts text within the body of the node.\r\n     *\r\n     * WARNING: This will forget any previously navigated descendant nodes.\r\n     * @param pos - Position to insert at.\r\n     * @param textOrWriterFunction - Text to insert.\r\n     */\r\n    insertText(pos: number, textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Replaces text within the body of the node.\r\n     *\r\n     * WARNING: This will forget any previously navigated descendant nodes.\r\n     * @param range - Start and end position of the text to replace.\r\n     * @param textOrWriterFunction - Text to replace the range with.\r\n     */\r\n    replaceText(range: [number, number], textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Removes all the text within the node\r\n     */\r\n    removeText(): this;\r\n    /**\r\n     * Removes text within the body of the node.\r\n     *\r\n     * WARNING: This will forget any previously navigated descendant nodes.\r\n     * @param pos - Start position to remove.\r\n     * @param end - End position to remove.\r\n     */\r\n    removeText(pos: number, end: number): this;\r\n}\r\n\r\ndeclare type TextInsertableNodeExtensionType = Node;\r\n\r\nexport declare function TypeArgumentedNode<T extends Constructor<TypeArgumentedNodeExtensionType>>(Base: T): Constructor<TypeArgumentedNode> & T;\r\n\r\nexport interface TypeArgumentedNode {\r\n    /**\r\n     * Gets all the type arguments of the node.\r\n     */\r\n    getTypeArguments(): TypeNode[];\r\n    /**\r\n     * Adds a type argument.\r\n     * @param argumentText - Argument text to add.\r\n     */\r\n    addTypeArgument(argumentText: string): TypeNode;\r\n    /**\r\n     * Adds type arguments.\r\n     * @param argumentTexts - Argument texts to add.\r\n     */\r\n    addTypeArguments(argumentTexts: ReadonlyArray<string>): TypeNode[];\r\n    /**\r\n     * Inserts a type argument.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentText - Argument text to insert.\r\n     */\r\n    insertTypeArgument(index: number, argumentText: string): TypeNode;\r\n    /**\r\n     * Inserts type arguments.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument texts to insert.\r\n     */\r\n    insertTypeArguments(index: number, argumentTexts: ReadonlyArray<string>): TypeNode[];\r\n    /**\r\n     * Removes a type argument.\r\n     * @param typeArg - Type argument to remove.\r\n     */\r\n    removeTypeArgument(typeArg: Node): this;\r\n    /**\r\n     * Removes a type argument.\r\n     * @param index - Index to remove.\r\n     */\r\n    removeTypeArgument(index: number): this;\r\n}\r\n\r\ndeclare type TypeArgumentedNodeExtensionType = Node<ts.Node & {\r\n    typeArguments?: ts.NodeArray<ts.TypeNode>;\r\n}>;\r\n\r\nexport declare function TypedNode<T extends Constructor<TypedNodeExtensionType>>(Base: T): Constructor<TypedNode> & T;\r\n\r\nexport interface TypedNode {\r\n    /**\r\n     * Gets the type node or undefined if none exists.\r\n     */\r\n    getTypeNode(): TypeNode | undefined;\r\n    /**\r\n     * Gets the type node or throws if none exists.\r\n     */\r\n    getTypeNodeOrThrow(): TypeNode;\r\n    /**\r\n     * Sets the type.\r\n     * @param textOrWriterFunction - Text or writer function to set the type with.\r\n     */\r\n    setType(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Removes the type.\r\n     */\r\n    removeType(): this;\r\n}\r\n\r\ndeclare type TypedNodeExtensionType = Node<ts.Node & {\r\n    type?: ts.TypeNode;\r\n}>;\r\n\r\nexport declare function TypeElementMemberedNode<T extends Constructor<TypeElementMemberedNodeExtensionType>>(Base: T): Constructor<TypeElementMemberedNode> & T;\r\n\r\nexport interface TypeElementMemberedNode {\r\n    /**\r\n     * Add construct signature.\r\n     * @param structure - Structure representing the construct signature.\r\n     */\r\n    addConstructSignature(structure: ConstructSignatureDeclarationStructure): ConstructSignatureDeclaration;\r\n    /**\r\n     * Add construct signatures.\r\n     * @param structures - Structures representing the construct signatures.\r\n     */\r\n    addConstructSignatures(structures: ReadonlyArray<ConstructSignatureDeclarationStructure>): ConstructSignatureDeclaration[];\r\n    /**\r\n     * Insert construct signature.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the construct signature.\r\n     */\r\n    insertConstructSignature(index: number, structure: ConstructSignatureDeclarationStructure): ConstructSignatureDeclaration;\r\n    /**\r\n     * Insert construct signatures.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the construct signatures.\r\n     */\r\n    insertConstructSignatures(index: number, structures: ReadonlyArray<ConstructSignatureDeclarationStructure>): ConstructSignatureDeclaration[];\r\n    /**\r\n     * Gets the first construct signature by a find function.\r\n     * @param findFunction - Function to find the construct signature by.\r\n     */\r\n    getConstructSignature(findFunction: (member: ConstructSignatureDeclaration) => boolean): ConstructSignatureDeclaration | undefined;\r\n    /**\r\n     * Gets the first construct signature by a find function or throws if not found.\r\n     * @param findFunction - Function to find the construct signature by.\r\n     */\r\n    getConstructSignatureOrThrow(findFunction: (member: ConstructSignatureDeclaration) => boolean): ConstructSignatureDeclaration;\r\n    /**\r\n     * Gets the interface construct signatures.\r\n     */\r\n    getConstructSignatures(): ConstructSignatureDeclaration[];\r\n    /**\r\n     * Add call signature.\r\n     * @param structure - Structure representing the call signature.\r\n     */\r\n    addCallSignature(structure: CallSignatureDeclarationStructure): CallSignatureDeclaration;\r\n    /**\r\n     * Add call signatures.\r\n     * @param structures - Structures representing the call signatures.\r\n     */\r\n    addCallSignatures(structures: ReadonlyArray<CallSignatureDeclarationStructure>): CallSignatureDeclaration[];\r\n    /**\r\n     * Insert call signature.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the call signature.\r\n     */\r\n    insertCallSignature(index: number, structure: CallSignatureDeclarationStructure): CallSignatureDeclaration;\r\n    /**\r\n     * Insert call signatures.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the call signatures.\r\n     */\r\n    insertCallSignatures(index: number, structures: ReadonlyArray<CallSignatureDeclarationStructure>): CallSignatureDeclaration[];\r\n    /**\r\n     * Gets the first call signature by a find function.\r\n     * @param findFunction - Function to find the call signature by.\r\n     */\r\n    getCallSignature(findFunction: (member: CallSignatureDeclaration) => boolean): CallSignatureDeclaration | undefined;\r\n    /**\r\n     * Gets the first call signature by a find function or throws if not found.\r\n     * @param findFunction - Function to find the call signature by.\r\n     */\r\n    getCallSignatureOrThrow(findFunction: (member: CallSignatureDeclaration) => boolean): CallSignatureDeclaration;\r\n    /**\r\n     * Gets the interface call signatures.\r\n     */\r\n    getCallSignatures(): CallSignatureDeclaration[];\r\n    /**\r\n     * Add index signature.\r\n     * @param structure - Structure representing the index signature.\r\n     */\r\n    addIndexSignature(structure: IndexSignatureDeclarationStructure): IndexSignatureDeclaration;\r\n    /**\r\n     * Add index signatures.\r\n     * @param structures - Structures representing the index signatures.\r\n     */\r\n    addIndexSignatures(structures: ReadonlyArray<IndexSignatureDeclarationStructure>): IndexSignatureDeclaration[];\r\n    /**\r\n     * Insert index signature.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the index signature.\r\n     */\r\n    insertIndexSignature(index: number, structure: IndexSignatureDeclarationStructure): IndexSignatureDeclaration;\r\n    /**\r\n     * Insert index signatures.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the index signatures.\r\n     */\r\n    insertIndexSignatures(index: number, structures: ReadonlyArray<IndexSignatureDeclarationStructure>): IndexSignatureDeclaration[];\r\n    /**\r\n     * Gets the first index signature by a find function.\r\n     * @param findFunction - Function to find the index signature by.\r\n     */\r\n    getIndexSignature(findFunction: (member: IndexSignatureDeclaration) => boolean): IndexSignatureDeclaration | undefined;\r\n    /**\r\n     * Gets the first index signature by a find function or throws if not found.\r\n     * @param findFunction - Function to find the index signature by.\r\n     */\r\n    getIndexSignatureOrThrow(findFunction: (member: IndexSignatureDeclaration) => boolean): IndexSignatureDeclaration;\r\n    /**\r\n     * Gets the interface index signatures.\r\n     */\r\n    getIndexSignatures(): IndexSignatureDeclaration[];\r\n    /**\r\n     * Add method.\r\n     * @param structure - Structure representing the method.\r\n     */\r\n    addMethod(structure: MethodSignatureStructure): MethodSignature;\r\n    /**\r\n     * Add methods.\r\n     * @param structures - Structures representing the methods.\r\n     */\r\n    addMethods(structures: ReadonlyArray<MethodSignatureStructure>): MethodSignature[];\r\n    /**\r\n     * Insert method.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the method.\r\n     */\r\n    insertMethod(index: number, structure: MethodSignatureStructure): MethodSignature;\r\n    /**\r\n     * Insert methods.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the methods.\r\n     */\r\n    insertMethods(index: number, structures: ReadonlyArray<MethodSignatureStructure>): MethodSignature[];\r\n    /**\r\n     * Gets the first method by name.\r\n     * @param name - Name.\r\n     */\r\n    getMethod(name: string): MethodSignature | undefined;\r\n    /**\r\n     * Gets the first method by a find function.\r\n     * @param findFunction - Function to find the method by.\r\n     */\r\n    getMethod(findFunction: (member: MethodSignature) => boolean): MethodSignature | undefined;\r\n    /**\r\n     * Gets the first method by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getMethodOrThrow(name: string): MethodSignature;\r\n    /**\r\n     * Gets the first method by a find function or throws if not found.\r\n     * @param findFunction - Function to find the method by.\r\n     */\r\n    getMethodOrThrow(findFunction: (member: MethodSignature) => boolean): MethodSignature;\r\n    /**\r\n     * Gets the interface method signatures.\r\n     */\r\n    getMethods(): MethodSignature[];\r\n    /**\r\n     * Add property.\r\n     * @param structure - Structure representing the property.\r\n     */\r\n    addProperty(structure: PropertySignatureStructure): PropertySignature;\r\n    /**\r\n     * Add properties.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    addProperties(structures: ReadonlyArray<PropertySignatureStructure>): PropertySignature[];\r\n    /**\r\n     * Insert property.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the property.\r\n     */\r\n    insertProperty(index: number, structure: PropertySignatureStructure): PropertySignature;\r\n    /**\r\n     * Insert properties.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    insertProperties(index: number, structures: ReadonlyArray<PropertySignatureStructure>): PropertySignature[];\r\n    /**\r\n     * Gets the first property by name.\r\n     * @param name - Name.\r\n     */\r\n    getProperty(name: string): PropertySignature | undefined;\r\n    /**\r\n     * Gets the first property by a find function.\r\n     * @param findFunction - Function to find the property by.\r\n     */\r\n    getProperty(findFunction: (member: PropertySignature) => boolean): PropertySignature | undefined;\r\n    /**\r\n     * Gets the first property by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getPropertyOrThrow(name: string): PropertySignature;\r\n    /**\r\n     * Gets the first property by a find function or throws if not found.\r\n     * @param findFunction - Function to find the property by.\r\n     */\r\n    getPropertyOrThrow(findFunction: (member: PropertySignature) => boolean): PropertySignature;\r\n    /**\r\n     * Gets the interface property signatures.\r\n     */\r\n    getProperties(): PropertySignature[];\r\n    /**\r\n     * Gets all the members.\r\n     */\r\n    getMembers(): TypeElementTypes[];\r\n}\r\n\r\ndeclare type TypeElementMemberedNodeExtensionType = Node<ts.Node & {\r\n    members: ts.TypeElement[];\r\n}>;\r\n\r\nexport declare function TypeParameteredNode<T extends Constructor<TypeParameteredNodeExtensionType>>(Base: T): Constructor<TypeParameteredNode> & T;\r\n\r\nexport interface TypeParameteredNode {\r\n    /**\r\n     * Gets a type parameter or undefined if it doesn't exist.\r\n     * @param name - Name of the parameter.\r\n     */\r\n    getTypeParameter(name: string): TypeParameterDeclaration | undefined;\r\n    /**\r\n     * Gets a type parameter or undefined if it doesn't exist.\r\n     * @param findFunction - Function to use to find the type parameter.\r\n     */\r\n    getTypeParameter(findFunction: (declaration: TypeParameterDeclaration) => boolean): TypeParameterDeclaration | undefined;\r\n    /**\r\n     * Gets a type parameter or throws if it doesn't exist.\r\n     * @param name - Name of the parameter.\r\n     */\r\n    getTypeParameterOrThrow(name: string): TypeParameterDeclaration;\r\n    /**\r\n     * Gets a type parameter or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the type parameter.\r\n     */\r\n    getTypeParameterOrThrow(findFunction: (declaration: TypeParameterDeclaration) => boolean): TypeParameterDeclaration;\r\n    /**\r\n     * Gets the type parameters.\r\n     */\r\n    getTypeParameters(): TypeParameterDeclaration[];\r\n    /**\r\n     * Adds a type parameter.\r\n     * @param structure - Structure of the type parameter.\r\n     */\r\n    addTypeParameter(structure: TypeParameterDeclarationStructure | string): TypeParameterDeclaration;\r\n    /**\r\n     * Adds type parameters.\r\n     * @param structures - Structures of the type parameters.\r\n     */\r\n    addTypeParameters(structures: ReadonlyArray<TypeParameterDeclarationStructure | string>): TypeParameterDeclaration[];\r\n    /**\r\n     * Inserts a type parameter.\r\n     * @param index - Child index to insert at. Specify a negative index to insert from the reverse.\r\n     * @param structure - Structure of the type parameter.\r\n     */\r\n    insertTypeParameter(index: number, structure: TypeParameterDeclarationStructure | string): TypeParameterDeclaration;\r\n    /**\r\n     * Inserts type parameters.\r\n     * @param index - Child index to insert at. Specify a negative index to insert from the reverse.\r\n     * @param structures - Structures of the type parameters.\r\n     */\r\n    insertTypeParameters(index: number, structures: ReadonlyArray<TypeParameterDeclarationStructure | string>): TypeParameterDeclaration[];\r\n}\r\n\r\ndeclare type TypeParameteredNodeExtensionType = Node<ts.Node & {\r\n    typeParameters?: ts.NodeArray<ts.TypeParameterDeclaration>;\r\n}>;\r\n\r\nexport declare function UnwrappableNode<T extends Constructor<UnwrappableNodeExtensionType>>(Base: T): Constructor<UnwrappableNode> & T;\r\n\r\nexport interface UnwrappableNode {\r\n    /**\r\n     * Replaces the node's text with its body's statements.\r\n     */\r\n    unwrap(): void;\r\n}\r\n\r\ndeclare type UnwrappableNodeExtensionType = Node;\r\n\r\nexport declare class ArrayBindingPattern extends Node<ts.ArrayBindingPattern> {\r\n    /**\r\n     * Gets the array binding pattern's elements.\r\n     */\r\n    getElements(): (BindingElement | OmittedExpression)[];\r\n}\r\n\r\ndeclare const BindingElementBase: Constructor<InitializerExpressionableNode> & Constructor<BindingNamedNode> & typeof Node;\r\n\r\nexport declare class BindingElement extends BindingElementBase<ts.BindingElement> {\r\n    /**\r\n     * Gets the binding element's dot dot dot token (...) if it exists or throws if not.\r\n     */\r\n    getDotDotDotTokenOrThrow(): Node<ts.Token<SyntaxKind.DotDotDotToken>>;\r\n    /**\r\n     * Gets the binding element's dot dot dot token (...) if it exists or returns undefined.\r\n     */\r\n    getDotDotDotToken(): Node<ts.Token<SyntaxKind.DotDotDotToken>> | undefined;\r\n    /**\r\n     * Gets binding element's property name node or throws if not found.\r\n     *\r\n     * For example in `const { a: b } = { a: 5 }`, `a` would be the property name.\r\n     */\r\n    getPropertyNameNodeOrThrow(): PropertyName;\r\n    /**\r\n     * Gets binding element's property name node or returns undefined if not found.\r\n     *\r\n     * For example in `const { a: b } = { a: 5 }`, `a` would be the property name.\r\n     */\r\n    getPropertyNameNode(): Identifier | NumericLiteral | StringLiteral | ComputedPropertyName | undefined;\r\n}\r\n\r\nexport declare class ObjectBindingPattern extends Node<ts.ObjectBindingPattern> {\r\n    /**\r\n     * Gets the object binding pattern's elements.\r\n     */\r\n    getElements(): BindingElement[];\r\n}\r\n\r\nexport declare function AbstractableNode<T extends Constructor<AbstractableNodeExtensionType>>(Base: T): Constructor<AbstractableNode> & T;\r\n\r\nexport interface AbstractableNode {\r\n    /**\r\n     * Gets if the node is abstract.\r\n     */\r\n    isAbstract(): boolean;\r\n    /**\r\n     * Gets the abstract keyword or undefined if it doesn't exist.\r\n     */\r\n    getAbstractKeyword(): Node | undefined;\r\n    /**\r\n     * Gets the abstract keyword or throws if it doesn't exist.\r\n     */\r\n    getAbstractKeywordOrThrow(): Node;\r\n    /**\r\n     * Sets if the node is abstract.\r\n     * @param isAbstract - If it should be abstract or not.\r\n     */\r\n    setIsAbstract(isAbstract: boolean): this;\r\n}\r\n\r\ndeclare type AbstractableNodeExtensionType = Node & ModifierableNode;\r\n\r\nexport declare function ClassLikeDeclarationBase<T extends Constructor<ClassLikeDeclarationBaseExtensionType>>(Base: T): Constructor<ClassLikeDeclarationBase> & T;\r\n\r\nexport interface ClassLikeDeclarationBase extends NameableNode, TextInsertableNode, ImplementsClauseableNode, HeritageClauseableNode, AbstractableNode, JSDocableNode, TypeParameteredNode, DecoratableNode, ModifierableNode, ClassLikeDeclarationBaseSpecific {\r\n}\r\n\r\ndeclare function ClassLikeDeclarationBaseSpecific<T extends Constructor<ClassLikeDeclarationBaseSpecificExtensionType>>(Base: T): Constructor<ClassLikeDeclarationBaseSpecific> & T;\r\n\r\ninterface ClassLikeDeclarationBaseSpecific {\r\n    /**\r\n     * Sets the extends expression.\r\n     * @param text - Text to set as the extends expression.\r\n     */\r\n    setExtends(text: string | WriterFunction): this;\r\n    /**\r\n     * Removes the extends expression, if it exists.\r\n     */\r\n    removeExtends(): this;\r\n    /**\r\n     * Gets the extends expression or throws if it doesn't exist.\r\n     */\r\n    getExtendsOrThrow(): ExpressionWithTypeArguments;\r\n    /**\r\n     * Gets the extends expression or returns undefined if it doesn't exist.\r\n     */\r\n    getExtends(): ExpressionWithTypeArguments | undefined;\r\n    /**\r\n     * Adds a constructor.\r\n     * @param structure - Structure of the constructor.\r\n     */\r\n    addConstructor(structure?: ConstructorDeclarationStructure): ConstructorDeclaration;\r\n    /**\r\n     * Adds constructors.\r\n     * @param structures - Structures of the constructor.\r\n     */\r\n    addConstructors(structures: ReadonlyArray<ConstructorDeclarationStructure>): ConstructorDeclaration[];\r\n    /**\r\n     * Inserts a constructor.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the constructor.\r\n     */\r\n    insertConstructor(index: number, structure?: ConstructorDeclarationStructure): ConstructorDeclaration;\r\n    /**\r\n     * Inserts constructors.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the constructor.\r\n     */\r\n    insertConstructors(index: number, structures: ReadonlyArray<ConstructorDeclarationStructure>): ConstructorDeclaration[];\r\n    /**\r\n     * Gets the constructor declarations.\r\n     */\r\n    getConstructors(): ConstructorDeclaration[];\r\n    /**\r\n     * Add get accessor.\r\n     * @param structure - Structure representing the get accessor.\r\n     */\r\n    addGetAccessor(structure: GetAccessorDeclarationStructure): GetAccessorDeclaration;\r\n    /**\r\n     * Add properties.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    addGetAccessors(structures: ReadonlyArray<GetAccessorDeclarationStructure>): GetAccessorDeclaration[];\r\n    /**\r\n     * Insert get accessor.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the get accessor.\r\n     */\r\n    insertGetAccessor(index: number, structure: GetAccessorDeclarationStructure): GetAccessorDeclaration;\r\n    /**\r\n     * Insert properties.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    insertGetAccessors(index: number, structures: ReadonlyArray<GetAccessorDeclarationStructure>): GetAccessorDeclaration[];\r\n    /**\r\n     * Add set accessor.\r\n     * @param structure - Structure representing the set accessor.\r\n     */\r\n    addSetAccessor(structure: SetAccessorDeclarationStructure): SetAccessorDeclaration;\r\n    /**\r\n     * Add properties.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    addSetAccessors(structures: ReadonlyArray<SetAccessorDeclarationStructure>): SetAccessorDeclaration[];\r\n    /**\r\n     * Insert set accessor.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the set accessor.\r\n     */\r\n    insertSetAccessor(index: number, structure: SetAccessorDeclarationStructure): SetAccessorDeclaration;\r\n    /**\r\n     * Insert properties.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    insertSetAccessors(index: number, structures: ReadonlyArray<SetAccessorDeclarationStructure>): SetAccessorDeclaration[];\r\n    /**\r\n     * Add property.\r\n     * @param structure - Structure representing the property.\r\n     */\r\n    addProperty(structure: PropertyDeclarationStructure): PropertyDeclaration;\r\n    /**\r\n     * Add properties.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    addProperties(structures: ReadonlyArray<PropertyDeclarationStructure>): PropertyDeclaration[];\r\n    /**\r\n     * Insert property.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the property.\r\n     */\r\n    insertProperty(index: number, structure: PropertyDeclarationStructure): PropertyDeclaration;\r\n    /**\r\n     * Insert properties.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    insertProperties(index: number, structures: ReadonlyArray<PropertyDeclarationStructure>): PropertyDeclaration[];\r\n    /**\r\n     * Gets the first instance property by name.\r\n     * @param name - Name.\r\n     */\r\n    getInstanceProperty(name: string): ClassInstancePropertyTypes | undefined;\r\n    /**\r\n     * Gets the first instance property by a find function.\r\n     * @param findFunction - Function to find an instance property by.\r\n     */\r\n    getInstanceProperty(findFunction: (prop: ClassInstancePropertyTypes) => boolean): ClassInstancePropertyTypes | undefined;\r\n    /**\r\n     * Gets the first instance property by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getInstancePropertyOrThrow(name: string): ClassInstancePropertyTypes;\r\n    /**\r\n     * Gets the first instance property by a find function or throws if not found.\r\n     * @param findFunction - Function to find an instance property by.\r\n     */\r\n    getInstancePropertyOrThrow(findFunction: (prop: ClassInstancePropertyTypes) => boolean): ClassInstancePropertyTypes;\r\n    /**\r\n     * Gets the class instance property declarations.\r\n     */\r\n    getInstanceProperties(): ClassInstancePropertyTypes[];\r\n    /**\r\n     * Gets the first static property by name.\r\n     * @param name - Name.\r\n     */\r\n    getStaticProperty(name: string): ClassStaticPropertyTypes | undefined;\r\n    /**\r\n     * Gets the first static property by a find function.\r\n     * @param findFunction - Function to find a static property by.\r\n     */\r\n    getStaticProperty(findFunction: (prop: ClassStaticPropertyTypes) => boolean): ClassStaticPropertyTypes | undefined;\r\n    /**\r\n     * Gets the first static property by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getStaticPropertyOrThrow(name: string): ClassStaticPropertyTypes;\r\n    /**\r\n     * Gets the first static property by a find function. or throws if not found.\r\n     * @param findFunction - Function to find a static property by.\r\n     */\r\n    getStaticPropertyOrThrow(findFunction: (prop: ClassStaticPropertyTypes) => boolean): ClassStaticPropertyTypes;\r\n    /**\r\n     * Gets the class instance property declarations.\r\n     */\r\n    getStaticProperties(): ClassStaticPropertyTypes[];\r\n    /**\r\n     * Gets the first property declaration by name.\r\n     * @param name - Name.\r\n     */\r\n    getProperty(name: string): PropertyDeclaration | undefined;\r\n    /**\r\n     * Gets the first property declaration by a find function.\r\n     * @param findFunction - Function to find a property declaration by.\r\n     */\r\n    getProperty(findFunction: (property: PropertyDeclaration) => boolean): PropertyDeclaration | undefined;\r\n    /**\r\n     * Gets the first property declaration by name or throws if it doesn't exist.\r\n     * @param name - Name.\r\n     */\r\n    getPropertyOrThrow(name: string): PropertyDeclaration;\r\n    /**\r\n     * Gets the first property declaration by a find function or throws if it doesn't exist.\r\n     * @param findFunction - Function to find a property declaration by.\r\n     */\r\n    getPropertyOrThrow(findFunction: (property: PropertyDeclaration) => boolean): PropertyDeclaration;\r\n    /**\r\n     * Gets the class property declarations regardless of whether it's an instance of static property.\r\n     */\r\n    getProperties(): PropertyDeclaration[];\r\n    /**\r\n     * Gets the first get accessor declaration by name.\r\n     * @param name - Name.\r\n     */\r\n    getGetAccessor(name: string): GetAccessorDeclaration | undefined;\r\n    /**\r\n     * Gets the first get accessor declaration by a find function.\r\n     * @param findFunction - Function to find a get accessor declaration by.\r\n     */\r\n    getGetAccessor(findFunction: (getAccessor: GetAccessorDeclaration) => boolean): GetAccessorDeclaration | undefined;\r\n    /**\r\n     * Gets the first get accessor declaration by name or throws if it doesn't exist.\r\n     * @param name - Name.\r\n     */\r\n    getGetAccessorOrThrow(name: string): GetAccessorDeclaration;\r\n    /**\r\n     * Gets the first get accessor declaration by a find function or throws if it doesn't exist.\r\n     * @param findFunction - Function to find a get accessor declaration by.\r\n     */\r\n    getGetAccessorOrThrow(findFunction: (getAccessor: GetAccessorDeclaration) => boolean): GetAccessorDeclaration;\r\n    /**\r\n     * Gets the class get accessor declarations regardless of whether it's an instance of static getAccessor.\r\n     */\r\n    getGetAccessors(): GetAccessorDeclaration[];\r\n    /**\r\n     * Sets the first set accessor declaration by name.\r\n     * @param name - Name.\r\n     */\r\n    getSetAccessor(name: string): SetAccessorDeclaration | undefined;\r\n    /**\r\n     * Sets the first set accessor declaration by a find function.\r\n     * @param findFunction - Function to find a set accessor declaration by.\r\n     */\r\n    getSetAccessor(findFunction: (setAccessor: SetAccessorDeclaration) => boolean): SetAccessorDeclaration | undefined;\r\n    /**\r\n     * Sets the first set accessor declaration by name or throws if it doesn't exist.\r\n     * @param name - Name.\r\n     */\r\n    getSetAccessorOrThrow(name: string): SetAccessorDeclaration;\r\n    /**\r\n     * Sets the first set accessor declaration by a find function or throws if it doesn't exist.\r\n     * @param findFunction - Function to find a set accessor declaration by.\r\n     */\r\n    getSetAccessorOrThrow(findFunction: (setAccessor: SetAccessorDeclaration) => boolean): SetAccessorDeclaration;\r\n    /**\r\n     * Sets the class set accessor declarations regardless of whether it's an instance of static setAccessor.\r\n     */\r\n    getSetAccessors(): SetAccessorDeclaration[];\r\n    /**\r\n     * Add method.\r\n     * @param structure - Structure representing the method.\r\n     */\r\n    addMethod(structure: MethodDeclarationStructure): MethodDeclaration;\r\n    /**\r\n     * Add methods.\r\n     * @param structures - Structures representing the methods.\r\n     */\r\n    addMethods(structures: ReadonlyArray<MethodDeclarationStructure>): MethodDeclaration[];\r\n    /**\r\n     * Insert method.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the method.\r\n     */\r\n    insertMethod(index: number, structure: MethodDeclarationStructure): MethodDeclaration;\r\n    /**\r\n     * Insert methods.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the methods.\r\n     */\r\n    insertMethods(index: number, structures: ReadonlyArray<MethodDeclarationStructure>): MethodDeclaration[];\r\n    /**\r\n     * Gets the first method declaration by name.\r\n     * @param name - Name.\r\n     */\r\n    getMethod(name: string): MethodDeclaration | undefined;\r\n    /**\r\n     * Gets the first method declaration by a find function.\r\n     * @param findFunction - Function to find a method declaration by.\r\n     */\r\n    getMethod(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration | undefined;\r\n    /**\r\n     * Gets the first method declaration by name or throws if it doesn't exist.\r\n     * @param name - Name.\r\n     */\r\n    getMethodOrThrow(name: string): MethodDeclaration;\r\n    /**\r\n     * Gets the first method declaration by a find function or throws if it doesn't exist.\r\n     * @param findFunction - Function to find a method declaration by.\r\n     */\r\n    getMethodOrThrow(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration;\r\n    /**\r\n     * Gets the class method declarations regardless of whether it's an instance of static method.\r\n     */\r\n    getMethods(): MethodDeclaration[];\r\n    /**\r\n     * Gets the first instance method by name.\r\n     * @param name - Name.\r\n     */\r\n    getInstanceMethod(name: string): MethodDeclaration | undefined;\r\n    /**\r\n     * Gets the first instance method by a find function.\r\n     * @param findFunction - Function to find an instance method by.\r\n     */\r\n    getInstanceMethod(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration | undefined;\r\n    /**\r\n     * Gets the first instance method by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getInstanceMethodOrThrow(name: string): MethodDeclaration;\r\n    /**\r\n     * Gets the first instance method by a find function. or throws if not found.\r\n     * @param findFunction - Function to find an instance method by.\r\n     */\r\n    getInstanceMethodOrThrow(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration;\r\n    /**\r\n     * Gets the class instance method declarations.\r\n     */\r\n    getInstanceMethods(): MethodDeclaration[];\r\n    /**\r\n     * Gets the first static method by name.\r\n     * @param name - Name.\r\n     */\r\n    getStaticMethod(name: string): MethodDeclaration | undefined;\r\n    /**\r\n     * Gets the first static method by a find function.\r\n     * @param findFunction - Function to find a static method by.\r\n     */\r\n    getStaticMethod(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration | undefined;\r\n    /**\r\n     * Gets the first static method by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getStaticMethodOrThrow(name: string): MethodDeclaration;\r\n    /**\r\n     * Gets the first static method by a find function. or throws if not found.\r\n     * @param findFunction - Function to find a static method by.\r\n     */\r\n    getStaticMethodOrThrow(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration;\r\n    /**\r\n     * Gets the class instance method declarations.\r\n     */\r\n    getStaticMethods(): MethodDeclaration[];\r\n    /**\r\n     * Gets the first instance member by name.\r\n     * @param name - Name.\r\n     */\r\n    getInstanceMember(name: string): ClassInstanceMemberTypes | undefined;\r\n    /**\r\n     * Gets the first instance member by a find function.\r\n     * @param findFunction - Function to find the instance member by.\r\n     */\r\n    getInstanceMember(findFunction: (member: ClassInstanceMemberTypes) => boolean): ClassInstanceMemberTypes | undefined;\r\n    /**\r\n     * Gets the first instance member by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getInstanceMemberOrThrow(name: string): ClassInstanceMemberTypes;\r\n    /**\r\n     * Gets the first instance member by a find function. or throws if not found.\r\n     * @param findFunction - Function to find the instance member by.\r\n     */\r\n    getInstanceMemberOrThrow(findFunction: (member: ClassInstanceMemberTypes) => boolean): ClassInstanceMemberTypes;\r\n    /**\r\n     * Gets the instance members.\r\n     */\r\n    getInstanceMembers(): ClassInstanceMemberTypes[];\r\n    /**\r\n     * Gets the first static member by name.\r\n     * @param name - Name.\r\n     */\r\n    getStaticMember(name: string): ClassStaticMemberTypes | undefined;\r\n    /**\r\n     * Gets the first static member by a find function.\r\n     * @param findFunction - Function to find an static method by.\r\n     */\r\n    getStaticMember(findFunction: (member: ClassStaticMemberTypes) => boolean): ClassStaticMemberTypes | undefined;\r\n    /**\r\n     * Gets the first static member by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getStaticMemberOrThrow(name: string): ClassStaticMemberTypes;\r\n    /**\r\n     * Gets the first static member by a find function. or throws if not found.\r\n     * @param findFunction - Function to find an static method by.\r\n     */\r\n    getStaticMemberOrThrow(findFunction: (member: ClassStaticMemberTypes) => boolean): ClassStaticMemberTypes;\r\n    /**\r\n     * Gets the static members.\r\n     */\r\n    getStaticMembers(): ClassStaticMemberTypes[];\r\n    /**\r\n     * Gets the class' members regardless of whether it's an instance of static member.\r\n     */\r\n    getMembers(): ClassMemberTypes[];\r\n    /**\r\n     * Gets the first member by name.\r\n     * @param name - Name.\r\n     */\r\n    getMember(name: string): ClassMemberTypes | undefined;\r\n    /**\r\n     * Gets the first member by a find function.\r\n     * @param findFunction - Function to find an method by.\r\n     */\r\n    getMember(findFunction: (member: ClassMemberTypes) => boolean): ClassMemberTypes | undefined;\r\n    /**\r\n     * Gets the first member by name or throws if not found.\r\n     * @param name - Name.\r\n     */\r\n    getMemberOrThrow(name: string): ClassMemberTypes;\r\n    /**\r\n     * Gets the first member by a find function. or throws if not found.\r\n     * @param findFunction - Function to find an method by.\r\n     */\r\n    getMemberOrThrow(findFunction: (member: ClassMemberTypes) => boolean): ClassMemberTypes;\r\n    /**\r\n     * Gets the base types.\r\n     *\r\n     * This is useful to use if the base could possibly be a mixin.\r\n     */\r\n    getBaseTypes(): Type[];\r\n    /**\r\n     * Gets the base class or throws.\r\n     *\r\n     * Note: Use getBaseTypes if you need to get the mixins.\r\n     */\r\n    getBaseClassOrThrow(): ClassDeclaration;\r\n    /**\r\n     * Gets the base class.\r\n     *\r\n     * Note: Use getBaseTypes if you need to get the mixins.\r\n     */\r\n    getBaseClass(): ClassDeclaration | undefined;\r\n    /**\r\n     * Gets all the derived classes.\r\n     */\r\n    getDerivedClasses(): ClassDeclaration[];\r\n}\r\n\r\nexport declare type ClassPropertyTypes = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;\r\n\r\nexport declare type ClassInstancePropertyTypes = ClassPropertyTypes | ParameterDeclaration;\r\n\r\nexport declare type ClassInstanceMemberTypes = MethodDeclaration | ClassInstancePropertyTypes;\r\n\r\nexport declare type ClassStaticPropertyTypes = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;\r\n\r\nexport declare type ClassStaticMemberTypes = MethodDeclaration | ClassStaticPropertyTypes;\r\n\r\nexport declare type ClassMemberTypes = MethodDeclaration | PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration;\r\n\r\ndeclare type ClassLikeDeclarationBaseExtensionType = Node<ts.ClassLikeDeclarationBase>;\r\n\r\ndeclare type ClassLikeDeclarationBaseSpecificExtensionType = Node<ts.ClassLikeDeclarationBase> & HeritageClauseableNode & ModifierableNode & NameableNode;\r\n\r\ndeclare const ClassDeclarationBase: Constructor<ChildOrderableNode> & Constructor<NamespaceChildableNode> & Constructor<AmbientableNode> & Constructor<ExportableNode> & Constructor<ClassLikeDeclarationBase> & typeof Statement;\r\n\r\nexport declare class ClassDeclaration extends ClassDeclarationBase<ts.ClassDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ClassDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ClassDeclarationStructure;\r\n    /**\r\n     * Extracts an interface declaration structure from the class.\r\n     * @param name - Name of the interface. Falls back to the same name as the class and then the filepath's base name.\r\n     */\r\n    extractInterface(name?: string): InterfaceDeclarationStructure;\r\n    /**\r\n     * Extracts an interface declaration structure from the static part of the class.\r\n     * @param name - Name of the interface.\r\n     */\r\n    extractStaticInterface(name: string): InterfaceDeclarationStructure;\r\n}\r\n\r\ndeclare const ClassExpressionBase: Constructor<ClassLikeDeclarationBase> & typeof PrimaryExpression;\r\n\r\nexport declare class ClassExpression extends ClassExpressionBase<ts.ClassExpression> {\r\n}\r\n\r\ndeclare const ConstructorDeclarationBase: Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<OverloadableNode> & Constructor<ScopedNode> & Constructor<FunctionLikeDeclaration> & Constructor<BodyableNode> & typeof Node;\r\n\r\ndeclare const ConstructorDeclarationOverloadBase: Constructor<TypeParameteredNode> & Constructor<JSDocableNode> & Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<ScopedNode> & Constructor<ModifierableNode> & Constructor<SignaturedDeclaration> & typeof Node;\r\n\r\nexport declare class ConstructorDeclaration extends ConstructorDeclarationBase<ts.ConstructorDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ConstructorDeclarationStructure>): this;\r\n    /**\r\n     * Add a constructor overload.\r\n     * @param structure - Structure to add.\r\n     */\r\n    addOverload(structure: ConstructorDeclarationOverloadStructure): ConstructorDeclaration;\r\n    /**\r\n     * Add constructor overloads.\r\n     * @param structures - Structures to add.\r\n     */\r\n    addOverloads(structures: ReadonlyArray<ConstructorDeclarationOverloadStructure>): ConstructorDeclaration[];\r\n    /**\r\n     * Inserts a constructor overload.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structures to insert.\r\n     */\r\n    insertOverload(index: number, structure: ConstructorDeclarationOverloadStructure): ConstructorDeclaration;\r\n    /**\r\n     * Inserts constructor overloads.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures to insert.\r\n     */\r\n    insertOverloads(index: number, structures: ReadonlyArray<ConstructorDeclarationOverloadStructure>): ConstructorDeclaration[];\r\n    /**\r\n     * Remove the constructor.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ConstructorDeclarationStructure | ConstructorDeclarationOverloadStructure;\r\n}\r\n\r\ndeclare const GetAccessorDeclarationBase: Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<DecoratableNode> & Constructor<AbstractableNode> & Constructor<ScopedNode> & Constructor<StaticableNode> & Constructor<FunctionLikeDeclaration> & Constructor<BodyableNode> & Constructor<PropertyNamedNode> & typeof Node;\r\n\r\nexport declare class GetAccessorDeclaration extends GetAccessorDeclarationBase<ts.GetAccessorDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<GetAccessorDeclarationStructure>): this;\r\n    /**\r\n     * Gets the corresponding set accessor if one exists.\r\n     */\r\n    getSetAccessor(): SetAccessorDeclaration | undefined;\r\n    /**\r\n     * Gets the corresponding set accessor or throws if not exists.\r\n     */\r\n    getSetAccessorOrThrow(): SetAccessorDeclaration;\r\n    /**\r\n     * Removes the get accessor.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): GetAccessorDeclarationStructure;\r\n}\r\n\r\ndeclare const MethodDeclarationBase: Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<OverloadableNode> & Constructor<BodyableNode> & Constructor<DecoratableNode> & Constructor<AbstractableNode> & Constructor<ScopedNode> & Constructor<QuestionTokenableNode> & Constructor<StaticableNode> & Constructor<AsyncableNode> & Constructor<GeneratorableNode> & Constructor<FunctionLikeDeclaration> & Constructor<PropertyNamedNode> & typeof Node;\r\n\r\ndeclare const MethodDeclarationOverloadBase: Constructor<JSDocableNode> & Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<ScopedNode> & Constructor<TypeParameteredNode> & Constructor<AbstractableNode> & Constructor<QuestionTokenableNode> & Constructor<StaticableNode> & Constructor<AsyncableNode> & Constructor<ModifierableNode> & Constructor<GeneratorableNode> & Constructor<SignaturedDeclaration> & typeof Node;\r\n\r\nexport declare class MethodDeclaration extends MethodDeclarationBase<ts.MethodDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<MethodDeclarationStructure>): this;\r\n    /**\r\n     * Add a method overload.\r\n     * @param structure - Structure to add.\r\n     */\r\n    addOverload(structure: MethodDeclarationOverloadStructure): MethodDeclaration;\r\n    /**\r\n     * Add method overloads.\r\n     * @param structures - Structures to add.\r\n     */\r\n    addOverloads(structures: ReadonlyArray<MethodDeclarationOverloadStructure>): MethodDeclaration[];\r\n    /**\r\n     * Inserts a method overload.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structures to insert.\r\n     */\r\n    insertOverload(index: number, structure: MethodDeclarationOverloadStructure): MethodDeclaration;\r\n    /**\r\n     * Inserts method overloads.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures to insert.\r\n     */\r\n    insertOverloads(index: number, structures: ReadonlyArray<MethodDeclarationOverloadStructure>): MethodDeclaration[];\r\n    /**\r\n     * Removes the method.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): MethodDeclarationStructure | MethodDeclarationOverloadStructure;\r\n}\r\n\r\ndeclare const PropertyDeclarationBase: Constructor<ChildOrderableNode> & Constructor<DecoratableNode> & Constructor<AbstractableNode> & Constructor<ScopedNode> & Constructor<StaticableNode> & Constructor<JSDocableNode> & Constructor<ReadonlyableNode> & Constructor<ExclamationTokenableNode> & Constructor<QuestionTokenableNode> & Constructor<InitializerExpressionableNode> & Constructor<TypedNode> & Constructor<PropertyNamedNode> & Constructor<ModifierableNode> & typeof Node;\r\n\r\nexport declare class PropertyDeclaration extends PropertyDeclarationBase<ts.PropertyDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<PropertyDeclarationStructure>): this;\r\n    /**\r\n     * Removes the property.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): PropertyDeclarationStructure;\r\n}\r\n\r\ndeclare const SetAccessorDeclarationBase: Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<DecoratableNode> & Constructor<AbstractableNode> & Constructor<ScopedNode> & Constructor<StaticableNode> & Constructor<FunctionLikeDeclaration> & Constructor<BodyableNode> & Constructor<PropertyNamedNode> & typeof Node;\r\n\r\nexport declare class SetAccessorDeclaration extends SetAccessorDeclarationBase<ts.SetAccessorDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<SetAccessorDeclarationStructure>): this;\r\n    /**\r\n     * Gets the corresponding get accessor if one exists.\r\n     */\r\n    getGetAccessor(): GetAccessorDeclaration | undefined;\r\n    /**\r\n     * Gets the corresponding get accessor or throws if not exists.\r\n     */\r\n    getGetAccessorOrThrow(): GetAccessorDeclaration;\r\n    /**\r\n     * Removes the set accessor.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): SetAccessorDeclarationStructure;\r\n}\r\n\r\nexport declare class CommentRange {\r\n    private constructor();\r\n    /**\r\n     * Gets the underlying compiler object.\r\n     */\r\n    readonly compilerObject: ts.CommentRange;\r\n    /**\r\n     * Gets the source file of the comment range.\r\n     */\r\n    getSourceFile(): SourceFile;\r\n    /**\r\n     * Gets the comment syntax kind.\r\n     */\r\n    getKind(): ts.CommentKind;\r\n    /**\r\n     * Gets the position.\r\n     */\r\n    getPos(): number;\r\n    /**\r\n     * Gets the end.\r\n     */\r\n    getEnd(): number;\r\n    /**\r\n     * Gets the width of the comment range.\r\n     */\r\n    getWidth(): number;\r\n    /**\r\n     * Gets the text of the comment range.\r\n     */\r\n    getText(): string;\r\n    /**\r\n     * Gets if the comment range was forgotten.\r\n     *\r\n     * This will be true after any manipulations have occured to the source file this comment range was generated from.\r\n     */\r\n    wasForgotten(): boolean;\r\n    private _throwIfForgotten;\r\n}\r\n\r\nexport declare class ComputedPropertyName extends Node<ts.ComputedPropertyName> {\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    getExpression(): Expression;\r\n}\r\n\r\ndeclare const IdentifierBase: Constructor<ReferenceFindableNode> & Constructor<RenameableNode> & typeof PrimaryExpression;\r\n\r\nexport declare class Identifier extends IdentifierBase<ts.Identifier> {\r\n    /**\r\n     * Gets the text for the identifier.\r\n     */\r\n    getText(): string;\r\n    /**\r\n     * Gets the definition nodes of the identifier.\r\n     * @remarks This is similar to \"go to definition\" and `.getDefinitions()`, but only returns the nodes.\r\n     */\r\n    getDefinitionNodes(): Node[];\r\n    /**\r\n     * Gets the definitions of the identifier.\r\n     * @remarks This is similar to \"go to definition.\" Use `.getDefinitionNodes()` if you only care about the nodes.\r\n     */\r\n    getDefinitions(): DefinitionInfo[];\r\n    /**\r\n     * Gets the implementations of the identifier.\r\n     *\r\n     * This is similar to \"go to implementation.\"\r\n     */\r\n    getImplementations(): ImplementationLocation[];\r\n}\r\n\r\nexport interface ForEachChildTraversalControl {\r\n    /**\r\n     * Stops traversal.\r\n     */\r\n    stop(): void;\r\n}\r\n\r\nexport interface ForEachDescendantTraversalControl extends ForEachChildTraversalControl {\r\n    /**\r\n     * Skips traversal of the current node's descendants.\r\n     */\r\n    skip(): void;\r\n    /**\r\n     * Skips traversal of the current node, siblings, and all their descendants.\r\n     */\r\n    up(): void;\r\n}\r\n\r\nexport interface TransformTraversalControl {\r\n    /**\r\n     * The node currently being transformed.\r\n     * @remarks Use the result of `.visitChildren()` instead before transforming if visiting the children.\r\n     */\r\n    currentNode: ts.Node;\r\n    /**\r\n     * Visits the children of the current node and returns a new node for the current node.\r\n     */\r\n    visitChildren(): ts.Node;\r\n}\r\n\r\nexport declare type NodePropertyToWrappedType<NodeType extends ts.Node, KeyName extends keyof NodeType, NonNullableNodeType = NonNullable<NodeType[KeyName]>> = NodeType[KeyName] extends ts.NodeArray<infer ArrayNodeTypeForNullable> | undefined ? CompilerNodeToWrappedType<ArrayNodeTypeForNullable>[] | undefined : NodeType[KeyName] extends ts.NodeArray<infer ArrayNodeType> ? CompilerNodeToWrappedType<ArrayNodeType>[] : NodeType[KeyName] extends ts.Node ? CompilerNodeToWrappedType<NodeType[KeyName]> : NonNullableNodeType extends ts.Node ? CompilerNodeToWrappedType<NonNullableNodeType> | undefined : NodeType[KeyName];\r\n\r\nexport declare type NodeParentType<NodeType extends ts.Node> = NodeType extends ts.SourceFile ? CompilerNodeToWrappedType<NodeType[\"parent\"]> | undefined : ts.Node extends NodeType ? CompilerNodeToWrappedType<NodeType[\"parent\"]> | undefined : CompilerNodeToWrappedType<NodeType[\"parent\"]>;\r\n\r\nexport interface TextRange {\r\n    getPos(): number;\r\n    getEnd(): number;\r\n}\r\n\r\nexport declare class Node<NodeType extends ts.Node = ts.Node> implements TextRange {\r\n    /**\r\n     * Gets the underlying compiler node.\r\n     */\r\n    readonly compilerNode: NodeType;\r\n    protected constructor();\r\n    /**\r\n     * Releases the node and all its descendants from the underlying node cache and ast.\r\n     *\r\n     * This is useful if you want to improve the performance of manipulation by not tracking this node anymore.\r\n     */\r\n    forget(): void;\r\n    /**\r\n     * Forgets the descendants of this node.\r\n     */\r\n    forgetDescendants(): this;\r\n    /**\r\n     * Gets if the compiler node was forgotten.\r\n     *\r\n     * This will be true when the compiler node was forgotten or removed.\r\n     */\r\n    wasForgotten(): boolean;\r\n    /**\r\n     * Gets the syntax kind.\r\n     */\r\n    getKind(): SyntaxKind;\r\n    /**\r\n     * Gets the syntax kind name.\r\n     */\r\n    getKindName(): string;\r\n    /**\r\n     * Prints the node using the compiler's printer.\r\n     * @param options - Options.\r\n     */\r\n    print(options?: PrintNodeOptions): string;\r\n    /**\r\n     * Gets the symbol or throws an error if it doesn't exist.\r\n     */\r\n    getSymbolOrThrow(): Symbol;\r\n    /**\r\n     * Gets the compiler symbol or undefined if it doesn't exist.\r\n     */\r\n    getSymbol(): Symbol | undefined;\r\n    /**\r\n     * Gets the type of the node.\r\n     */\r\n    getType(): Type;\r\n    /**\r\n     * If the node contains the provided range (inclusive).\r\n     * @param pos - Start position.\r\n     * @param end - End position.\r\n     */\r\n    containsRange(pos: number, end: number): boolean;\r\n    /**\r\n     * Gets if the specified position is within a string.\r\n     * @param pos - Position.\r\n     */\r\n    isInStringAtPos(pos: number): boolean;\r\n    /**\r\n     * Gets the first child by a condition or throws.\r\n     * @param condition - Condition.\r\n     */\r\n    getFirstChildOrThrow<T extends Node>(condition?: (node: Node) => node is T): T;\r\n    /**\r\n     * Gets the first child by a condition or throws.\r\n     * @param condition - Condition.\r\n     */\r\n    getFirstChildOrThrow(condition?: (node: Node) => boolean): Node;\r\n    /**\r\n     * Gets the first child by a condition.\r\n     * @param condition - Condition.\r\n     */\r\n    getFirstChild<T extends Node>(condition?: (node: Node) => node is T): T | undefined;\r\n    /**\r\n     * Gets the first child by a condition.\r\n     * @param condition - Condition.\r\n     */\r\n    getFirstChild(condition?: (node: Node) => boolean): Node | undefined;\r\n    /**\r\n     * Gets the last child by a condition or throws.\r\n     * @param condition - Condition.\r\n     */\r\n    getLastChildOrThrow<T extends Node>(condition?: (node: Node) => node is T): T;\r\n    /**\r\n     * Gets the last child by a condition or throws.\r\n     * @param condition - Condition.\r\n     */\r\n    getLastChildOrThrow(condition?: (node: Node) => boolean): Node;\r\n    /**\r\n     * Gets the last child by a condition.\r\n     * @param condition - Condition.\r\n     */\r\n    getLastChild<T extends Node>(condition?: (node: Node) => node is T): T | undefined;\r\n    /**\r\n     * Gets the last child by a condition.\r\n     * @param condition - Condition.\r\n     */\r\n    getLastChild(condition?: (node: Node) => boolean): Node | undefined;\r\n    /**\r\n     * Gets the first descendant by a condition or throws.\r\n     * @param condition - Condition.\r\n     */\r\n    getFirstDescendantOrThrow<T extends Node>(condition?: (node: Node) => node is T): T;\r\n    /**\r\n     * Gets the first descendant by a condition or throws.\r\n     * @param condition - Condition.\r\n     */\r\n    getFirstDescendantOrThrow(condition?: (node: Node) => boolean): Node;\r\n    /**\r\n     * Gets the first descendant by a condition.\r\n     * @param condition - Condition.\r\n     */\r\n    getFirstDescendant<T extends Node>(condition?: (node: Node) => node is T): T | undefined;\r\n    /**\r\n     * Gets the first descendant by a condition.\r\n     * @param condition - Condition.\r\n     */\r\n    getFirstDescendant(condition?: (node: Node) => boolean): Node | undefined;\r\n    /**\r\n     * Gets the previous sibling or throws.\r\n     * @param condition - Optional condition for getting the previous sibling.\r\n     */\r\n    getPreviousSiblingOrThrow<T extends Node>(condition?: (node: Node) => node is T): T;\r\n    /**\r\n     * Gets the previous sibling or throws.\r\n     * @param condition - Optional condition for getting the previous sibling.\r\n     */\r\n    getPreviousSiblingOrThrow(condition?: (node: Node) => boolean): Node;\r\n    /**\r\n     * Gets the previous sibling.\r\n     * @param condition - Optional condition for getting the previous sibling.\r\n     */\r\n    getPreviousSibling<T extends Node>(condition?: (node: Node) => node is T): T | undefined;\r\n    /**\r\n     * Gets the previous sibling.\r\n     * @param condition - Optional condition for getting the previous sibling.\r\n     */\r\n    getPreviousSibling(condition?: (node: Node) => boolean): Node | undefined;\r\n    /**\r\n     * Gets the next sibling or throws.\r\n     * @param condition - Optional condition for getting the next sibling.\r\n     */\r\n    getNextSiblingOrThrow<T extends Node>(condition?: (node: Node) => node is T): T;\r\n    /**\r\n     * Gets the next sibling or throws.\r\n     * @param condition - Optional condition for getting the next sibling.\r\n     */\r\n    getNextSiblingOrThrow(condition?: (node: Node) => boolean): Node;\r\n    /**\r\n     * Gets the next sibling.\r\n     * @param condition - Optional condition for getting the next sibling.\r\n     */\r\n    getNextSibling<T extends Node>(condition?: (node: Node) => node is T): T | undefined;\r\n    /**\r\n     * Gets the next sibling.\r\n     * @param condition - Optional condition for getting the next sibling.\r\n     */\r\n    getNextSibling(condition?: (node: Node) => boolean): Node | undefined;\r\n    /**\r\n     * Gets the previous siblings.\r\n     *\r\n     * Note: Closest sibling is the zero index.\r\n     */\r\n    getPreviousSiblings(): Node[];\r\n    /**\r\n     * Gets the next siblings.\r\n     *\r\n     * Note: Closest sibling is the zero index.\r\n     */\r\n    getNextSiblings(): Node[];\r\n    /**\r\n     * Gets all the children of the node.\r\n     */\r\n    getChildren(): Node[];\r\n    /**\r\n     * Gets the child at the specified index.\r\n     * @param index - Index of the child.\r\n     */\r\n    getChildAtIndex(index: number): Node;\r\n    /**\r\n     * Gets the child syntax list or throws if it doesn't exist.\r\n     */\r\n    getChildSyntaxListOrThrow(): SyntaxList;\r\n    /**\r\n     * Gets the child syntax list if it exists.\r\n     */\r\n    getChildSyntaxList(): SyntaxList | undefined;\r\n    /**\r\n     * Invokes the `cbNode` callback for each child and the `cbNodeArray` for every array of nodes stored in properties of the node.\r\n     * If `cbNodeArray` is not defined, then it will pass every element of the array to `cbNode`.\r\n     *\r\n     * @remarks There exists a `traversal.stop()` function on the second parameter that allows stopping iteration.\r\n     * @param cbNode - Callback invoked for each child.\r\n     * @param cbNodeArray - Callback invoked for each array of nodes.\r\n     */\r\n    forEachChild(cbNode: (node: Node, traversal: ForEachChildTraversalControl) => void, cbNodeArray?: (nodes: Node[], traversal: ForEachChildTraversalControl) => void): void;\r\n    /**\r\n     * Invokes the `cbNode` callback for each descendant and the `cbNodeArray` for every array of nodes stored in properties of the node and descendant nodes.\r\n     * If `cbNodeArray` is not defined, then it will pass every element of the array to `cbNode`.\r\n     *\r\n     * @remarks There exists a `traversal` object on the second parameter that allows various control of iteration.\r\n     * @param cbNode - Callback invoked for each descendant.\r\n     * @param cbNodeArray - Callback invoked for each array of nodes.\r\n     */\r\n    forEachDescendant(cbNode: (node: Node, traversal: ForEachDescendantTraversalControl) => void, cbNodeArray?: (nodes: Node[], traversal: ForEachDescendantTraversalControl) => void): void;\r\n    /**\r\n     * Gets the node's descendants.\r\n     */\r\n    getDescendants(): Node[];\r\n    /**\r\n     * Gets the node's descendant statements.\r\n     */\r\n    getDescendantStatements(): Statement[];\r\n    /**\r\n     * Gets the number of children the node has.\r\n     */\r\n    getChildCount(): number;\r\n    /**\r\n     * Gets the child at the provided text position, or undefined if not found.\r\n     * @param pos - Text position to search for.\r\n     */\r\n    getChildAtPos(pos: number): Node | undefined;\r\n    /**\r\n     * Gets the most specific descendant at the provided text position, or undefined if not found.\r\n     * @param pos - Text position to search for.\r\n     */\r\n    getDescendantAtPos(pos: number): Node | undefined;\r\n    /**\r\n     * Gets the most specific descendant at the provided start text position with the specified width, or undefined if not found.\r\n     * @param start - Start text position to search for.\r\n     * @param width - Text length of the node to search for.\r\n     */\r\n    getDescendantAtStartWithWidth(start: number, width: number): Node | undefined;\r\n    /**\r\n     * Gets the source file text position where the node starts that includes the leading trivia (comments and whitespace).\r\n     */\r\n    getPos(): number;\r\n    /**\r\n     * Gets the source file text position where the node ends.\r\n     *\r\n     * @remarks This does not include the following trivia (comments and whitespace).\r\n     */\r\n    getEnd(): number;\r\n    /**\r\n     * Gets the source file text position where the node starts that does not include the leading trivia (comments and whitespace).\r\n     * @param includeJsDocComment - Whether to include the JS doc comment.\r\n     */\r\n    getStart(includeJsDocComment?: boolean): number;\r\n    /**\r\n     * Gets the source file text position of the end of the last significant token or the start of the source file.\r\n     */\r\n    getFullStart(): number;\r\n    /**\r\n     * Gets the first source file text position that is not whitespace.\r\n     */\r\n    getNonWhitespaceStart(): number;\r\n    /**\r\n     * Gets the text length of the node without trivia.\r\n     */\r\n    getWidth(): number;\r\n    /**\r\n     * Gets the text length of the node with trivia.\r\n     */\r\n    getFullWidth(): number;\r\n    /**\r\n     * Gets the node's leading trivia's text length.\r\n     */\r\n    getLeadingTriviaWidth(): number;\r\n    /**\r\n     * Gets the text length from the end of the current node to the next significant token or new line.\r\n     */\r\n    getTrailingTriviaWidth(): number;\r\n    /**\r\n     * Gets the text position of the next significant token or new line.\r\n     */\r\n    getTrailingTriviaEnd(): number;\r\n    /**\r\n     * Gets the text without leading trivia (comments and whitespace).\r\n     * @param includeJsDocComment\r\n     */\r\n    getText(includeJsDocComment?: boolean): string;\r\n    /**\r\n     * Gets the full text with leading trivia (comments and whitespace).\r\n     */\r\n    getFullText(): string;\r\n    /**\r\n     * Gets the combined modifier flags.\r\n     */\r\n    getCombinedModifierFlags(): ts.ModifierFlags;\r\n    /**\r\n     * Gets the source file.\r\n     */\r\n    getSourceFile(): SourceFile;\r\n    /**\r\n     * Gets a compiler node property wrapped in a Node.\r\n     * @param propertyName - Property name.\r\n     */\r\n    getNodeProperty<KeyType extends keyof LocalNodeType, LocalNodeType extends ts.Node = NodeType>(propertyName: KeyType): NodePropertyToWrappedType<LocalNodeType, KeyType>;\r\n    /**\r\n     * Goes up the tree getting all the parents in ascending order.\r\n     */\r\n    getAncestors(): Node[];\r\n    /**\r\n     * Get the node's parent.\r\n     */\r\n    getParent<T extends Node | undefined = NodeParentType<NodeType>>(): T;\r\n    /**\r\n     * Gets the parent or throws an error if it doesn't exist.\r\n     */\r\n    getParentOrThrow<T extends Node | undefined = NodeParentType<NodeType>>(): NonNullable<T>;\r\n    /**\r\n     * Goes up the parents (ancestors) of the node while a condition is true.\r\n     * Throws if the initial parent doesn't match the condition.\r\n     * @param condition - Condition that tests the parent to see if the expression is true.\r\n     */\r\n    getParentWhileOrThrow<T extends Node>(condition: (node: Node) => node is T): T;\r\n    /**\r\n     * Goes up the parents (ancestors) of the node while a condition is true.\r\n     * Throws if the initial parent doesn't match the condition.\r\n     * @param condition - Condition that tests the parent to see if the expression is true.\r\n     */\r\n    getParentWhileOrThrow(condition: (node: Node) => boolean): Node;\r\n    /**\r\n     * Goes up the parents (ancestors) of the node while a condition is true.\r\n     * Returns undefined if the initial parent doesn't match the condition.\r\n     * @param condition - Condition that tests the parent to see if the expression is true.\r\n     */\r\n    getParentWhile<T extends Node>(condition: (node: Node) => node is T): T | undefined;\r\n    /**\r\n     * Goes up the parents (ancestors) of the node while a condition is true.\r\n     * Returns undefined if the initial parent doesn't match the condition.\r\n     * @param condition - Condition that tests the parent to see if the expression is true.\r\n     */\r\n    getParentWhile(condition: (node: Node) => boolean): Node | undefined;\r\n    /**\r\n     * Goes up the parents (ancestors) of the node while the parent is the specified syntax kind.\r\n     * Throws if the initial parent is not the specified syntax kind.\r\n     * @param kind - Syntax kind to check for.\r\n     */\r\n    getParentWhileKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Goes up the parents (ancestors) of the node while the parent is the specified syntax kind.\r\n     * Returns undefined if the initial parent is not the specified syntax kind.\r\n     * @param kind - Syntax kind to check for.\r\n     */\r\n    getParentWhileKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the last token of this node. Usually this is a close brace.\r\n     */\r\n    getLastToken(): Node;\r\n    /**\r\n     * Gets if this node is in a syntax list.\r\n     */\r\n    isInSyntaxList(): boolean;\r\n    /**\r\n     * Gets the parent if it's a syntax list or throws an error otherwise.\r\n     */\r\n    getParentSyntaxListOrThrow(): SyntaxList;\r\n    /**\r\n     * Gets the parent if it's a syntax list.\r\n     */\r\n    getParentSyntaxList(): SyntaxList | undefined;\r\n    /**\r\n     * Gets the child index of this node relative to the parent.\r\n     */\r\n    getChildIndex(): number;\r\n    /**\r\n     * Gets the indentation level of the current node.\r\n     */\r\n    getIndentationLevel(): number;\r\n    /**\r\n     * Gets the child indentation level of the current node.\r\n     */\r\n    getChildIndentationLevel(): number;\r\n    /**\r\n     * Gets the indentation text.\r\n     * @param offset - Optional number of levels of indentation to add or remove.\r\n     */\r\n    getIndentationText(offset?: number): string;\r\n    /**\r\n     * Gets the next indentation level text.\r\n     * @param offset - Optional number of levels of indentation to add or remove.\r\n     */\r\n    getChildIndentationText(offset?: number): string;\r\n    /**\r\n     * Gets the position of the start of the line that this node starts on.\r\n     * @param includeJsDocComment - Whether to include the JS doc comment or not.\r\n     */\r\n    getStartLinePos(includeJsDocComment?: boolean): number;\r\n    /**\r\n     * Gets the line number at the start of the node.\r\n     * @param includeJsDocComment - Whether to include the JS doc comment or not.\r\n     */\r\n    getStartLineNumber(includeJsDocComment?: boolean): number;\r\n    /**\r\n     * Gets the line number of the end of the node.\r\n     */\r\n    getEndLineNumber(): number;\r\n    /**\r\n     * Gets if this is the first node on the current line.\r\n     */\r\n    isFirstNodeOnLine(): boolean;\r\n    /**\r\n     * Replaces the text of the current node with new text.\r\n     *\r\n     * This will forget the current node and return a new node that can be asserted or type guarded to the correct type.\r\n     * @param textOrWriterFunction - Text or writer function to replace with.\r\n     * @returns The new node.\r\n     */\r\n    replaceWithText(textOrWriterFunction: string | WriterFunction): Node;\r\n    /**\r\n     * Prepends the specified whitespace to current node.\r\n     * @param textOrWriterFunction - Text or writer function.\r\n     */\r\n    prependWhitespace(textOrWriterFunction: string | WriterFunction): void;\r\n    /**\r\n     * Appends the specified whitespace to current node.\r\n     * @param textOrWriterFunction - Text or writer function.\r\n     */\r\n    appendWhitespace(textOrWriterFunction: string | WriterFunction): void;\r\n    /**\r\n     * Formats the node's text using the internal TypeScript formatting API.\r\n     * @param settings - Format code settings.\r\n     */\r\n    formatText(settings?: FormatCodeSettings): void;\r\n    /**\r\n     * Transforms the node using the compiler api nodes and functions (experimental).\r\n     *\r\n     * WARNING: This will forget descendants of transformed nodes.\r\n     * @example Increments all the numeric literals in a source file.\r\n     * ```ts\r\n     * sourceFile.transform(traversal => {\r\n     *   const node = traversal.visitChildren(); // recommend always visiting the children first (post order)\r\n     *   if (ts.isNumericLiteral(node))\r\n     *     return ts.createNumericLiteral((parseInt(node.text, 10) + 1).toString());\r\n     *   return node;\r\n     * });\r\n     * ```\r\n     * @example Updates the class declaration node without visiting the children.\r\n     * ```ts\r\n     * const classDec = sourceFile.getClassOrThrow(\"MyClass\");\r\n     * classDec.transform(traversal => {\r\n     *   const node = traversal.currentNode;\r\n     *   return ts.updateClassDeclaration(node, undefined, undefined, ts.createIdentifier(\"MyUpdatedClass\"), undefined, undefined, []);\r\n     * });\r\n     * ```\r\n     */\r\n    transform(visitNode: (traversal: TransformTraversalControl) => ts.Node): this;\r\n    /**\r\n     * Gets the leading comment ranges of the current node.\r\n     */\r\n    getLeadingCommentRanges(): CommentRange[];\r\n    /**\r\n     * Gets the trailing comment ranges of the current node.\r\n     */\r\n    getTrailingCommentRanges(): CommentRange[];\r\n    /**\r\n     * Gets the children based on a kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getChildrenOfKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind][];\r\n    /**\r\n     * Gets the first child by syntax kind or throws an error if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstChildByKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the first child by syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstChildByKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the first child if it matches the specified syntax kind or throws an error if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstChildIfKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the first child if it matches the specified syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstChildIfKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the last child by syntax kind or throws an error if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getLastChildByKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the last child by syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getLastChildByKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the last child if it matches the specified syntax kind or throws an error if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getLastChildIfKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the last child if it matches the specified syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getLastChildIfKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the child at the specified index if it's the specified kind or throws an exception.\r\n     * @param index - Child index to get.\r\n     * @param kind - Expected kind.\r\n     */\r\n    getChildAtIndexIfKindOrThrow<TKind extends SyntaxKind>(index: number, kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the child at the specified index if it's the specified kind or returns undefined.\r\n     * @param index - Child index to get.\r\n     * @param kind - Expected kind.\r\n     */\r\n    getChildAtIndexIfKind<TKind extends SyntaxKind>(index: number, kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the previous sibiling if it matches the specified kind, or throws.\r\n     * @param kind - Kind to check.\r\n     */\r\n    getPreviousSiblingIfKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the next sibiling if it matches the specified kind, or throws.\r\n     * @param kind - Kind to check.\r\n     */\r\n    getNextSiblingIfKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the previous sibling if it matches the specified kind.\r\n     * @param kind - Kind to check.\r\n     */\r\n    getPreviousSiblingIfKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the next sibling if it matches the specified kind.\r\n     * @param kind - Kind to check.\r\n     */\r\n    getNextSiblingIfKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the parent if it's a certain syntax kind.\r\n     */\r\n    getParentIfKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the parent if it's a certain syntax kind of throws.\r\n     */\r\n    getParentIfKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the first ancestor by syntax kind or throws if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstAncestorByKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Get the first ancestor by syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstAncestorByKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the first ancestor that matches the provided condition or throws if not found.\r\n     * @param condition - Condition to match.\r\n     */\r\n    getFirstAncestorOrThrow<T extends Node>(condition?: (node: Node) => node is T): T;\r\n    /**\r\n     * Gets the first ancestor that matches the provided condition or throws if not found.\r\n     * @param condition - Condition to match.\r\n     */\r\n    getFirstAncestorOrThrow(condition?: (node: Node) => boolean): Node;\r\n    /**\r\n     * Gets the first ancestor that matches the provided condition or returns undefined if not found.\r\n     * @param condition - Condition to match.\r\n     */\r\n    getFirstAncestor<T extends Node>(condition?: (node: Node) => node is T): T | undefined;\r\n    /**\r\n     * Gets the first ancestor that matches the provided condition or returns undefined if not found.\r\n     * @param condition - Condition to match.\r\n     */\r\n    getFirstAncestor(condition?: (node: Node) => boolean): Node | undefined;\r\n    /**\r\n     * Gets the descendants that match a specified syntax kind.\r\n     * @param kind - Kind to check.\r\n     */\r\n    getDescendantsOfKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind][];\r\n    /**\r\n     * Gets the first descendant by syntax kind or throws.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstDescendantByKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Gets the first descendant by syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    getFirstDescendantByKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n}\r\n\r\nexport declare class QualifiedName extends Node<ts.QualifiedName> {\r\n    /**\r\n     * Gets the left side of the qualified name.\r\n     */\r\n    getLeft(): EntityName;\r\n    /**\r\n     * Gets the right identifier of the qualified name.\r\n     */\r\n    getRight(): Identifier;\r\n}\r\nexport declare enum Scope {\r\n    Public = \"public\",\r\n    Protected = \"protected\",\r\n    Private = \"private\"\r\n}\r\n\r\nexport declare class SyntaxList extends Node<ts.SyntaxList> {\r\n    /**\r\n     * Adds text at the end of the current children.\r\n     * @param textOrWriterFunction - Text to add or function that provides a writer to write with.\r\n     * @returns The children that were added.\r\n     */\r\n    addChildText(textOrWriterFunction: string | WriterFunction): Node<ts.Node>[];\r\n    /**\r\n     * Inserts text at the specified child index.\r\n     * @param index - Child index to insert at.\r\n     * @param textOrWriterFunction - Text to insert or function that provides a writer to write with.\r\n     * @returns The children that were inserted.\r\n     */\r\n    insertChildText(index: number, textOrWriterFunction: string | WriterFunction): Node<ts.Node>[];\r\n}\r\n\r\nexport declare type CompilerNodeToWrappedType<T extends ts.Node> = T extends ts.ObjectDestructuringAssignment ? ObjectDestructuringAssignment : T extends ts.ArrayDestructuringAssignment ? ArrayDestructuringAssignment : T extends ts.SuperElementAccessExpression ? SuperElementAccessExpression : T extends ts.SuperPropertyAccessExpression ? SuperPropertyAccessExpression : T extends ts.AssignmentExpression<infer U> ? AssignmentExpression<ts.AssignmentExpression<U>> : T[\"kind\"] extends keyof ImplementedKindToNodeMappings ? ImplementedKindToNodeMappings[T[\"kind\"]] : T extends ts.SyntaxList ? SyntaxList : T extends ts.JSDocTypeExpression ? JSDocTypeExpression : T extends ts.JSDocType ? JSDocType : T extends ts.TypeNode ? TypeNode : T extends ts.TypeElement ? TypeElement : T extends ts.JSDocTag ? JSDocTag : T extends ts.LiteralExpression ? LiteralExpression : T extends ts.PrimaryExpression ? PrimaryExpression : T extends ts.MemberExpression ? MemberExpression : T extends ts.LeftHandSideExpression ? LeftHandSideExpression : T extends ts.UpdateExpression ? UpdateExpression : T extends ts.UnaryExpression ? UnaryExpression : T extends ts.Expression ? Expression : T extends ts.IterationStatement ? IterationStatement : T extends ts.Statement ? Statement : Node<T>;\r\n\r\ndeclare const DecoratorBase: typeof Node;\r\n\r\nexport declare class Decorator extends DecoratorBase<ts.Decorator> {\r\n    /**\r\n     * Gets the decorator name.\r\n     */\r\n    getName(): string;\r\n    /**\r\n     * Gets the name node of the decorator.\r\n     */\r\n    getNameNode(): Identifier;\r\n    /**\r\n     * Gets the full decorator name.\r\n     */\r\n    getFullName(): string;\r\n    /**\r\n     * Gets if the decorator is a decorator factory.\r\n     */\r\n    isDecoratorFactory(): boolean;\r\n    /**\r\n     * Set if this decorator is a decorator factory.\r\n     * @param isDecoratorFactory - If it should be a decorator factory or not.\r\n     */\r\n    setIsDecoratorFactory(isDecoratorFactory: boolean): this;\r\n    /**\r\n     * Gets the call expression if a decorator factory, or throws.\r\n     */\r\n    getCallExpressionOrThrow(): CallExpression;\r\n    /**\r\n     * Gets the call expression if a decorator factory.\r\n     */\r\n    getCallExpression(): CallExpression | undefined;\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    getExpression(): Expression<ts.LeftHandSideExpression>;\r\n    /**\r\n     * Gets the decorator's arguments from its call expression.\r\n     */\r\n    getArguments(): Node[];\r\n    /**\r\n     * Gets the decorator's type arguments from its call expression.\r\n     */\r\n    getTypeArguments(): TypeNode[];\r\n    /**\r\n     * Adds a type argument.\r\n     * @param argumentTexts - Argument text.\r\n     */\r\n    addTypeArgument(argumentText: string): TypeNode<ts.TypeNode>;\r\n    /**\r\n     * Adds type arguments.\r\n     * @param argumentTexts - Argument texts.\r\n     */\r\n    addTypeArguments(argumentTexts: ReadonlyArray<string>): TypeNode<ts.TypeNode>[];\r\n    /**\r\n     * Inserts a type argument.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument text.\r\n     */\r\n    insertTypeArgument(index: number, argumentText: string): TypeNode<ts.TypeNode>;\r\n    /**\r\n     * Inserts type arguments.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument texts.\r\n     */\r\n    insertTypeArguments(index: number, argumentTexts: ReadonlyArray<string>): TypeNode<ts.TypeNode>[];\r\n    /**\r\n     * Removes a type argument.\r\n     * @param typeArg - Type argument to remove.\r\n     */\r\n    removeTypeArgument(typeArg: Node): this;\r\n    /**\r\n     * Removes a type argument.\r\n     * @param index - Index to remove.\r\n     */\r\n    removeTypeArgument(index: number): this;\r\n    /**\r\n     * Adds an argument.\r\n     * @param argumentTexts - Argument text.\r\n     */\r\n    addArgument(argumentText: string | WriterFunction): Node<ts.Node>;\r\n    /**\r\n     * Adds arguments.\r\n     * @param argumentTexts - Argument texts.\r\n     */\r\n    addArguments(argumentTexts: ReadonlyArray<string | WriterFunction> | WriterFunction): Node<ts.Node>[];\r\n    /**\r\n     * Inserts an argument.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument text.\r\n     */\r\n    insertArgument(index: number, argumentText: string | WriterFunction): Node<ts.Node>;\r\n    /**\r\n     * Inserts arguments.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument texts.\r\n     */\r\n    insertArguments(index: number, argumentTexts: ReadonlyArray<string | WriterFunction> | WriterFunction): Node<ts.Node>[];\r\n    /**\r\n     * Removes an argument based on the node.\r\n     * @param node - Argument's node to remove.\r\n     */\r\n    removeArgument(node: Node): this;\r\n    /**\r\n     * Removes an argument based on the specified index.\r\n     * @param index - Index to remove.\r\n     */\r\n    removeArgument(index: number): this;\r\n    /**\r\n     * Removes this decorator.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<DecoratorStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): DecoratorStructure;\r\n}\r\n\r\nexport declare function JSDocPropertyLikeTag<T extends Constructor<JSDocPropertyLikeTagExtensionType>>(Base: T): Constructor<JSDocPropertyLikeTag> & T;\r\n\r\nexport interface JSDocPropertyLikeTag {\r\n    /** Gets the type expression node of the JS doc property like tag. */\r\n    getTypeExpression(): JSDocTypeExpression | undefined;\r\n    /** Gets the name of the JS doc property like tag. */\r\n    getName(): string;\r\n    /** Gets the name node of the JS doc property like tag. */\r\n    getNameNode(): EntityName;\r\n    /** Checks if the JS doc property like tag is bracketed. */\r\n    isBracketed(): boolean;\r\n}\r\n\r\ndeclare type JSDocPropertyLikeTagExtensionType = Node<ts.JSDocPropertyLikeTag> & JSDocTag;\r\n\r\ndeclare const JSDocBase: typeof Node;\r\n\r\n/**\r\n * JS doc node.\r\n */\r\nexport declare class JSDoc extends JSDocBase<ts.JSDoc> {\r\n    /**\r\n     * Gets the tags of the JSDoc.\r\n     */\r\n    getTags(): JSDocTag[];\r\n    /**\r\n     * Gets the comment.\r\n     */\r\n    getComment(): string | undefined;\r\n    /**\r\n     * Gets the JSDoc's text without the surrounding comment.\r\n     */\r\n    getInnerText(): string;\r\n    /**\r\n     * Sets the comment.\r\n     * @param textOrWriterFunction - Text or writer function to set.\r\n     */\r\n    setComment(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Removes this JSDoc.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<JSDocStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): JSDocStructure;\r\n}\r\n\r\n/**\r\n * JS doc augments tag node.\r\n */\r\nexport declare class JSDocAugmentsTag extends JSDocTag<ts.JSDocAugmentsTag> {\r\n}\r\n\r\n/**\r\n * JS doc class tag node.\r\n */\r\nexport declare class JSDocClassTag extends JSDocTag<ts.JSDocClassTag> {\r\n}\r\n\r\ndeclare const JSDocFunctionTypeBase: Constructor<SignaturedDeclaration> & typeof JSDocType;\r\n\r\n/**\r\n * JS doc function type.\r\n */\r\nexport declare class JSDocFunctionType extends JSDocFunctionTypeBase<ts.JSDocFunctionType> {\r\n}\r\n\r\ndeclare const JSDocParameterTagBase: Constructor<JSDocPropertyLikeTag> & typeof JSDocTag;\r\n\r\n/**\r\n * JS doc parameter tag node.\r\n */\r\nexport declare class JSDocParameterTag extends JSDocParameterTagBase<ts.JSDocParameterTag> {\r\n}\r\n\r\ndeclare const JSDocPropertyTagBase: Constructor<JSDocPropertyLikeTag> & typeof JSDocTag;\r\n\r\n/**\r\n * JS doc property tag node.\r\n */\r\nexport declare class JSDocPropertyTag extends JSDocPropertyTagBase<ts.JSDocPropertyTag> {\r\n}\r\n\r\n/**\r\n * JS doc return tag node.\r\n */\r\nexport declare class JSDocReturnTag extends JSDocTag<ts.JSDocReturnTag> {\r\n    /**\r\n     * Gets the type expression node of the JS doc property return tag.\r\n     */\r\n    getTypeExpression(): JSDocTypeExpression | undefined;\r\n}\r\n\r\n/**\r\n * JS doc signature node.\r\n */\r\nexport declare class JSDocSignature extends JSDocType<ts.JSDocSignature> {\r\n    /**\r\n     * Gets the type node of the JS doc signature.\r\n     */\r\n    getTypeNode(): JSDocReturnTag | undefined;\r\n}\r\n\r\n/**\r\n * JS doc tag node.\r\n */\r\nexport declare class JSDocTag<NodeType extends ts.JSDocTag = ts.JSDocTag> extends Node<NodeType> {\r\n    /**\r\n     * Gets the tag's name as a string.\r\n     */\r\n    getTagName(): string;\r\n    /**\r\n     * Gets the tag name node.\r\n     */\r\n    getTagNameNode(): Identifier;\r\n    /**\r\n     * Gets the tag's comment.\r\n     */\r\n    getComment(): string | undefined;\r\n}\r\n\r\n/**\r\n * JS doc tag info.\r\n */\r\nexport declare class JSDocTagInfo {\r\n    private constructor();\r\n    /** Gets the compiler JS doc tag info. */\r\n    readonly compilerObject: ts.JSDocTagInfo;\r\n    /**\r\n     * Gets the name.\r\n     */\r\n    getName(): string;\r\n    /**\r\n     * Gets the text.\r\n     */\r\n    getText(): string | undefined;\r\n}\r\n\r\n/**\r\n * JS doc type node.\r\n */\r\nexport declare class JSDocType<T extends ts.JSDocType = ts.JSDocType> extends TypeNode<T> {\r\n}\r\n\r\n/**\r\n * JS doc type def tag node.\r\n */\r\nexport declare class JSDocTypedefTag extends JSDocTag<ts.JSDocTypedefTag> {\r\n}\r\n\r\n/**\r\n * JS doc type tag node.\r\n */\r\nexport declare class JSDocTypeTag extends JSDocTag<ts.JSDocTypeTag> {\r\n    /**\r\n     * Gets the type expression node of the JS doc property type tag.\r\n     */\r\n    getTypeExpression(): JSDocTypeExpression | undefined;\r\n}\r\n\r\n/**\r\n * JS doc unknown tag node.\r\n */\r\nexport declare class JSDocUnknownTag extends JSDocTag<ts.JSDocUnknownTag> {\r\n}\r\n\r\n/**\r\n * JS doc type expression node.\r\n */\r\nexport declare class JSDocTypeExpression extends TypeNode<ts.JSDocTypeExpression> {\r\n    /**\r\n     * Gets the type node of the JS doc type expression.\r\n     */\r\n    getTypeNode(): TypeNode<ts.TypeNode>;\r\n}\r\n\r\ndeclare const EnumDeclarationBase: Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<NamespaceChildableNode> & Constructor<JSDocableNode> & Constructor<AmbientableNode> & Constructor<ExportableNode> & Constructor<ModifierableNode> & Constructor<NamedNode> & typeof Statement;\r\n\r\nexport declare class EnumDeclaration extends EnumDeclarationBase<ts.EnumDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<EnumDeclarationStructure>): this;\r\n    /**\r\n     * Adds a member to the enum.\r\n     * @param structure - Structure of the enum.\r\n     */\r\n    addMember(structure: EnumMemberStructure): EnumMember;\r\n    /**\r\n     * Adds members to the enum.\r\n     * @param structures - Structures of the enums.\r\n     */\r\n    addMembers(structures: ReadonlyArray<EnumMemberStructure>): EnumMember[];\r\n    /**\r\n     * Inserts a member to the enum.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the enum.\r\n     */\r\n    insertMember(index: number, structure: EnumMemberStructure): EnumMember;\r\n    /**\r\n     * Inserts members to an enum.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the enums.\r\n     */\r\n    insertMembers(index: number, structures: ReadonlyArray<EnumMemberStructure>): EnumMember[];\r\n    /**\r\n     * Gets an enum member.\r\n     * @param name - Name of the member.\r\n     */\r\n    getMember(name: string): EnumMember | undefined;\r\n    /**\r\n     * Gets an enum member.\r\n     * @param findFunction - Function to use to find the member.\r\n     */\r\n    getMember(findFunction: (declaration: EnumMember) => boolean): EnumMember | undefined;\r\n    /**\r\n     * Gets an enum member or throws if not found.\r\n     * @param name - Name of the member.\r\n     */\r\n    getMemberOrThrow(name: string): EnumMember;\r\n    /**\r\n     * Gets an enum member or throws if not found.\r\n     * @param findFunction - Function to use to find the member.\r\n     */\r\n    getMemberOrThrow(findFunction: (declaration: EnumMember) => boolean): EnumMember;\r\n    /**\r\n     * Gets the enum's members.\r\n     */\r\n    getMembers(): EnumMember[];\r\n    /**\r\n     * Toggle if it's a const enum.\r\n     */\r\n    setIsConstEnum(value: boolean): this;\r\n    /**\r\n     * Gets if it's a const enum.\r\n     */\r\n    isConstEnum(): boolean;\r\n    /**\r\n     * Gets the const enum keyword or undefined if not exists.\r\n     */\r\n    getConstKeyword(): Node<ts.Node> | undefined;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): EnumDeclarationStructure;\r\n}\r\n\r\ndeclare const EnumMemberBase: Constructor<JSDocableNode> & Constructor<InitializerExpressionableNode> & Constructor<PropertyNamedNode> & typeof Node;\r\n\r\nexport declare class EnumMember extends EnumMemberBase<ts.EnumMember> {\r\n    /**\r\n     * Gets the constant value of the enum.\r\n     */\r\n    getValue(): string | number | undefined;\r\n    /**\r\n     * Sets the enum value.\r\n     * @param value - Enum value.\r\n     */\r\n    setValue(value: string | number): this;\r\n    /**\r\n     * Removes this enum member.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<EnumMemberStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): EnumMemberStructure;\r\n}\r\n\r\ndeclare const ArrayDestructuringAssignmentBase: typeof AssignmentExpression;\r\n\r\nexport declare class ArrayDestructuringAssignment extends ArrayDestructuringAssignmentBase<ts.ArrayDestructuringAssignment> {\r\n    /**\r\n     * Gets the left array literal expression of the array destructuring assignment.\r\n     */\r\n    getLeft(): ArrayLiteralExpression;\r\n}\r\n\r\nexport declare class ArrayLiteralExpression extends PrimaryExpression<ts.ArrayLiteralExpression> {\r\n    /**\r\n     * Gets the array's elements.\r\n     */\r\n    getElements(): Expression[];\r\n    /**\r\n     * Adds an element to the array.\r\n     * @param textOrWriterFunction - Text to add as an element.\r\n     * @param options - Options.\r\n     */\r\n    addElement(textOrWriterFunction: string | WriterFunction, options?: {\r\n        useNewLines?: boolean;\r\n    }): Expression<ts.Expression>;\r\n    /**\r\n     * Adds elements to the array.\r\n     * @param textsOrWriterFunction - Texts to add as elements.\r\n     * @param options - Options.\r\n     */\r\n    addElements(textsOrWriterFunction: ReadonlyArray<string | WriterFunction> | WriterFunction, options?: {\r\n        useNewLines?: boolean;\r\n    }): Expression<ts.Expression>[];\r\n    /**\r\n     * Insert an element into the array.\r\n     * @param index - Child index to insert at.\r\n     * @param text - Text to insert as an element.\r\n     * @param options - Options.\r\n     */\r\n    insertElement(index: number, textOrWriterFunction: string | WriterFunction, options?: {\r\n        useNewLines?: boolean;\r\n    }): Expression<ts.Expression>;\r\n    /**\r\n     * Insert elements into the array.\r\n     * @param index - Child index to insert at.\r\n     * @param textsOrWriterFunction - Texts to insert as elements.\r\n     * @param options - Options.\r\n     */\r\n    insertElements(index: number, textsOrWriterFunction: ReadonlyArray<string | WriterFunction> | WriterFunction, options?: {\r\n        useNewLines?: boolean;\r\n    }): Expression<ts.Expression>[];\r\n    /**\r\n     * Removes an element from the array.\r\n     * @param index - Index to remove from.\r\n     */\r\n    removeElement(index: number): void;\r\n    /**\r\n     * Removes an element from the array.\r\n     * @param element - Element to remove.\r\n     */\r\n    removeElement(element: Expression): void;\r\n}\r\n\r\ndeclare const AsExpressionBase: Constructor<TypedNode> & Constructor<ExpressionedNode> & typeof Expression;\r\n\r\nexport declare class AsExpression extends AsExpressionBase<ts.AsExpression> {\r\n}\r\n\r\ndeclare const AssignmentExpressionBase: typeof BinaryExpression;\r\n\r\nexport declare class AssignmentExpression<T extends ts.AssignmentExpression<ts.AssignmentOperatorToken> = ts.AssignmentExpression<ts.AssignmentOperatorToken>> extends AssignmentExpressionBase<T> {\r\n    /**\r\n     * Gets the operator token of the assignment expression.\r\n     */\r\n    getOperatorToken(): Node<ts.Token<ts.AssignmentOperator>>;\r\n}\r\n\r\ndeclare const AwaitExpressionBase: Constructor<UnaryExpressionedNode> & typeof UnaryExpression;\r\n\r\nexport declare class AwaitExpression extends AwaitExpressionBase<ts.AwaitExpression> {\r\n}\r\n\r\ndeclare const BinaryExpressionBase: typeof Expression;\r\n\r\nexport declare class BinaryExpression<T extends ts.BinaryExpression = ts.BinaryExpression> extends BinaryExpressionBase<T> {\r\n    /**\r\n     * Gets the left side of the binary expression.\r\n     */\r\n    getLeft(): Expression;\r\n    /**\r\n     * Gets the operator token of the binary expression.\r\n     */\r\n    getOperatorToken(): Node<ts.Token<ts.BinaryOperator>>;\r\n    /**\r\n     * Gets the right side of the binary expression.\r\n     */\r\n    getRight(): Expression;\r\n}\r\n\r\ndeclare const CallExpressionBase: Constructor<TypeArgumentedNode> & Constructor<ArgumentedNode> & Constructor<LeftHandSideExpressionedNode> & typeof LeftHandSideExpression;\r\n\r\nexport declare class CallExpression<T extends ts.CallExpression = ts.CallExpression> extends CallExpressionBase<T> {\r\n    /**\r\n     * Gets the return type of the call expression.\r\n     */\r\n    getReturnType(): Type;\r\n}\r\n\r\ndeclare const CommaListExpressionBase: typeof Expression;\r\n\r\nexport declare class CommaListExpression extends CommaListExpressionBase<ts.CommaListExpression> {\r\n    /**\r\n     * Gets the elements.\r\n     */\r\n    getElements(): Expression[];\r\n}\r\n\r\ndeclare const ConditionalExpressionBase: typeof Expression;\r\n\r\nexport declare class ConditionalExpression extends ConditionalExpressionBase<ts.ConditionalExpression> {\r\n    /**\r\n     * Gets the condition of the conditional expression.\r\n     */\r\n    getCondition(): Expression;\r\n    /**\r\n     * Gets the question token of the conditional expression.\r\n     */\r\n    getQuestionToken(): Node<ts.Token<SyntaxKind.QuestionToken>>;\r\n    /**\r\n     * Gets the when true expression of the conditional expression.\r\n     */\r\n    getWhenTrue(): Expression;\r\n    /**\r\n     * Gets the colon token of the conditional expression.\r\n     */\r\n    getColonToken(): Node<ts.Token<SyntaxKind.ColonToken>>;\r\n    /**\r\n     * Gets the when false expression of the conditional expression.\r\n     */\r\n    getWhenFalse(): Expression;\r\n}\r\n\r\ndeclare const DeleteExpressionBase: Constructor<UnaryExpressionedNode> & typeof UnaryExpression;\r\n\r\nexport declare class DeleteExpression extends DeleteExpressionBase<ts.DeleteExpression> {\r\n}\r\n\r\ndeclare const ElementAccessExpressionBase: Constructor<LeftHandSideExpressionedNode> & typeof MemberExpression;\r\n\r\nexport declare class ElementAccessExpression<T extends ts.ElementAccessExpression = ts.ElementAccessExpression> extends ElementAccessExpressionBase<T> {\r\n    /**\r\n     * Gets this element access expression's argument expression or undefined if none exists.\r\n     */\r\n    getArgumentExpression(): Expression | undefined;\r\n    /**\r\n     * Gets this element access expression's argument expression or throws if none exists.\r\n     */\r\n    getArgumentExpressionOrThrow(): Expression<ts.Expression>;\r\n}\r\n\r\nexport declare class Expression<T extends ts.Expression = ts.Expression> extends Node<T> {\r\n    /**\r\n     * Gets the contextual type of the expression.\r\n     */\r\n    getContextualType(): Type | undefined;\r\n}\r\n\r\nexport declare function ExpressionedNode<T extends Constructor<ExpressionedNodeExtensionType>>(Base: T): Constructor<ExpressionedNode> & T;\r\n\r\nexport interface ExpressionedNode {\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    getExpression(): Expression;\r\n    /**\r\n     * Sets the expression.\r\n     * @param textOrWriterFunction - Text to set the expression with.\r\n     */\r\n    setExpression(textOrWriterFunction: string | WriterFunction): this;\r\n}\r\n\r\ndeclare type ExpressionedNodeExtensionType = Node<ts.Node & {\r\n    expression: ts.Expression;\r\n}>;\r\n\r\nexport declare function ImportExpressionedNode<T extends Constructor<ImportExpressionedNodeExtensionType>>(Base: T): Constructor<ImportExpressionedNode> & T;\r\n\r\nexport interface ImportExpressionedNode {\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    getExpression(): ImportExpression;\r\n}\r\n\r\ndeclare type ImportExpressionedNodeExtensionType = Node<ts.Node & {\r\n    expression: ts.ImportExpression;\r\n}>;\r\n\r\nexport declare function LeftHandSideExpressionedNode<T extends Constructor<LeftHandSideExpressionedNodeExtensionType>>(Base: T): Constructor<LeftHandSideExpressionedNode> & T;\r\n\r\nexport interface LeftHandSideExpressionedNode {\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    getExpression(): LeftHandSideExpression;\r\n}\r\n\r\ndeclare type LeftHandSideExpressionedNodeExtensionType = Node<ts.Node & {\r\n    expression: ts.LeftHandSideExpression;\r\n}>;\r\n\r\nexport declare function SuperExpressionedNode<T extends Constructor<SuperExpressionedNodeExtensionType>>(Base: T): Constructor<SuperExpressionedNode> & T;\r\n\r\nexport interface SuperExpressionedNode {\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    getExpression(): SuperExpression;\r\n}\r\n\r\ndeclare type SuperExpressionedNodeExtensionType = Node<ts.Node & {\r\n    expression: ts.SuperExpression;\r\n}>;\r\n\r\nexport declare function UnaryExpressionedNode<T extends Constructor<UnaryExpressionedNodeExtensionType>>(Base: T): Constructor<UnaryExpressionedNode> & T;\r\n\r\nexport interface UnaryExpressionedNode {\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    getExpression(): UnaryExpression;\r\n}\r\n\r\ndeclare type UnaryExpressionedNodeExtensionType = Node<ts.Node & {\r\n    expression: ts.UnaryExpression;\r\n}>;\r\n\r\ndeclare const ImportExpressionBase: typeof PrimaryExpression;\r\n\r\nexport declare class ImportExpression extends ImportExpressionBase<ts.ImportExpression> {\r\n}\r\n\r\nexport declare class LeftHandSideExpression<T extends ts.LeftHandSideExpression = ts.LeftHandSideExpression> extends UpdateExpression<T> {\r\n}\r\n\r\ndeclare const LiteralExpressionBase: Constructor<LiteralLikeNode> & typeof PrimaryExpression;\r\n\r\nexport declare class LiteralExpression<T extends ts.LiteralExpression = ts.LiteralExpression> extends LiteralExpressionBase<T> {\r\n}\r\n\r\nexport declare class MemberExpression<T extends ts.MemberExpression = ts.MemberExpression> extends LeftHandSideExpression<T> {\r\n}\r\n\r\ndeclare const MetaPropertyBase: Constructor<NamedNode> & typeof PrimaryExpression;\r\n\r\nexport declare class MetaProperty extends MetaPropertyBase<ts.MetaProperty> {\r\n    /**\r\n     * Gets the keyword token.\r\n     */\r\n    getKeywordToken(): SyntaxKind.ImportKeyword | SyntaxKind.NewKeyword;\r\n}\r\n\r\ndeclare const NewExpressionBase: Constructor<TypeArgumentedNode> & Constructor<ArgumentedNode> & Constructor<LeftHandSideExpressionedNode> & typeof PrimaryExpression;\r\n\r\nexport declare class NewExpression extends NewExpressionBase<ts.NewExpression> {\r\n}\r\n\r\ndeclare const NonNullExpressionBase: Constructor<ExpressionedNode> & typeof LeftHandSideExpression;\r\n\r\nexport declare class NonNullExpression extends NonNullExpressionBase<ts.NonNullExpression> {\r\n}\r\n\r\ndeclare const ObjectDestructuringAssignmentBase: typeof AssignmentExpression;\r\n\r\nexport declare class ObjectDestructuringAssignment extends ObjectDestructuringAssignmentBase<ts.ObjectDestructuringAssignment> {\r\n    /**\r\n     * Gets the left object literal expression of the object destructuring assignment.\r\n     */\r\n    getLeft(): ObjectLiteralExpression;\r\n}\r\n\r\ndeclare const ObjectLiteralExpressionBase: typeof PrimaryExpression;\r\n\r\nexport declare class ObjectLiteralExpression extends ObjectLiteralExpressionBase<ts.ObjectLiteralExpression> {\r\n    /**\r\n     * Gets the first property by the provided name or throws.\r\n     * @param name - Name of the property.\r\n     */\r\n    getPropertyOrThrow(name: string): ObjectLiteralElementLike;\r\n    /**\r\n     * Gets the first property that matches the provided find function or throws.\r\n     * @param findFunction - Find function.\r\n     */\r\n    getPropertyOrThrow(findFunction: (property: ObjectLiteralElementLike) => boolean): ObjectLiteralElementLike;\r\n    /**\r\n     * Gets the first property by the provided name or returns undefined.\r\n     * @param name - Name of the property.\r\n     */\r\n    getProperty(name: string): ObjectLiteralElementLike | undefined;\r\n    /**\r\n     * Gets the first property that matches the provided find function or returns undefined.\r\n     * @param findFunction - Find function.\r\n     */\r\n    getProperty(findFunction: (property: ObjectLiteralElementLike) => boolean): ObjectLiteralElementLike | undefined;\r\n    /**\r\n     * Gets the properties.\r\n     */\r\n    getProperties(): ObjectLiteralElementLike[];\r\n    /**\r\n     * Adds a property assignment.\r\n     * @param structure - Structure that represents the property assignment to add.\r\n     */\r\n    addPropertyAssignment(structure: PropertyAssignmentStructure): PropertyAssignment;\r\n    /**\r\n     * Adds property assignments.\r\n     * @param structures - Structure that represents the property assignments to add.\r\n     */\r\n    addPropertyAssignments(structures: ReadonlyArray<PropertyAssignmentStructure>): PropertyAssignment[];\r\n    /**\r\n     * Inserts a property assignment at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the property assignment to insert.\r\n     */\r\n    insertPropertyAssignment(index: number, structure: PropertyAssignmentStructure): PropertyAssignment;\r\n    /**\r\n     * Inserts property assignments at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the property assignments to insert.\r\n     */\r\n    insertPropertyAssignments(index: number, structures: ReadonlyArray<PropertyAssignmentStructure>): PropertyAssignment[];\r\n    /**\r\n     * Adds a shorthand property assignment.\r\n     * @param structure - Structure that represents the shorthand property assignment to add.\r\n     */\r\n    addShorthandPropertyAssignment(structure: ShorthandPropertyAssignmentStructure): ShorthandPropertyAssignment;\r\n    /**\r\n     * Adds shorthand property assignments.\r\n     * @param structures - Structure that represents the shorthand property assignments to add.\r\n     */\r\n    addShorthandPropertyAssignments(structures: ReadonlyArray<ShorthandPropertyAssignmentStructure>): ShorthandPropertyAssignment[];\r\n    /**\r\n     * Inserts a shorthand property assignment at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the shorthand property assignment to insert.\r\n     */\r\n    insertShorthandPropertyAssignment(index: number, structure: ShorthandPropertyAssignmentStructure): ShorthandPropertyAssignment;\r\n    /**\r\n     * Inserts shorthand property assignments at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the shorthand property assignments to insert.\r\n     */\r\n    insertShorthandPropertyAssignments(index: number, structures: ReadonlyArray<ShorthandPropertyAssignmentStructure>): ShorthandPropertyAssignment[];\r\n    /**\r\n     * Adds a spread assignment.\r\n     * @param structure - Structure that represents the spread assignment to add.\r\n     */\r\n    addSpreadAssignment(structure: SpreadAssignmentStructure): SpreadAssignment;\r\n    /**\r\n     * Adds spread assignments.\r\n     * @param structures - Structure that represents the spread assignments to add.\r\n     */\r\n    addSpreadAssignments(structures: ReadonlyArray<SpreadAssignmentStructure>): SpreadAssignment[];\r\n    /**\r\n     * Inserts a spread assignment at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the spread assignment to insert.\r\n     */\r\n    insertSpreadAssignment(index: number, structure: SpreadAssignmentStructure): SpreadAssignment;\r\n    /**\r\n     * Inserts spread assignments at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the spread assignments to insert.\r\n     */\r\n    insertSpreadAssignments(index: number, structures: ReadonlyArray<SpreadAssignmentStructure>): SpreadAssignment[];\r\n    /**\r\n     * Adds a method.\r\n     * @param structure - Structure that represents the method to add.\r\n     */\r\n    addMethod(structure: MethodDeclarationStructure): MethodDeclaration;\r\n    /**\r\n     * Adds methods.\r\n     * @param structures - Structure that represents the methods to add.\r\n     */\r\n    addMethods(structures: ReadonlyArray<MethodDeclarationStructure>): MethodDeclaration[];\r\n    /**\r\n     * Inserts a method at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the method to insert.\r\n     */\r\n    insertMethod(index: number, structure: MethodDeclarationStructure): MethodDeclaration;\r\n    /**\r\n     * Inserts methods at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the methods to insert.\r\n     */\r\n    insertMethods(index: number, structures: ReadonlyArray<MethodDeclarationStructure>): MethodDeclaration[];\r\n    /**\r\n     * Adds a get accessor.\r\n     * @param structure - Structure that represents the property assignment to add.\r\n     */\r\n    addGetAccessor(structure: GetAccessorDeclarationStructure): GetAccessorDeclaration;\r\n    /**\r\n     * Adds get accessors.\r\n     * @param structures - Structure that represents the get accessors to add.\r\n     */\r\n    addGetAccessors(structures: ReadonlyArray<GetAccessorDeclarationStructure>): GetAccessorDeclaration[];\r\n    /**\r\n     * Inserts a get accessor at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the get accessor to insert.\r\n     */\r\n    insertGetAccessor(index: number, structure: GetAccessorDeclarationStructure): GetAccessorDeclaration;\r\n    /**\r\n     * Inserts get accessors at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the get accessors to insert.\r\n     */\r\n    insertGetAccessors(index: number, structures: ReadonlyArray<GetAccessorDeclarationStructure>): GetAccessorDeclaration[];\r\n    /**\r\n     * Adds a set accessor.\r\n     * @param structure - Structure that represents the property assignment to add.\r\n     */\r\n    addSetAccessor(structure: SetAccessorDeclarationStructure): SetAccessorDeclaration;\r\n    /**\r\n     * Adds set accessors.\r\n     * @param structures - Structure that represents the set accessors to add.\r\n     */\r\n    addSetAccessors(structures: ReadonlyArray<SetAccessorDeclarationStructure>): SetAccessorDeclaration[];\r\n    /**\r\n     * Inserts a set accessor at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the set accessor to insert.\r\n     */\r\n    insertSetAccessor(index: number, structure: SetAccessorDeclarationStructure): SetAccessorDeclaration;\r\n    /**\r\n     * Inserts set accessors at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the set accessors to insert.\r\n     */\r\n    insertSetAccessors(index: number, structures: ReadonlyArray<SetAccessorDeclarationStructure>): SetAccessorDeclaration[];\r\n}\r\n\r\ndeclare const PropertyAssignmentBase: Constructor<InitializerGetExpressionableNode> & Constructor<QuestionTokenableNode> & Constructor<PropertyNamedNode> & typeof Node;\r\n\r\nexport declare class PropertyAssignment extends PropertyAssignmentBase<ts.PropertyAssignment> {\r\n    /**\r\n     * Removes the initializer and returns the new shorthand property assignment.\r\n     *\r\n     * Note: The current node will no longer be valid because it's no longer a property assignment.\r\n     */\r\n    removeInitializer(): ShorthandPropertyAssignment;\r\n    /**\r\n     * Sets the initializer.\r\n     * @param textOrWriterFunction - New text ot set for the initializer.\r\n     */\r\n    setInitializer(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Removes this property.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<PropertyAssignmentStructure>): this | ShorthandPropertyAssignment;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): PropertyAssignmentStructure;\r\n}\r\n\r\ndeclare const ShorthandPropertyAssignmentBase: Constructor<InitializerGetExpressionableNode> & Constructor<QuestionTokenableNode> & Constructor<NamedNode> & typeof Node;\r\n\r\nexport declare class ShorthandPropertyAssignment extends ShorthandPropertyAssignmentBase<ts.ShorthandPropertyAssignment> {\r\n    /**\r\n     * Gets if the shorthand property assignment has an object assignment initializer.\r\n     */\r\n    hasObjectAssignmentInitializer(): boolean;\r\n    /**\r\n     * Gets the object assignment initializer or throws if it doesn't exist.\r\n     */\r\n    getObjectAssignmentInitializerOrThrow(): Expression<ts.Expression>;\r\n    /**\r\n     * Gets the object assignment initializer if it exists.\r\n     */\r\n    getObjectAssignmentInitializer(): Expression | undefined;\r\n    /**\r\n     * Gets the equals token or throws if it doesn't exist.\r\n     */\r\n    getEqualsTokenOrThrow(): Node<ts.Token<SyntaxKind.EqualsToken>>;\r\n    /**\r\n     * Gets the equals token if it exists.\r\n     */\r\n    getEqualsToken(): Node<ts.Token<SyntaxKind.EqualsToken>> | undefined;\r\n    /**\r\n     * Remove the object assignment initializer.\r\n     *\r\n     * This is only useful to remove bad code.\r\n     */\r\n    removeObjectAssignmentInitializer(): this;\r\n    /**\r\n     * Sets the initializer.\r\n     *\r\n     * Note: The current node will no longer be valid because it's no longer a shorthand property assignment.\r\n     * @param text - New text to set for the initializer.\r\n     */\r\n    setInitializer(text: string): PropertyAssignment;\r\n    /**\r\n     * Removes this property.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ShorthandPropertyAssignmentStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ShorthandPropertyAssignmentStructure;\r\n}\r\n\r\ndeclare const SpreadAssignmentBase: Constructor<ExpressionedNode> & typeof Node;\r\n\r\nexport declare class SpreadAssignment extends SpreadAssignmentBase<ts.SpreadAssignment> {\r\n    /**\r\n     * Removes this property.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<SpreadAssignmentStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): SpreadAssignmentStructure;\r\n}\r\n\r\ndeclare const OmittedExpressionBase: typeof Expression;\r\n\r\nexport declare class OmittedExpression extends OmittedExpressionBase<ts.OmittedExpression> {\r\n}\r\n\r\ndeclare const ParenthesizedExpressionBase: Constructor<ExpressionedNode> & typeof Expression;\r\n\r\nexport declare class ParenthesizedExpression extends ParenthesizedExpressionBase<ts.ParenthesizedExpression> {\r\n}\r\n\r\ndeclare const PartiallyEmittedExpressionBase: Constructor<ExpressionedNode> & typeof Expression;\r\n\r\nexport declare class PartiallyEmittedExpression extends PartiallyEmittedExpressionBase<ts.PartiallyEmittedExpression> {\r\n}\r\n\r\ndeclare const PostfixUnaryExpressionBase: typeof UnaryExpression;\r\n\r\nexport declare class PostfixUnaryExpression extends PostfixUnaryExpressionBase<ts.PostfixUnaryExpression> {\r\n    /**\r\n     * Gets the operator token of the postfix unary expression.\r\n     */\r\n    getOperatorToken(): ts.PostfixUnaryOperator;\r\n    /**\r\n     * Gets the operand of the postfix unary expression.\r\n     */\r\n    getOperand(): LeftHandSideExpression;\r\n}\r\n\r\ndeclare const PrefixUnaryExpressionBase: typeof UnaryExpression;\r\n\r\nexport declare class PrefixUnaryExpression extends PrefixUnaryExpressionBase<ts.PrefixUnaryExpression> {\r\n    /**\r\n     * Gets the operator token of the prefix unary expression.\r\n     */\r\n    getOperatorToken(): ts.PrefixUnaryOperator;\r\n    /**\r\n     * Gets the operand of the prefix unary expression.\r\n     */\r\n    getOperand(): UnaryExpression;\r\n}\r\n\r\nexport declare class PrimaryExpression<T extends ts.PrimaryExpression = ts.PrimaryExpression> extends MemberExpression<T> {\r\n}\r\n\r\ndeclare const PropertyAccessExpressionBase: Constructor<NamedNode> & Constructor<LeftHandSideExpressionedNode> & typeof MemberExpression;\r\n\r\nexport declare class PropertyAccessExpression<T extends ts.PropertyAccessExpression = ts.PropertyAccessExpression> extends PropertyAccessExpressionBase<T> {\r\n}\r\n\r\ndeclare const SpreadElementBase: Constructor<ExpressionedNode> & typeof Expression;\r\n\r\nexport declare class SpreadElement extends SpreadElementBase<ts.SpreadElement> {\r\n}\r\n\r\ndeclare const SuperElementAccessExpressionBase: Constructor<SuperExpressionedNode> & typeof ElementAccessExpression;\r\n\r\nexport declare class SuperElementAccessExpression extends SuperElementAccessExpressionBase<ts.SuperElementAccessExpression> {\r\n}\r\n\r\ndeclare const SuperExpressionBase: typeof PrimaryExpression;\r\n\r\nexport declare class SuperExpression extends SuperExpressionBase<ts.SuperExpression> {\r\n}\r\n\r\ndeclare const SuperPropertyAccessExpressionBase: Constructor<SuperExpressionedNode> & typeof PropertyAccessExpression;\r\n\r\nexport declare class SuperPropertyAccessExpression extends SuperPropertyAccessExpressionBase<ts.SuperPropertyAccessExpression> {\r\n}\r\n\r\ndeclare const ThisExpressionBase: typeof PrimaryExpression;\r\n\r\nexport declare class ThisExpression extends ThisExpressionBase<ts.ThisExpression> {\r\n}\r\n\r\ndeclare const TypeAssertionBase: Constructor<TypedNode> & Constructor<UnaryExpressionedNode> & typeof UnaryExpression;\r\n\r\nexport declare class TypeAssertion extends TypeAssertionBase<ts.TypeAssertion> {\r\n}\r\n\r\ndeclare const TypeOfExpressionBase: Constructor<UnaryExpressionedNode> & typeof UnaryExpression;\r\n\r\nexport declare class TypeOfExpression extends TypeOfExpressionBase<ts.TypeOfExpression> {\r\n}\r\n\r\nexport declare class UnaryExpression<T extends ts.UnaryExpression = ts.UnaryExpression> extends Expression<T> {\r\n}\r\n\r\nexport declare class UpdateExpression<T extends ts.UpdateExpression = ts.UpdateExpression> extends UnaryExpression<T> {\r\n}\r\n\r\ndeclare const VoidExpressionBase: Constructor<UnaryExpressionedNode> & typeof UnaryExpression;\r\n\r\nexport declare class VoidExpression extends VoidExpressionBase<ts.VoidExpression> {\r\n}\r\n\r\ndeclare const YieldExpressionBase: Constructor<GeneratorableNode> & typeof Expression;\r\n\r\nexport declare class YieldExpression extends YieldExpressionBase<ts.YieldExpression> {\r\n    /**\r\n     * Gets the expression or undefined of the yield expression.\r\n     */\r\n    getExpression(): Expression | undefined;\r\n    /**\r\n     * Gets the expression of the yield expression or throws if it does not exist.\r\n     */\r\n    getExpressionOrThrow(): Expression<ts.Expression>;\r\n}\r\n\r\ndeclare const ArrowFunctionBase: Constructor<TextInsertableNode> & Constructor<BodiedNode> & Constructor<AsyncableNode> & Constructor<FunctionLikeDeclaration> & typeof Expression;\r\n\r\nexport declare class ArrowFunction extends ArrowFunctionBase<ts.ArrowFunction> {\r\n    /**\r\n     * Gets the equals greater than token of the arrow function.\r\n     */\r\n    getEqualsGreaterThan(): Node<ts.Token<SyntaxKind.EqualsGreaterThanToken>>;\r\n}\r\n\r\ndeclare const FunctionDeclarationBase: Constructor<ChildOrderableNode> & Constructor<UnwrappableNode> & Constructor<TextInsertableNode> & Constructor<OverloadableNode> & Constructor<BodyableNode> & Constructor<AsyncableNode> & Constructor<GeneratorableNode> & Constructor<FunctionLikeDeclaration> & Constructor<StatementedNode> & Constructor<AmbientableNode> & Constructor<NamespaceChildableNode> & Constructor<ExportableNode> & Constructor<ModifierableNode> & Constructor<NameableNode> & typeof Node;\r\n\r\ndeclare const FunctionDeclarationOverloadBase: Constructor<ChildOrderableNode> & Constructor<UnwrappableNode> & Constructor<TextInsertableNode> & Constructor<AsyncableNode> & Constructor<GeneratorableNode> & Constructor<ModifierableNode> & Constructor<SignaturedDeclaration> & Constructor<StatementedNode> & Constructor<AmbientableNode> & Constructor<NamespaceChildableNode> & Constructor<JSDocableNode> & Constructor<TypeParameteredNode> & Constructor<ExportableNode> & typeof Node;\r\n\r\nexport declare class FunctionDeclaration extends FunctionDeclarationBase<ts.FunctionDeclaration> {\r\n    /**\r\n     * Adds a function overload.\r\n     * @param structure - Structure of the overload.\r\n     */\r\n    addOverload(structure: FunctionDeclarationOverloadStructure): FunctionDeclaration;\r\n    /**\r\n     * Adds function overloads.\r\n     * @param structures - Structures of the overloads.\r\n     */\r\n    addOverloads(structures: ReadonlyArray<FunctionDeclarationOverloadStructure>): FunctionDeclaration[];\r\n    /**\r\n     * Inserts a function overload.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the overload.\r\n     */\r\n    insertOverload(index: number, structure: FunctionDeclarationOverloadStructure): FunctionDeclaration;\r\n    /**\r\n     * Inserts function overloads.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structures of the overloads.\r\n     */\r\n    insertOverloads(index: number, structures: ReadonlyArray<FunctionDeclarationOverloadStructure>): FunctionDeclaration[];\r\n    /**\r\n     * Removes this function declaration.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<FunctionDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): FunctionDeclarationStructure | FunctionDeclarationOverloadStructure;\r\n}\r\n\r\ndeclare const FunctionExpressionBase: Constructor<JSDocableNode> & Constructor<TextInsertableNode> & Constructor<BodiedNode> & Constructor<AsyncableNode> & Constructor<GeneratorableNode> & Constructor<StatementedNode> & Constructor<TypeParameteredNode> & Constructor<SignaturedDeclaration> & Constructor<ModifierableNode> & Constructor<NameableNode> & typeof PrimaryExpression;\r\n\r\nexport declare class FunctionExpression extends FunctionExpressionBase<ts.FunctionExpression> {\r\n}\r\n\r\nexport declare function FunctionLikeDeclaration<T extends Constructor<FunctionLikeDeclarationExtensionType>>(Base: T): Constructor<FunctionLikeDeclaration> & T;\r\n\r\nexport interface FunctionLikeDeclaration extends JSDocableNode, TypeParameteredNode, SignaturedDeclaration, StatementedNode, ModifierableNode {\r\n}\r\n\r\ndeclare type FunctionLikeDeclarationExtensionType = Node<ts.FunctionLikeDeclaration>;\r\n\r\nexport declare function OverloadableNode<T extends Constructor<OverloadableNodeExtensionType>>(Base: T): Constructor<OverloadableNode> & T;\r\n\r\n/**\r\n * Node that supports overloads.\r\n */\r\nexport interface OverloadableNode {\r\n    /**\r\n     * Gets all the overloads associated with this node.\r\n     */\r\n    getOverloads(): this[];\r\n    /**\r\n     * Gets the implementation or undefined if it doesn't exist.\r\n     */\r\n    getImplementation(): this | undefined;\r\n    /**\r\n     * Gets the implementation or throws if it doesn't exist.\r\n     */\r\n    getImplementationOrThrow(): this;\r\n    /**\r\n     * Gets if this is an overload.\r\n     */\r\n    isOverload(): boolean;\r\n    /**\r\n     * Gets if this is the implementation.\r\n     */\r\n    isImplementation(): boolean;\r\n}\r\n\r\ndeclare type OverloadableNodeExtensionType = Node & BodyableNode;\r\n\r\ndeclare const ParameterDeclarationBase: Constructor<QuestionTokenableNode> & Constructor<DecoratableNode> & Constructor<ScopeableNode> & Constructor<ReadonlyableNode> & Constructor<ModifierableNode> & Constructor<TypedNode> & Constructor<InitializerExpressionableNode> & Constructor<DeclarationNamedNode> & typeof Node;\r\n\r\nexport declare class ParameterDeclaration extends ParameterDeclarationBase<ts.ParameterDeclaration> {\r\n    /**\r\n     * Gets the dot dot dot token (...) if it exists, for a rest parameter.\r\n     */\r\n    getDotDotDotToken(): Node<ts.Token<SyntaxKind.DotDotDotToken>> | undefined;\r\n    /**\r\n     * Gets if it's a rest parameter.\r\n     */\r\n    isRestParameter(): boolean;\r\n    /**\r\n     * Gets if this is a property with a scope or readonly keyword (found in class constructors).\r\n     */\r\n    isParameterProperty(): boolean;\r\n    /**\r\n     * Sets if it's a rest parameter.\r\n     * @param value - Sets if it's a rest parameter or not.\r\n     */\r\n    setIsRestParameter(value: boolean): this;\r\n    /**\r\n     * Gets if it's optional.\r\n     */\r\n    isOptional(): boolean;\r\n    /**\r\n     * Remove this parameter.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ParameterDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ParameterDeclarationStructure;\r\n    /**\r\n     * Sets if this node has a question token.\r\n     * @param value - If it should have a question token or not.\r\n     */\r\n    setHasQuestionToken(value: boolean): this;\r\n    /**\r\n     * Sets the initializer.\r\n     * @param text - Text or writer function to set for the initializer.\r\n     */\r\n    setInitializer(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Sets the type.\r\n     * @param textOrWriterFunction - Text or writer function to set the type with.\r\n     */\r\n    setType(textOrWriterFunction: string | WriterFunction): this;\r\n}\r\n\r\nexport declare class HeritageClause extends Node<ts.HeritageClause> {\r\n    /**\r\n     * Gets all the type nodes for the heritage clause.\r\n     */\r\n    getTypeNodes(): ExpressionWithTypeArguments[];\r\n    /**\r\n     * Gets the heritage clause token.\r\n     */\r\n    getToken(): SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;\r\n    /**\r\n     * Remove the expression from the heritage clause.\r\n     * @param index - Index of the expression to remove.\r\n     */\r\n    removeExpression(index: number): this;\r\n    /**\r\n     * Removes the expression from the heritage clause.\r\n     * @param expressionNode - Expression to remove.\r\n     */\r\n    removeExpression(expressionNode: ExpressionWithTypeArguments): this;\r\n}\r\n\r\ndeclare const CallSignatureDeclarationBase: Constructor<TypeParameteredNode> & Constructor<ChildOrderableNode> & Constructor<JSDocableNode> & Constructor<SignaturedDeclaration> & typeof TypeElement;\r\n\r\nexport declare class CallSignatureDeclaration extends CallSignatureDeclarationBase<ts.CallSignatureDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<CallSignatureDeclarationStructure>): this;\r\n    /**\r\n     * Removes this call signature.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): CallSignatureDeclarationStructure;\r\n}\r\n\r\ndeclare const ConstructSignatureDeclarationBase: Constructor<TypeParameteredNode> & Constructor<ChildOrderableNode> & Constructor<JSDocableNode> & Constructor<SignaturedDeclaration> & typeof TypeElement;\r\n\r\nexport declare class ConstructSignatureDeclaration extends ConstructSignatureDeclarationBase<ts.ConstructSignatureDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ConstructSignatureDeclarationStructure>): this;\r\n    /**\r\n     * Removes this construct signature.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ConstructSignatureDeclarationStructure;\r\n}\r\n\r\ndeclare const IndexSignatureDeclarationBase: Constructor<ReturnTypedNode> & Constructor<ChildOrderableNode> & Constructor<JSDocableNode> & Constructor<ReadonlyableNode> & Constructor<ModifierableNode> & typeof TypeElement;\r\n\r\nexport declare class IndexSignatureDeclaration extends IndexSignatureDeclarationBase<ts.IndexSignatureDeclaration> {\r\n    /**\r\n     * Gets the key name.\r\n     */\r\n    getKeyName(): string;\r\n    /**\r\n     * Sets the key name.\r\n     * @param name - New name.\r\n     */\r\n    setKeyName(name: string): void;\r\n    /**\r\n     * Gets the key name node.\r\n     */\r\n    getKeyNameNode(): BindingName;\r\n    /**\r\n     * Gets the key type.\r\n     */\r\n    getKeyType(): Type;\r\n    /**\r\n     * Sets the key type.\r\n     * @param type - Type.\r\n     */\r\n    setKeyType(type: string): this;\r\n    /**\r\n     * Gets the key type node.\r\n     */\r\n    getKeyTypeNode(): TypeNode;\r\n    /**\r\n     * Removes this index signature.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<IndexSignatureDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): IndexSignatureDeclarationStructure;\r\n}\r\n\r\ndeclare const InterfaceDeclarationBase: Constructor<TypeElementMemberedNode> & Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<ExtendsClauseableNode> & Constructor<HeritageClauseableNode> & Constructor<TypeParameteredNode> & Constructor<JSDocableNode> & Constructor<AmbientableNode> & Constructor<NamespaceChildableNode> & Constructor<ExportableNode> & Constructor<ModifierableNode> & Constructor<NamedNode> & typeof Statement;\r\n\r\nexport declare class InterfaceDeclaration extends InterfaceDeclarationBase<ts.InterfaceDeclaration> {\r\n    /**\r\n     * Gets the base types.\r\n     */\r\n    getBaseTypes(): Type[];\r\n    /**\r\n     * Gets the base declarations.\r\n     */\r\n    getBaseDeclarations(): (TypeAliasDeclaration | InterfaceDeclaration | ClassDeclaration)[];\r\n    /**\r\n     * Gets all the implementations of the interface.\r\n     *\r\n     * This is similar to \"go to implementation.\"\r\n     */\r\n    getImplementations(): ImplementationLocation[];\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<InterfaceDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): InterfaceDeclarationStructure;\r\n}\r\n\r\ndeclare const MethodSignatureBase: Constructor<ChildOrderableNode> & Constructor<JSDocableNode> & Constructor<QuestionTokenableNode> & Constructor<TypeParameteredNode> & Constructor<SignaturedDeclaration> & Constructor<PropertyNamedNode> & typeof TypeElement;\r\n\r\nexport declare class MethodSignature extends MethodSignatureBase<ts.MethodSignature> {\r\n    /**\r\n     * Removes this method signature.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<MethodSignatureStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): MethodSignatureStructure;\r\n}\r\n\r\ndeclare const PropertySignatureBase: Constructor<ChildOrderableNode> & Constructor<JSDocableNode> & Constructor<ReadonlyableNode> & Constructor<QuestionTokenableNode> & Constructor<InitializerExpressionableNode> & Constructor<TypedNode> & Constructor<PropertyNamedNode> & Constructor<ModifierableNode> & typeof TypeElement;\r\n\r\nexport declare class PropertySignature extends PropertySignatureBase<ts.PropertySignature> {\r\n    /**\r\n     * Removes this property signature.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<PropertySignatureStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): PropertySignatureStructure;\r\n}\r\n\r\nexport declare class TypeElement<TNode extends ts.TypeElement = ts.TypeElement> extends Node<TNode> {\r\n}\r\n\r\nexport declare function JsxAttributedNode<T extends Constructor<JsxAttributedNodeExtensionType>>(Base: T): Constructor<JsxAttributedNode> & T;\r\n\r\nexport interface JsxAttributedNode {\r\n    /**\r\n     * Gets the JSX element's attributes.\r\n     */\r\n    getAttributes(): JsxAttributeLike[];\r\n    /**\r\n     * Gets an attribute by name or returns undefined when it can't be found.\r\n     * @param name - Name to search for.\r\n     */\r\n    getAttribute(name: string): JsxAttributeLike | undefined;\r\n    /**\r\n     * Gets an attribute by a find function or returns undefined when it can't be found.\r\n     * @param findFunction - Find function.\r\n     */\r\n    getAttribute(findFunction: (attribute: JsxAttributeLike) => boolean): JsxAttributeLike | undefined;\r\n    /**\r\n     * Gets an attribute by name or throws when it can't be found.\r\n     * @param name - Name to search for.\r\n     */\r\n    getAttributeOrThrow(name: string): JsxAttributeLike;\r\n    /**\r\n     * Gets an attribute by a find function or throws when it can't be found.\r\n     * @param findFunction - Find function.\r\n     */\r\n    getAttributeOrThrow(findFunction: (attribute: JsxAttributeLike) => boolean): JsxAttributeLike;\r\n    /**\r\n     * Adds an attribute into the element.\r\n     */\r\n    addAttribute(attribute: JsxAttributeStructure | JsxSpreadAttributeStructure): JsxAttributeLike;\r\n    /**\r\n     * Adds attributes into the element.\r\n     */\r\n    addAttributes(attributes: ReadonlyArray<JsxAttributeStructure | JsxSpreadAttributeStructure>): JsxAttributeLike[];\r\n    /**\r\n     * Inserts an attribute into the element.\r\n     */\r\n    insertAttribute(index: number, attribute: JsxAttributeStructure | JsxSpreadAttributeStructure): JsxAttributeLike;\r\n    /**\r\n     * Inserts attributes into the element.\r\n     */\r\n    insertAttributes(index: number, attributes: ReadonlyArray<JsxAttributeStructure | JsxSpreadAttributeStructure>): JsxAttributeLike[];\r\n}\r\n\r\ndeclare type JsxAttributedNodeExtensionType = Node<ts.Node & {\r\n    attributes: ts.JsxAttributes;\r\n}> & JsxTagNamedNode;\r\n\r\nexport declare function JsxTagNamedNode<T extends Constructor<JsxTagNamedNodeExtensionType>>(Base: T): Constructor<JsxTagNamedNode> & T;\r\n\r\nexport interface JsxTagNamedNode {\r\n    /**\r\n     * Gets the tag name of the JSX closing element.\r\n     */\r\n    getTagNameNode(): JsxTagNameExpression;\r\n}\r\n\r\ndeclare type JsxTagNamedNodeExtensionType = Node<ts.Node & {\r\n    tagName: ts.JsxTagNameExpression;\r\n}>;\r\n\r\ndeclare const JsxAttributeBase: Constructor<NamedNode> & typeof Node;\r\n\r\nexport declare class JsxAttribute extends JsxAttributeBase<ts.JsxAttribute> {\r\n    /**\r\n     * Gets the JSX attribute's initializer or throws if it doesn't exist.\r\n     */\r\n    getInitializerOrThrow(): StringLiteral | JsxExpression;\r\n    /**\r\n     * Gets the JSX attribute's initializer or returns undefined if it doesn't exist.\r\n     */\r\n    getInitializer(): StringLiteral | JsxExpression | undefined;\r\n    /**\r\n     * Sets the initializer.\r\n     * @param textOrWriterFunction - Text or writer function to set the initializer with.\r\n     * @remarks You need to provide the quotes or braces.\r\n     */\r\n    setInitializer(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Removes the initializer.\r\n     */\r\n    removeInitializer(): this;\r\n    /**\r\n     * Removes the JSX attribute.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<JsxAttributeStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): JsxAttributeStructure;\r\n}\r\n\r\ndeclare const JsxClosingElementBase: Constructor<JsxTagNamedNode> & typeof Node;\r\n\r\nexport declare class JsxClosingElement extends JsxClosingElementBase<ts.JsxClosingElement> {\r\n}\r\n\r\nexport declare class JsxClosingFragment extends Expression<ts.JsxClosingFragment> {\r\n}\r\n\r\ndeclare const JsxElementBase: typeof PrimaryExpression;\r\n\r\nexport declare class JsxElement extends JsxElementBase<ts.JsxElement> {\r\n    /**\r\n     * Gets the children of the JSX element.\r\n     */\r\n    getJsxChildren(): JsxChild[];\r\n    /**\r\n     * Gets the opening element.\r\n     */\r\n    getOpeningElement(): JsxOpeningElement;\r\n    /**\r\n     * Gets the closing element.\r\n     */\r\n    getClosingElement(): JsxClosingElement;\r\n    /**\r\n     * Sets the body text.\r\n     * @param textOrWriterFunction - Text or writer function to set as the body.\r\n     */\r\n    setBodyText(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Sets the body text without surrounding new lines.\r\n     * @param textOrWriterFunction - Text to set as the body.\r\n     */\r\n    setBodyTextInline(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<JsxElementStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): JsxElementStructure;\r\n}\r\n\r\nexport declare class JsxExpression extends Expression<ts.JsxExpression> {\r\n    /**\r\n     * Gets the dot dot dot token (...) or throws if it doesn't exist.\r\n     */\r\n    getDotDotDotTokenOrThrow(): Node<ts.Token<SyntaxKind.DotDotDotToken>>;\r\n    /**\r\n     * Gets the dot dot dot token (...) or returns undefined if it doesn't exist.\r\n     */\r\n    getDotDotDotToken(): Node<ts.Token<SyntaxKind.DotDotDotToken>> | undefined;\r\n    /**\r\n     * Gets the expression or throws if it doesn't exist.\r\n     */\r\n    getExpressionOrThrow(): Expression<ts.Expression>;\r\n    /**\r\n     * Gets the expression or returns undefined if it doesn't exist\r\n     */\r\n    getExpression(): Expression | undefined;\r\n}\r\n\r\nexport declare class JsxFragment extends PrimaryExpression<ts.JsxFragment> {\r\n    /**\r\n     * Gets the children of the JSX fragment.\r\n     */\r\n    getJsxChildren(): JsxChild[];\r\n    /**\r\n     * Gets the opening fragment.\r\n     */\r\n    getOpeningFragment(): JsxOpeningFragment;\r\n    /**\r\n     * Gets the closing fragment.\r\n     */\r\n    getClosingFragment(): JsxClosingFragment;\r\n}\r\n\r\ndeclare const JsxOpeningElementBase: Constructor<JsxAttributedNode> & Constructor<JsxTagNamedNode> & typeof Expression;\r\n\r\nexport declare class JsxOpeningElement extends JsxOpeningElementBase<ts.JsxOpeningElement> {\r\n}\r\n\r\nexport declare class JsxOpeningFragment extends Expression<ts.JsxOpeningFragment> {\r\n}\r\n\r\ndeclare const JsxSelfClosingElementBase: Constructor<JsxAttributedNode> & Constructor<JsxTagNamedNode> & typeof PrimaryExpression;\r\n\r\nexport declare class JsxSelfClosingElement extends JsxSelfClosingElementBase<ts.JsxSelfClosingElement> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<JsxElementStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): JsxElementStructure;\r\n}\r\n\r\ndeclare const JsxSpreadAttributeBase: typeof Node;\r\n\r\nexport declare class JsxSpreadAttribute extends JsxSpreadAttributeBase<ts.JsxSpreadAttribute> {\r\n    /**\r\n     * Gets the JSX spread attribute's expression.\r\n     */\r\n    getExpression(): Expression<ts.Expression>;\r\n    /**\r\n     * Sets the expression.\r\n     * @param textOrWriterFunction - Text to set the expression with.\r\n     */\r\n    setExpression(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Removes the JSX spread attribute.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<JsxSpreadAttributeStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): JsxSpreadAttributeStructure;\r\n}\r\n\r\nexport declare class JsxText extends Node<ts.JsxText> {\r\n    /**\r\n     * Gets if the JSX text contains only white spaces.\r\n     */\r\n    containsOnlyWhiteSpaces(): boolean;\r\n}\r\n\r\nexport interface ImplementedKindToNodeMappings {\r\n    [SyntaxKind.SourceFile]: SourceFile;\r\n    [SyntaxKind.ArrayBindingPattern]: ArrayBindingPattern;\r\n    [SyntaxKind.ArrayLiteralExpression]: ArrayLiteralExpression;\r\n    [SyntaxKind.ArrayType]: ArrayTypeNode;\r\n    [SyntaxKind.ArrowFunction]: ArrowFunction;\r\n    [SyntaxKind.AsExpression]: AsExpression;\r\n    [SyntaxKind.AwaitExpression]: AwaitExpression;\r\n    [SyntaxKind.BindingElement]: BindingElement;\r\n    [SyntaxKind.BinaryExpression]: BinaryExpression;\r\n    [SyntaxKind.Block]: Block;\r\n    [SyntaxKind.BreakStatement]: BreakStatement;\r\n    [SyntaxKind.CallExpression]: CallExpression;\r\n    [SyntaxKind.CallSignature]: CallSignatureDeclaration;\r\n    [SyntaxKind.CaseBlock]: CaseBlock;\r\n    [SyntaxKind.CaseClause]: CaseClause;\r\n    [SyntaxKind.CatchClause]: CatchClause;\r\n    [SyntaxKind.ClassDeclaration]: ClassDeclaration;\r\n    [SyntaxKind.ClassExpression]: ClassExpression;\r\n    [SyntaxKind.Constructor]: ConstructorDeclaration;\r\n    [SyntaxKind.ConstructorType]: ConstructorTypeNode;\r\n    [SyntaxKind.ConstructSignature]: ConstructSignatureDeclaration;\r\n    [SyntaxKind.ContinueStatement]: ContinueStatement;\r\n    [SyntaxKind.CommaListExpression]: CommaListExpression;\r\n    [SyntaxKind.ComputedPropertyName]: ComputedPropertyName;\r\n    [SyntaxKind.ConditionalExpression]: ConditionalExpression;\r\n    [SyntaxKind.DebuggerStatement]: DebuggerStatement;\r\n    [SyntaxKind.Decorator]: Decorator;\r\n    [SyntaxKind.DefaultClause]: DefaultClause;\r\n    [SyntaxKind.DeleteExpression]: DeleteExpression;\r\n    [SyntaxKind.DoStatement]: DoStatement;\r\n    [SyntaxKind.ElementAccessExpression]: ElementAccessExpression;\r\n    [SyntaxKind.EmptyStatement]: EmptyStatement;\r\n    [SyntaxKind.EnumDeclaration]: EnumDeclaration;\r\n    [SyntaxKind.EnumMember]: EnumMember;\r\n    [SyntaxKind.ExportAssignment]: ExportAssignment;\r\n    [SyntaxKind.ExportDeclaration]: ExportDeclaration;\r\n    [SyntaxKind.ExportSpecifier]: ExportSpecifier;\r\n    [SyntaxKind.ExpressionWithTypeArguments]: ExpressionWithTypeArguments;\r\n    [SyntaxKind.ExpressionStatement]: ExpressionStatement;\r\n    [SyntaxKind.ExternalModuleReference]: ExternalModuleReference;\r\n    [SyntaxKind.QualifiedName]: QualifiedName;\r\n    [SyntaxKind.FirstNode]: QualifiedName;\r\n    [SyntaxKind.ForInStatement]: ForInStatement;\r\n    [SyntaxKind.ForOfStatement]: ForOfStatement;\r\n    [SyntaxKind.ForStatement]: ForStatement;\r\n    [SyntaxKind.FunctionDeclaration]: FunctionDeclaration;\r\n    [SyntaxKind.FunctionExpression]: FunctionExpression;\r\n    [SyntaxKind.FunctionType]: FunctionTypeNode;\r\n    [SyntaxKind.GetAccessor]: GetAccessorDeclaration;\r\n    [SyntaxKind.HeritageClause]: HeritageClause;\r\n    [SyntaxKind.Identifier]: Identifier;\r\n    [SyntaxKind.IfStatement]: IfStatement;\r\n    [SyntaxKind.ImportClause]: ImportClause;\r\n    [SyntaxKind.ImportDeclaration]: ImportDeclaration;\r\n    [SyntaxKind.ImportEqualsDeclaration]: ImportEqualsDeclaration;\r\n    [SyntaxKind.ImportSpecifier]: ImportSpecifier;\r\n    [SyntaxKind.ImportType]: ImportTypeNode;\r\n    [SyntaxKind.LastTypeNode]: ImportTypeNode;\r\n    [SyntaxKind.IndexedAccessType]: IndexedAccessTypeNode;\r\n    [SyntaxKind.IndexSignature]: IndexSignatureDeclaration;\r\n    [SyntaxKind.InterfaceDeclaration]: InterfaceDeclaration;\r\n    [SyntaxKind.IntersectionType]: IntersectionTypeNode;\r\n    [SyntaxKind.JSDocAugmentsTag]: JSDocAugmentsTag;\r\n    [SyntaxKind.JSDocClassTag]: JSDocClassTag;\r\n    [SyntaxKind.JSDocFunctionType]: JSDocFunctionType;\r\n    [SyntaxKind.JSDocReturnTag]: JSDocReturnTag;\r\n    [SyntaxKind.JSDocSignature]: JSDocSignature;\r\n    [SyntaxKind.JSDocTag]: JSDocUnknownTag;\r\n    [SyntaxKind.FirstJSDocTagNode]: JSDocUnknownTag;\r\n    [SyntaxKind.JSDocTypeExpression]: JSDocTypeExpression;\r\n    [SyntaxKind.FirstJSDocNode]: JSDocTypeExpression;\r\n    [SyntaxKind.JSDocTypeTag]: JSDocTypeTag;\r\n    [SyntaxKind.JSDocTypedefTag]: JSDocTypedefTag;\r\n    [SyntaxKind.JSDocParameterTag]: JSDocParameterTag;\r\n    [SyntaxKind.JSDocPropertyTag]: JSDocPropertyTag;\r\n    [SyntaxKind.LastJSDocNode]: JSDocPropertyTag;\r\n    [SyntaxKind.LastJSDocTagNode]: JSDocPropertyTag;\r\n    [SyntaxKind.JsxAttribute]: JsxAttribute;\r\n    [SyntaxKind.JsxClosingElement]: JsxClosingElement;\r\n    [SyntaxKind.JsxClosingFragment]: JsxClosingFragment;\r\n    [SyntaxKind.JsxElement]: JsxElement;\r\n    [SyntaxKind.JsxExpression]: JsxExpression;\r\n    [SyntaxKind.JsxFragment]: JsxFragment;\r\n    [SyntaxKind.JsxOpeningElement]: JsxOpeningElement;\r\n    [SyntaxKind.JsxOpeningFragment]: JsxOpeningFragment;\r\n    [SyntaxKind.JsxSelfClosingElement]: JsxSelfClosingElement;\r\n    [SyntaxKind.JsxSpreadAttribute]: JsxSpreadAttribute;\r\n    [SyntaxKind.JsxText]: JsxText;\r\n    [SyntaxKind.LabeledStatement]: LabeledStatement;\r\n    [SyntaxKind.LiteralType]: LiteralTypeNode;\r\n    [SyntaxKind.MetaProperty]: MetaProperty;\r\n    [SyntaxKind.MethodDeclaration]: MethodDeclaration;\r\n    [SyntaxKind.MethodSignature]: MethodSignature;\r\n    [SyntaxKind.ModuleBlock]: ModuleBlock;\r\n    [SyntaxKind.ModuleDeclaration]: NamespaceDeclaration;\r\n    [SyntaxKind.NamedExports]: NamedExports;\r\n    [SyntaxKind.NamedImports]: NamedImports;\r\n    [SyntaxKind.NamespaceImport]: NamespaceImport;\r\n    [SyntaxKind.NewExpression]: NewExpression;\r\n    [SyntaxKind.NonNullExpression]: NonNullExpression;\r\n    [SyntaxKind.NotEmittedStatement]: NotEmittedStatement;\r\n    [SyntaxKind.NoSubstitutionTemplateLiteral]: NoSubstitutionTemplateLiteral;\r\n    [SyntaxKind.LastLiteralToken]: NoSubstitutionTemplateLiteral;\r\n    [SyntaxKind.FirstTemplateToken]: NoSubstitutionTemplateLiteral;\r\n    [SyntaxKind.NumericLiteral]: NumericLiteral;\r\n    [SyntaxKind.FirstLiteralToken]: NumericLiteral;\r\n    [SyntaxKind.ObjectBindingPattern]: ObjectBindingPattern;\r\n    [SyntaxKind.ObjectLiteralExpression]: ObjectLiteralExpression;\r\n    [SyntaxKind.OmittedExpression]: OmittedExpression;\r\n    [SyntaxKind.Parameter]: ParameterDeclaration;\r\n    [SyntaxKind.ParenthesizedExpression]: ParenthesizedExpression;\r\n    [SyntaxKind.ParenthesizedType]: ParenthesizedTypeNode;\r\n    [SyntaxKind.PartiallyEmittedExpression]: PartiallyEmittedExpression;\r\n    [SyntaxKind.PostfixUnaryExpression]: PostfixUnaryExpression;\r\n    [SyntaxKind.PrefixUnaryExpression]: PrefixUnaryExpression;\r\n    [SyntaxKind.PropertyAccessExpression]: PropertyAccessExpression;\r\n    [SyntaxKind.PropertyAssignment]: PropertyAssignment;\r\n    [SyntaxKind.PropertyDeclaration]: PropertyDeclaration;\r\n    [SyntaxKind.PropertySignature]: PropertySignature;\r\n    [SyntaxKind.RegularExpressionLiteral]: RegularExpressionLiteral;\r\n    [SyntaxKind.ReturnStatement]: ReturnStatement;\r\n    [SyntaxKind.SetAccessor]: SetAccessorDeclaration;\r\n    [SyntaxKind.ShorthandPropertyAssignment]: ShorthandPropertyAssignment;\r\n    [SyntaxKind.SpreadAssignment]: SpreadAssignment;\r\n    [SyntaxKind.SpreadElement]: SpreadElement;\r\n    [SyntaxKind.StringLiteral]: StringLiteral;\r\n    [SyntaxKind.SwitchStatement]: SwitchStatement;\r\n    [SyntaxKind.SyntaxList]: SyntaxList;\r\n    [SyntaxKind.TaggedTemplateExpression]: TaggedTemplateExpression;\r\n    [SyntaxKind.TemplateExpression]: TemplateExpression;\r\n    [SyntaxKind.TemplateHead]: TemplateHead;\r\n    [SyntaxKind.TemplateMiddle]: TemplateMiddle;\r\n    [SyntaxKind.TemplateSpan]: TemplateSpan;\r\n    [SyntaxKind.TemplateTail]: TemplateTail;\r\n    [SyntaxKind.LastTemplateToken]: TemplateTail;\r\n    [SyntaxKind.ThrowStatement]: ThrowStatement;\r\n    [SyntaxKind.TryStatement]: TryStatement;\r\n    [SyntaxKind.TupleType]: TupleTypeNode;\r\n    [SyntaxKind.TypeAliasDeclaration]: TypeAliasDeclaration;\r\n    [SyntaxKind.TypeAssertionExpression]: TypeAssertion;\r\n    [SyntaxKind.TypeLiteral]: TypeLiteralNode;\r\n    [SyntaxKind.TypeParameter]: TypeParameterDeclaration;\r\n    [SyntaxKind.TypeReference]: TypeReferenceNode;\r\n    [SyntaxKind.UnionType]: UnionTypeNode;\r\n    [SyntaxKind.VariableDeclaration]: VariableDeclaration;\r\n    [SyntaxKind.VariableDeclarationList]: VariableDeclarationList;\r\n    [SyntaxKind.VariableStatement]: VariableStatement;\r\n    [SyntaxKind.JSDocComment]: JSDoc;\r\n    [SyntaxKind.TypePredicate]: TypeNode;\r\n    [SyntaxKind.FirstTypeNode]: TypeNode;\r\n    [SyntaxKind.SemicolonToken]: Node;\r\n    [SyntaxKind.TypeOfExpression]: TypeOfExpression;\r\n    [SyntaxKind.WhileStatement]: WhileStatement;\r\n    [SyntaxKind.WithStatement]: WithStatement;\r\n    [SyntaxKind.YieldExpression]: YieldExpression;\r\n    [SyntaxKind.AnyKeyword]: Expression;\r\n    [SyntaxKind.BooleanKeyword]: Expression;\r\n    [SyntaxKind.NeverKeyword]: Expression;\r\n    [SyntaxKind.NumberKeyword]: Expression;\r\n    [SyntaxKind.ObjectKeyword]: Expression;\r\n    [SyntaxKind.StringKeyword]: Expression;\r\n    [SyntaxKind.SymbolKeyword]: Expression;\r\n    [SyntaxKind.UndefinedKeyword]: Expression;\r\n    [SyntaxKind.FalseKeyword]: BooleanLiteral;\r\n    [SyntaxKind.TrueKeyword]: BooleanLiteral;\r\n    [SyntaxKind.ImportKeyword]: ImportExpression;\r\n    [SyntaxKind.NullKeyword]: NullLiteral;\r\n    [SyntaxKind.SuperKeyword]: SuperExpression;\r\n    [SyntaxKind.ThisKeyword]: ThisExpression;\r\n    [SyntaxKind.VoidExpression]: VoidExpression;\r\n}\r\n\r\nexport interface KindToNodeMappings extends ImplementedKindToNodeMappings {\r\n    [kind: number]: Node;\r\n}\r\n\r\nexport interface KindToExpressionMappings {\r\n    [kind: number]: Node;\r\n    [SyntaxKind.ArrayLiteralExpression]: ArrayLiteralExpression;\r\n    [SyntaxKind.ArrowFunction]: ArrowFunction;\r\n    [SyntaxKind.AsExpression]: AsExpression;\r\n    [SyntaxKind.AwaitExpression]: AwaitExpression;\r\n    [SyntaxKind.BinaryExpression]: BinaryExpression;\r\n    [SyntaxKind.CallExpression]: CallExpression;\r\n    [SyntaxKind.ClassExpression]: ClassExpression;\r\n    [SyntaxKind.CommaListExpression]: CommaListExpression;\r\n    [SyntaxKind.ConditionalExpression]: ConditionalExpression;\r\n    [SyntaxKind.DeleteExpression]: DeleteExpression;\r\n    [SyntaxKind.ElementAccessExpression]: ElementAccessExpression;\r\n    [SyntaxKind.FunctionExpression]: FunctionExpression;\r\n    [SyntaxKind.Identifier]: Identifier;\r\n    [SyntaxKind.JsxClosingFragment]: JsxClosingFragment;\r\n    [SyntaxKind.JsxElement]: JsxElement;\r\n    [SyntaxKind.JsxExpression]: JsxExpression;\r\n    [SyntaxKind.JsxFragment]: JsxFragment;\r\n    [SyntaxKind.JsxOpeningElement]: JsxOpeningElement;\r\n    [SyntaxKind.JsxOpeningFragment]: JsxOpeningFragment;\r\n    [SyntaxKind.JsxSelfClosingElement]: JsxSelfClosingElement;\r\n    [SyntaxKind.MetaProperty]: MetaProperty;\r\n    [SyntaxKind.NewExpression]: NewExpression;\r\n    [SyntaxKind.NonNullExpression]: NonNullExpression;\r\n    [SyntaxKind.NoSubstitutionTemplateLiteral]: NoSubstitutionTemplateLiteral;\r\n    [SyntaxKind.LastLiteralToken]: NoSubstitutionTemplateLiteral;\r\n    [SyntaxKind.FirstTemplateToken]: NoSubstitutionTemplateLiteral;\r\n    [SyntaxKind.NumericLiteral]: NumericLiteral;\r\n    [SyntaxKind.FirstLiteralToken]: NumericLiteral;\r\n    [SyntaxKind.ObjectLiteralExpression]: ObjectLiteralExpression;\r\n    [SyntaxKind.OmittedExpression]: OmittedExpression;\r\n    [SyntaxKind.ParenthesizedExpression]: ParenthesizedExpression;\r\n    [SyntaxKind.PartiallyEmittedExpression]: PartiallyEmittedExpression;\r\n    [SyntaxKind.PostfixUnaryExpression]: PostfixUnaryExpression;\r\n    [SyntaxKind.PrefixUnaryExpression]: PrefixUnaryExpression;\r\n    [SyntaxKind.PropertyAccessExpression]: PropertyAccessExpression;\r\n    [SyntaxKind.RegularExpressionLiteral]: RegularExpressionLiteral;\r\n    [SyntaxKind.SpreadElement]: SpreadElement;\r\n    [SyntaxKind.StringLiteral]: StringLiteral;\r\n    [SyntaxKind.TaggedTemplateExpression]: TaggedTemplateExpression;\r\n    [SyntaxKind.TemplateExpression]: TemplateExpression;\r\n    [SyntaxKind.TypeAssertionExpression]: TypeAssertion;\r\n    [SyntaxKind.TypeOfExpression]: TypeOfExpression;\r\n    [SyntaxKind.YieldExpression]: YieldExpression;\r\n    [SyntaxKind.AnyKeyword]: Expression;\r\n    [SyntaxKind.BooleanKeyword]: Expression;\r\n    [SyntaxKind.NeverKeyword]: Expression;\r\n    [SyntaxKind.NumberKeyword]: Expression;\r\n    [SyntaxKind.ObjectKeyword]: Expression;\r\n    [SyntaxKind.StringKeyword]: Expression;\r\n    [SyntaxKind.SymbolKeyword]: Expression;\r\n    [SyntaxKind.UndefinedKeyword]: Expression;\r\n    [SyntaxKind.FalseKeyword]: BooleanLiteral;\r\n    [SyntaxKind.TrueKeyword]: BooleanLiteral;\r\n    [SyntaxKind.ImportKeyword]: ImportExpression;\r\n    [SyntaxKind.NullKeyword]: NullLiteral;\r\n    [SyntaxKind.SuperKeyword]: SuperExpression;\r\n    [SyntaxKind.ThisKeyword]: ThisExpression;\r\n    [SyntaxKind.VoidExpression]: VoidExpression;\r\n}\r\n\r\ndeclare const BooleanLiteralBase: typeof PrimaryExpression;\r\n\r\nexport declare class BooleanLiteral extends BooleanLiteralBase<ts.BooleanLiteral> {\r\n    /**\r\n     * Gets the literal value.\r\n     */\r\n    getLiteralValue(): boolean;\r\n    /**\r\n     * Sets the literal value.\r\n     *\r\n     * Note: For the time being, this forgets the current node and returns the new node.\r\n     * @param value - Value to set.\r\n     */\r\n    setLiteralValue(value: boolean): BooleanLiteral;\r\n}\r\n\r\ndeclare const NullLiteralBase: typeof PrimaryExpression;\r\n\r\nexport declare class NullLiteral extends NullLiteralBase<ts.NullLiteral> {\r\n}\r\n\r\ndeclare const NumericLiteralBase: typeof LiteralExpression;\r\n\r\nexport declare class NumericLiteral extends NumericLiteralBase<ts.NumericLiteral> {\r\n    /**\r\n     * Gets the literal value.\r\n     */\r\n    getLiteralValue(): number;\r\n    /**\r\n     * Sets the literal value.\r\n     * @param value - Value to set.\r\n     */\r\n    setLiteralValue(value: number): this;\r\n}\r\n/** Quote type for a string literal. */\r\nexport declare enum QuoteKind {\r\n    /** Single quote */\r\n    Single = \"'\",\r\n    /** Double quote */\r\n    Double = \"\\\"\"\r\n}\r\n\r\ndeclare const RegularExpressionLiteralBase: typeof LiteralExpression;\r\n\r\nexport declare class RegularExpressionLiteral extends RegularExpressionLiteralBase<ts.RegularExpressionLiteral> {\r\n    /**\r\n     * Gets the literal value.\r\n     */\r\n    getLiteralValue(): RegExp;\r\n    /**\r\n     * Sets the literal value according to a pattern and some flags.\r\n     * @param pattern - Pattern.\r\n     * @param flags - Flags.\r\n     */\r\n    setLiteralValue(pattern: string, flags?: string): this;\r\n    /**\r\n     * Sets the literal value according to a regular expression object.\r\n     * @param regExp - Regular expression.\r\n     */\r\n    setLiteralValue(regExp: RegExp): this;\r\n}\r\n\r\ndeclare const StringLiteralBase: typeof LiteralExpression;\r\n\r\nexport declare class StringLiteral extends StringLiteralBase<ts.StringLiteral> {\r\n    /**\r\n     * Gets the literal value.\r\n     *\r\n     * This is equivalent to .getLiteralText() for string literals and only exists for consistency with other literals.\r\n     */\r\n    getLiteralValue(): string;\r\n    /**\r\n     * Sets the literal value.\r\n     * @param value - Value to set.\r\n     */\r\n    setLiteralValue(value: string): this;\r\n    /**\r\n     * Gets the quote kind.\r\n     */\r\n    getQuoteKind(): QuoteKind;\r\n}\r\n\r\ndeclare const NoSubstitutionTemplateLiteralBase: typeof LiteralExpression;\r\n\r\nexport declare class NoSubstitutionTemplateLiteral extends NoSubstitutionTemplateLiteralBase<ts.NoSubstitutionTemplateLiteral> {\r\n    /**\r\n     * Gets the literal value.\r\n     */\r\n    getLiteralValue(): string;\r\n    /**\r\n     * Sets the literal value.\r\n     *\r\n     * Note: This could possibly replace the node if you add a tagged template.\r\n     * @param value - Value to set.\r\n     * @returns The new node if the kind changed; the current node otherwise.\r\n     */\r\n    setLiteralValue(value: string): TemplateLiteral;\r\n}\r\n\r\nexport declare class TaggedTemplateExpression extends MemberExpression<ts.TaggedTemplateExpression> {\r\n    /**\r\n     * Gets the tag.\r\n     */\r\n    getTag(): LeftHandSideExpression;\r\n    /**\r\n     * Gets the template literal.\r\n     */\r\n    getTemplate(): TemplateLiteral;\r\n    /**\r\n     * Removes the tag from the tagged template.\r\n     * @returns The new template expression.\r\n     */\r\n    removeTag(): TemplateLiteral;\r\n}\r\n\r\ndeclare const TemplateExpressionBase: typeof PrimaryExpression;\r\n\r\nexport declare class TemplateExpression extends TemplateExpressionBase<ts.TemplateExpression> {\r\n    /**\r\n     * Gets the template head.\r\n     */\r\n    getHead(): TemplateHead;\r\n    /**\r\n     * Gets the template spans.\r\n     */\r\n    getTemplateSpans(): TemplateSpan[];\r\n    /**\r\n     * Sets the literal value.\r\n     *\r\n     * Note: This could possibly replace the node if you remove all the tagged templates.\r\n     * @param value - Value to set.\r\n     * @returns The new node if the kind changed; the current node otherwise.\r\n     */\r\n    setLiteralValue(value: string): TemplateLiteral;\r\n}\r\n\r\ndeclare const TemplateHeadBase: Constructor<LiteralLikeNode> & typeof Node;\r\n\r\nexport declare class TemplateHead extends TemplateHeadBase<ts.TemplateHead> {\r\n}\r\n\r\ndeclare const TemplateMiddleBase: Constructor<LiteralLikeNode> & typeof Node;\r\n\r\nexport declare class TemplateMiddle extends TemplateMiddleBase<ts.TemplateMiddle> {\r\n}\r\n\r\ndeclare const TemplateSpanBase: Constructor<ExpressionedNode> & typeof Node;\r\n\r\nexport declare class TemplateSpan extends TemplateSpanBase<ts.TemplateSpan> {\r\n    /**\r\n     * Gets the template literal.\r\n     */\r\n    getLiteral(): TemplateMiddle | TemplateTail;\r\n}\r\n\r\ndeclare const TemplateTailBase: Constructor<LiteralLikeNode> & typeof Node;\r\n\r\nexport declare class TemplateTail extends TemplateTailBase<ts.TemplateTail> {\r\n}\r\n\r\ndeclare const ExportAssignmentBase: typeof Statement;\r\n\r\nexport declare class ExportAssignment extends ExportAssignmentBase<ts.ExportAssignment> {\r\n    /**\r\n     * Gets if this is an export equals assignment.\r\n     *\r\n     * If this is false, then it's `export default`.\r\n     */\r\n    isExportEquals(): boolean;\r\n    /**\r\n     * Sets if this is an export equals assignment or export default.\r\n     * @param value - Whether it should be an export equals assignment.\r\n     */\r\n    setIsExportEquals(value: boolean): this;\r\n    /**\r\n     * Gets the export assignment expression.\r\n     */\r\n    getExpression(): Expression;\r\n    /**\r\n     * Sets the expression of the export assignment.\r\n     * @param textOrWriterFunction - Text or writer function to set as the export assignment expression.\r\n     */\r\n    setExpression(textOrWriterFunction: string | WriterFunction): this;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ExportAssignmentStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ExportAssignmentStructure;\r\n}\r\n\r\ndeclare const ExportDeclarationBase: typeof Statement;\r\n\r\nexport declare class ExportDeclaration extends ExportDeclarationBase<ts.ExportDeclaration> {\r\n    /**\r\n     * Sets the import specifier.\r\n     * @param text - Text to set as the module specifier.\r\n     */\r\n    setModuleSpecifier(text: string): this;\r\n    /**\r\n     * Sets the import specifier.\r\n     * @param sourceFile - Source file to set the module specifier from.\r\n     */\r\n    setModuleSpecifier(sourceFile: SourceFile): this;\r\n    /**\r\n     * Gets the module specifier or undefined if it doesn't exist.\r\n     */\r\n    getModuleSpecifier(): StringLiteral | undefined;\r\n    /**\r\n     * Gets the module specifier value or undefined if it doesn't exist.\r\n     */\r\n    getModuleSpecifierValue(): string | undefined;\r\n    /**\r\n     * Gets the source file referenced in the module specifier or throws if it can't find it or it doesn't exist.\r\n     */\r\n    getModuleSpecifierSourceFileOrThrow(): SourceFile;\r\n    /**\r\n     * Gets the source file referenced in the module specifier.\r\n     */\r\n    getModuleSpecifierSourceFile(): SourceFile | undefined;\r\n    /**\r\n     * Gets if the module specifier starts with `./` or `../`.\r\n     */\r\n    isModuleSpecifierRelative(): boolean;\r\n    /**\r\n     * Removes the module specifier.\r\n     */\r\n    removeModuleSpecifier(): this;\r\n    /**\r\n     * Gets if the module specifier exists\r\n     */\r\n    hasModuleSpecifier(): boolean;\r\n    /**\r\n     * Gets if this export declaration is a namespace export.\r\n     */\r\n    isNamespaceExport(): boolean;\r\n    /**\r\n     * Gets if the export declaration has named exports.\r\n     */\r\n    hasNamedExports(): boolean;\r\n    /**\r\n     * Adds a named export.\r\n     * @param namedExport - Structure, name, or writer function to write the named export.\r\n     */\r\n    addNamedExport(namedExport: ExportSpecifierStructure | string | WriterFunction): ExportSpecifier;\r\n    /**\r\n     * Adds named exports.\r\n     * @param namedExports - Structures, names, or writer function to write the named exports.\r\n     */\r\n    addNamedExports(namedExports: ReadonlyArray<ExportSpecifierStructure | string | WriterFunction> | WriterFunction): ExportSpecifier[];\r\n    /**\r\n     * Inserts a named export.\r\n     * @param index - Child index to insert at.\r\n     * @param namedExport - Structure, name, or writer function to write the named export.\r\n     */\r\n    insertNamedExport(index: number, namedExport: ExportSpecifierStructure | string | WriterFunction): ExportSpecifier;\r\n    /**\r\n     * Inserts named exports into the export declaration.\r\n     * @param index - Child index to insert at.\r\n     * @param namedExports - Structures, names, or writer funciton to write the named exports.\r\n     */\r\n    insertNamedExports(index: number, namedExports: ReadonlyArray<ExportSpecifierStructure | string | WriterFunction> | WriterFunction): ExportSpecifier[];\r\n    /**\r\n     * Gets the named exports.\r\n     */\r\n    getNamedExports(): ExportSpecifier[];\r\n    /**\r\n     * Changes the export declaration to namespace export. Removes all the named exports.\r\n     */\r\n    toNamespaceExport(): this;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ExportDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ExportDeclarationStructure;\r\n}\r\n\r\ndeclare const ExportSpecifierBase: typeof Node;\r\n\r\nexport declare class ExportSpecifier extends ExportSpecifierBase<ts.ExportSpecifier> {\r\n    /**\r\n     * Sets the name of what's being exported.\r\n     */\r\n    setName(name: string): this;\r\n    /**\r\n     * Gets the name of the export specifier.\r\n     */\r\n    getName(): string;\r\n    /**\r\n     * Gets the name node of what's being exported.\r\n     */\r\n    getNameNode(): Identifier;\r\n    /**\r\n     * Sets the alias for the name being exported and renames all the usages.\r\n     * @param alias - Alias to set.\r\n     */\r\n    renameAlias(alias: string): this;\r\n    /**\r\n     * Sets the alias without renaming all the usages.\r\n     * @param alias - Alias to set.\r\n     */\r\n    setAlias(alias: string): this;\r\n    /**\r\n     * Removes the alias without renaming.\r\n     * @remarks Use removeAliasWithRename() if you want it to rename any usages to the name of the export specifier.\r\n     */\r\n    removeAlias(): this;\r\n    /**\r\n     * Removes the alias and renames any usages to the name of the export specifier.\r\n     */\r\n    removeAliasWithRename(): this;\r\n    /**\r\n     * Gets the alias identifier, if it exists.\r\n     */\r\n    getAliasNode(): Identifier | undefined;\r\n    /**\r\n     * Gets the export declaration associated with this export specifier.\r\n     */\r\n    getExportDeclaration(): ExportDeclaration;\r\n    /**\r\n     * Gets the local target symbol of the export specifier or throws if it doesn't exist.\r\n     */\r\n    getLocalTargetSymbolOrThrow(): Symbol;\r\n    /**\r\n     * Gets the local target symbol of the export specifier or undefined if it doesn't exist.\r\n     */\r\n    getLocalTargetSymbol(): Symbol | undefined;\r\n    /**\r\n     * Gets all the declarations referenced by the export specifier.\r\n     */\r\n    getLocalTargetDeclarations(): Node[];\r\n    /**\r\n     * Removes the export specifier.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ExportSpecifierStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ExportSpecifierStructure;\r\n}\r\n\r\nexport declare class ExternalModuleReference extends Node<ts.ExternalModuleReference> {\r\n    /**\r\n     * Gets the expression or undefined of the yield expression.\r\n     */\r\n    getExpression(): Expression | undefined;\r\n    /**\r\n     * Gets the expression of the yield expression or throws if it does not exist.\r\n     */\r\n    getExpressionOrThrow(): Expression<ts.Expression>;\r\n    /**\r\n     * Gets the source file referenced or throws if it can't find it.\r\n     */\r\n    getReferencedSourceFileOrThrow(): SourceFile;\r\n    /**\r\n     * Gets if the external module reference is relative.\r\n     */\r\n    isRelative(): boolean;\r\n    /**\r\n     * Gets the source file referenced or returns undefined if it can't find it.\r\n     */\r\n    getReferencedSourceFile(): SourceFile | undefined;\r\n}\r\n/**\r\n * Result of refreshing a source file from the file system.\r\n */\r\nexport declare enum FileSystemRefreshResult {\r\n    /** The source file did not change. */\r\n    NoChange = 0,\r\n    /** The source file was updated from the file system. */\r\n    Updated = 1,\r\n    /** The source file was deleted. */\r\n    Deleted = 2\r\n}\r\n\r\ndeclare const ImportClauseBase: typeof Node;\r\n\r\nexport declare class ImportClause extends ImportClauseBase<ts.ImportClause> {\r\n    /**\r\n     * Gets the default import or throws if it doesn't exit.\r\n     */\r\n    getDefaultImportOrThrow(): Identifier;\r\n    /**\r\n     * Gets the default import or returns undefined if it doesn't exist.\r\n     */\r\n    getDefaultImport(): Identifier | undefined;\r\n    /**\r\n     * Gets the named bindings of the import clause or throws if it doesn't exist.\r\n     */\r\n    getNamedBindingsOrThrow(): NamespaceImport | NamedImports;\r\n    /**\r\n     * Gets the named bindings of the import clause or returns undefined if it doesn't exist.\r\n     */\r\n    getNamedBindings(): NamespaceImport | NamedImports | undefined;\r\n    /**\r\n     * Gets the namespace import if it exists or throws.\r\n     */\r\n    getNamespaceImportOrThrow(): Identifier;\r\n    /**\r\n     * Gets the namespace import identifier, if it exists.\r\n     */\r\n    getNamespaceImport(): Identifier | undefined;\r\n    /**\r\n     * Gets the namespace import identifier, if it exists.\r\n     */\r\n    getNamedImports(): ImportSpecifier[];\r\n}\r\n\r\ndeclare const ImportDeclarationBase: typeof Statement;\r\n\r\nexport declare class ImportDeclaration extends ImportDeclarationBase<ts.ImportDeclaration> {\r\n    /**\r\n     * Sets the import specifier.\r\n     * @param text - Text to set as the module specifier.\r\n     */\r\n    setModuleSpecifier(text: string): this;\r\n    /**\r\n     * Sets the import specifier.\r\n     * @param sourceFile - Source file to set the module specifier from.\r\n     */\r\n    setModuleSpecifier(sourceFile: SourceFile): this;\r\n    /**\r\n     * Gets the module specifier.\r\n     */\r\n    getModuleSpecifier(): StringLiteral;\r\n    /**\r\n     * Gets the module specifier string literal value.\r\n     */\r\n    getModuleSpecifierValue(): string;\r\n    /**\r\n     * Gets the source file referenced in the module specifier or throws if it can't find it.\r\n     */\r\n    getModuleSpecifierSourceFileOrThrow(): SourceFile;\r\n    /**\r\n     * Gets the source file referenced in the module specifier or returns undefined if it can't find it.\r\n     */\r\n    getModuleSpecifierSourceFile(): SourceFile | undefined;\r\n    /**\r\n     * Gets if the module specifier starts with `./` or `../`.\r\n     */\r\n    isModuleSpecifierRelative(): boolean;\r\n    /**\r\n     * Sets the default import.\r\n     * @param text - Text to set as the default import.\r\n     * @remarks Use renameDefaultImport to rename.\r\n     */\r\n    setDefaultImport(text: string): this;\r\n    /**\r\n     * Renames or sets the provided default import.\r\n     * @param text - Text to set or rename the default import with.\r\n     */\r\n    renameDefaultImport(text: string): this;\r\n    /**\r\n     * Gets the default import or throws if it doesn't exit.\r\n     */\r\n    getDefaultImportOrThrow(): Identifier;\r\n    /**\r\n     * Gets the default import or returns undefined if it doesn't exist.\r\n     */\r\n    getDefaultImport(): Identifier | undefined;\r\n    /**\r\n     * Sets the namespace import.\r\n     * @param text - Text to set as the namespace import.\r\n     * @throws - InvalidOperationError if a named import exists.\r\n     */\r\n    setNamespaceImport(text: string): this;\r\n    /**\r\n     * Removes the namespace import.\r\n     */\r\n    removeNamespaceImport(): this;\r\n    /**\r\n     * Removes the default import.\r\n     */\r\n    removeDefaultImport(): this;\r\n    /**\r\n     * Gets the namespace import if it exists or throws.\r\n     */\r\n    getNamespaceImportOrThrow(): Identifier;\r\n    /**\r\n     * Gets the namespace import identifier, if it exists.\r\n     */\r\n    getNamespaceImport(): Identifier | undefined;\r\n    /**\r\n     * Adds a named import.\r\n     * @param namedImport - Name, structure, or writer to write the named import with.\r\n     */\r\n    addNamedImport(namedImport: ImportSpecifierStructure | string | WriterFunction): ImportSpecifier;\r\n    /**\r\n     * Adds named imports.\r\n     * @param namedImport - Structures, names, or writer function to write the named import with.\r\n     */\r\n    addNamedImports(namedImports: ReadonlyArray<ImportSpecifierStructure | string | WriterFunction> | WriterFunction): ImportSpecifier[];\r\n    /**\r\n     * Inserts a named import.\r\n     * @param index - Child index to insert at.\r\n     * @param namedImport - Structure, name, or writer function to write the named import with.\r\n     */\r\n    insertNamedImport(index: number, namedImport: ImportSpecifierStructure | string | WriterFunction): ImportSpecifier;\r\n    /**\r\n     * Inserts named imports into the import declaration.\r\n     * @param index - Child index to insert at.\r\n     * @param namedImports - Structures, names, or writer function to write the named import with.\r\n     */\r\n    insertNamedImports(index: number, namedImports: ReadonlyArray<ImportSpecifierStructure | string | WriterFunction> | WriterFunction): ImportSpecifier[];\r\n    /**\r\n     * Gets the named imports.\r\n     */\r\n    getNamedImports(): ImportSpecifier[];\r\n    /**\r\n     * Removes all the named imports.\r\n     */\r\n    removeNamedImports(): this;\r\n    /**\r\n     * Gets the import clause or throws if it doesn't exist.\r\n     */\r\n    getImportClauseOrThrow(): ImportClause;\r\n    /**\r\n     * Gets the import clause or returns undefined if it doesn't exist.\r\n     */\r\n    getImportClause(): ImportClause | undefined;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ImportDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ImportDeclarationStructure;\r\n}\r\n\r\ndeclare const ImportEqualsDeclarationBase: Constructor<JSDocableNode> & Constructor<NamedNode> & typeof Statement;\r\n\r\nexport declare class ImportEqualsDeclaration extends ImportEqualsDeclarationBase<ts.ImportEqualsDeclaration> {\r\n    /**\r\n     * Gets the module reference of the import equals declaration.\r\n     */\r\n    getModuleReference(): ModuleReference;\r\n    /**\r\n     * Gets if the external module reference is relative.\r\n     */\r\n    isExternalModuleReferenceRelative(): boolean;\r\n    /**\r\n     * Sets the external module reference.\r\n     * @param externalModuleReference - External module reference as a string.\r\n     */\r\n    setExternalModuleReference(externalModuleReference: string): this;\r\n    /**\r\n     * Sets the external module reference.\r\n     * @param sourceFile - Source file to set the external module reference to.\r\n     */\r\n    setExternalModuleReference(sourceFile: SourceFile): this;\r\n    /**\r\n     * Gets the source file referenced in the external module reference or throws if it doesn't exist.\r\n     */\r\n    getExternalModuleReferenceSourceFileOrThrow(): SourceFile;\r\n    /**\r\n     * Gets the source file referenced in the external module reference or returns undefined if it doesn't exist.\r\n     */\r\n    getExternalModuleReferenceSourceFile(): SourceFile | undefined;\r\n}\r\n\r\ndeclare const ImportSpecifierBase: typeof Node;\r\n\r\nexport declare class ImportSpecifier extends ImportSpecifierBase<ts.ImportSpecifier> {\r\n    /**\r\n     * Sets the identifier being imported.\r\n     * @param name - Name being imported.\r\n     */\r\n    setName(name: string): this;\r\n    /**\r\n     * Gets the name of the import specifier.\r\n     */\r\n    getName(): string;\r\n    /**\r\n     * Gets the name node of what's being imported.\r\n     */\r\n    getNameNode(): Identifier;\r\n    /**\r\n     * Sets the alias for the name being imported and renames all the usages.\r\n     * @param alias - Alias to set.\r\n     */\r\n    renameAlias(alias: string): this;\r\n    /**\r\n     * Sets the alias without renaming all the usages.\r\n     * @param alias - Alias to set.\r\n     */\r\n    setAlias(alias: string): this;\r\n    /**\r\n     * Removes the alias without renaming.\r\n     * @remarks Use removeAliasWithRename() if you want it to rename any usages to the name of the import specifier.\r\n     */\r\n    removeAlias(): this;\r\n    /**\r\n     * Removes the alias and renames any usages to the name of the import specifier.\r\n     */\r\n    removeAliasWithRename(): this;\r\n    /**\r\n     * Gets the alias identifier, if it exists.\r\n     */\r\n    getAliasNode(): Identifier | undefined;\r\n    /**\r\n     * Gets the import declaration associated with this import specifier.\r\n     */\r\n    getImportDeclaration(): ImportDeclaration;\r\n    /**\r\n     * Remove the import specifier.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<ImportSpecifierStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): ImportSpecifierStructure;\r\n}\r\n\r\ndeclare const ModuleBlockBase: Constructor<StatementedNode> & typeof Statement;\r\n\r\nexport declare class ModuleBlock extends ModuleBlockBase<ts.ModuleBlock> {\r\n}\r\n\r\ndeclare const NamedExportsBase: typeof Node;\r\n\r\nexport declare class NamedExports extends NamedExportsBase<ts.NamedExports> {\r\n    /** Gets the export specifiers. */\r\n    getElements(): ExportSpecifier[];\r\n}\r\n\r\ndeclare const NamedImportsBase: typeof Node;\r\n\r\nexport declare class NamedImports extends NamedImportsBase<ts.NamedImports> {\r\n    /** Gets the import specifiers. */\r\n    getElements(): ImportSpecifier[];\r\n}\r\n\r\nexport declare function NamespaceChildableNode<T extends Constructor<NamespaceChildableNodeExtensionType>>(Base: T): Constructor<NamespaceChildableNode> & T;\r\n\r\nexport interface NamespaceChildableNode {\r\n    /**\r\n     * Gets the parent namespace or undefined if it doesn't exist.\r\n     */\r\n    getParentNamespace(): NamespaceDeclaration | undefined;\r\n    /**\r\n     * Gets the parent namespace or throws if it doesn't exist.\r\n     */\r\n    getParentNamespaceOrThrow(): NamespaceDeclaration;\r\n}\r\n\r\ndeclare type NamespaceChildableNodeExtensionType = Node;\r\n\r\ndeclare const NamespaceDeclarationBase: Constructor<ModuledNode> & Constructor<ChildOrderableNode> & Constructor<UnwrappableNode> & Constructor<TextInsertableNode> & Constructor<BodiedNode> & Constructor<NamespaceChildableNode> & Constructor<StatementedNode> & Constructor<JSDocableNode> & Constructor<AmbientableNode> & Constructor<ExportableNode> & Constructor<ModifierableNode> & Constructor<NamedNode> & typeof Statement;\r\n\r\nexport declare class NamespaceDeclaration extends NamespaceDeclarationBase<ts.NamespaceDeclaration> {\r\n    /**\r\n     * Gets the full name of the namespace.\r\n     */\r\n    getName(): string;\r\n    /**\r\n     * Sets the name without renaming references.\r\n     * @param newName - New full namespace name.\r\n     */\r\n    setName(newName: string): this;\r\n    /**\r\n     * Renames the name.\r\n     * @param newName - New name.\r\n     */\r\n    rename(newName: string): this;\r\n    /**\r\n     * Gets the name nodes.\r\n     */\r\n    getNameNodes(): Identifier[];\r\n    /**\r\n     * Gets if this namespace has a namespace keyword.\r\n     */\r\n    hasNamespaceKeyword(): boolean;\r\n    /**\r\n     * Gets if this namespace has a namespace keyword.\r\n     */\r\n    hasModuleKeyword(): boolean;\r\n    /**\r\n     * Sets the namespace declaration kind.\r\n     * @param kind - Kind to set.\r\n     */\r\n    setDeclarationKind(kind: NamespaceDeclarationKind): this;\r\n    /**\r\n     * Gets the namesapce declaration kind.\r\n     */\r\n    getDeclarationKind(): NamespaceDeclarationKind;\r\n    /**\r\n     * Gets the namespace or module keyword or returns undefined if it's global.\r\n     */\r\n    getDeclarationKindKeyword(): Node<ts.Node> | undefined;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<NamespaceDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): NamespaceDeclarationStructure;\r\n}\r\nexport declare enum NamespaceDeclarationKind {\r\n    Namespace = \"namespace\",\r\n    Module = \"module\",\r\n    Global = \"global\"\r\n}\r\n\r\ndeclare const NamespaceImportBase: Constructor<RenameableNode> & typeof Node;\r\n\r\nexport declare class NamespaceImport extends NamespaceImportBase<ts.NamespaceImport> {\r\n    /**\r\n     * Sets the name of the namespace import.\r\n     */\r\n    setName(name: string): this;\r\n    /**\r\n     * Gets the name of the namespace import.\r\n     */\r\n    getName(): string;\r\n    /**\r\n     * Gets the namespace import's name node.\r\n     */\r\n    getNameNode(): Identifier;\r\n}\r\n\r\nexport interface SourceFileCopyOptions {\r\n    overwrite?: boolean;\r\n}\r\n\r\nexport interface SourceFileMoveOptions {\r\n    overwrite?: boolean;\r\n}\r\n\r\n/**\r\n * Options for emitting a source file.\r\n */\r\nexport interface SourceFileEmitOptions extends EmitOptionsBase {\r\n}\r\n\r\ndeclare const SourceFileBase: Constructor<ModuledNode> & Constructor<StatementedNode> & Constructor<TextInsertableNode> & typeof Node;\r\n\r\nexport declare class SourceFile extends SourceFileBase<ts.SourceFile> {\r\n    private constructor();\r\n    /**\r\n     * Gets the file path.\r\n     */\r\n    getFilePath(): string;\r\n    /**\r\n     * Gets the file path's base name.\r\n     */\r\n    getBaseName(): string;\r\n    /**\r\n     * Gets the file path's base name without the extension.\r\n     */\r\n    getBaseNameWithoutExtension(): string;\r\n    /**\r\n     * Gets the file path's extension.\r\n     */\r\n    getExtension(): string;\r\n    /**\r\n     * Gets the directory that the source file is contained in.\r\n     */\r\n    getDirectory(): Directory;\r\n    /**\r\n     * Gets the directory path that the source file is contained in.\r\n     */\r\n    getDirectoryPath(): string;\r\n    /**\r\n     * Gets the full text with leading trivia.\r\n     */\r\n    getFullText(): string;\r\n    /**\r\n     * Gets the line number at the provided position.\r\n     * @param pos - Position\r\n     */\r\n    getLineNumberAtPos(pos: number): number;\r\n    /**\r\n     * Gets the character count from the start of the line to the provided position.\r\n     * @param pos - Position.\r\n     */\r\n    getLengthFromLineStartAtPos(pos: number): number;\r\n    /**\r\n     * Copies this source file to the specified directory.\r\n     *\r\n     * This will modify the module specifiers in the new file, if necessary.\r\n     * @param dirPathOrDirectory Directory path or directory object to copy the file to.\r\n     * @param options Options for copying.\r\n     * @returns The source file the copy was made to.\r\n     */\r\n    copyToDirectory(dirPathOrDirectory: string | Directory, options?: SourceFileCopyOptions): SourceFile;\r\n    /**\r\n     * Copy this source file to a new file.\r\n     *\r\n     * This will modify the module specifiers in the new file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for copying.\r\n     */\r\n    copy(filePath: string, options?: SourceFileCopyOptions): SourceFile;\r\n    /**\r\n     * Copy this source file to a new file and immediately saves it to the file system asynchronously.\r\n     *\r\n     * This will modify the module specifiers in the new file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for copying.\r\n     */\r\n    copyImmediately(filePath: string, options?: SourceFileCopyOptions): Promise<SourceFile>;\r\n    /**\r\n     * Copy this source file to a new file and immediately saves it to the file system synchronously.\r\n     *\r\n     * This will modify the module specifiers in the new file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for copying.\r\n     */\r\n    copyImmediatelySync(filePath: string, options?: SourceFileCopyOptions): SourceFile;\r\n    /**\r\n     * Moves this source file to the specified directory.\r\n     *\r\n     * This will modify the module specifiers in other files that specify this file and the module specifiers in the current file, if necessary.\r\n     * @param dirPathOrDirectory Directory path or directory object to move the file to.\r\n     * @param options Options for moving.\r\n     */\r\n    moveToDirectory(dirPathOrDirectory: string | Directory, options?: SourceFileMoveOptions): SourceFile;\r\n    /**\r\n     * Moves this source file to a new file.\r\n     *\r\n     * This will modify the module specifiers in other files that specify this file and the module specifiers in the current file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for moving.\r\n     */\r\n    move(filePath: string, options?: SourceFileMoveOptions): SourceFile;\r\n    /**\r\n     * Moves this source file to a new file and asynchronously updates the file system immediately.\r\n     *\r\n     * This will modify the module specifiers in other files that specify this file and the module specifiers in the current file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for moving.\r\n     */\r\n    moveImmediately(filePath: string, options?: SourceFileMoveOptions): Promise<SourceFile>;\r\n    /**\r\n     * Moves this source file to a new file and synchronously updates the file system immediately.\r\n     *\r\n     * This will modify the module specifiers in other files that specify this file and the module specifiers in the current file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for moving.\r\n     */\r\n    moveImmediatelySync(filePath: string, options?: SourceFileMoveOptions): SourceFile;\r\n    /**\r\n     * Queues a deletion of the file to the file system.\r\n     *\r\n     * The file will be deleted when you call ast.save(). If you wish to immediately delete the file, then use deleteImmediately().\r\n     */\r\n    delete(): void;\r\n    /**\r\n     * Asynchronously deletes the file from the file system.\r\n     */\r\n    deleteImmediately(): Promise<void>;\r\n    /**\r\n     * Synchronously deletes the file from the file system.\r\n     */\r\n    deleteImmediatelySync(): void;\r\n    /**\r\n     * Asynchronously saves this file with any changes.\r\n     */\r\n    save(): Promise<void>;\r\n    /**\r\n     * Synchronously saves this file with any changes.\r\n     */\r\n    saveSync(): void;\r\n    /**\r\n     * Gets any source files referenced via `/// <reference path=\"...\" />` comments.\r\n     */\r\n    getReferencedFiles(): SourceFile[];\r\n    /**\r\n     * Gets any source files referenced via `/// <reference types=\"...\" />` comments.\r\n     */\r\n    getTypeReferenceDirectives(): SourceFile[];\r\n    /**\r\n     * Get any source files that reference this source file.\r\n     */\r\n    getReferencingSourceFiles(): SourceFile[];\r\n    /**\r\n     * Gets the import and exports in other source files that reference this source file.\r\n     */\r\n    getReferencingNodesInOtherSourceFiles(): SourceFileReferencingNodes[];\r\n    /**\r\n     * Gets the string literals in other source files that reference this source file.\r\n     */\r\n    getReferencingLiteralsInOtherSourceFiles(): StringLiteral[];\r\n    /**\r\n     * Gets all the descendant string literals that reference a source file.\r\n     */\r\n    getImportStringLiterals(): StringLiteral[];\r\n    /**\r\n     * Gets the script target of the source file.\r\n     */\r\n    getLanguageVersion(): ScriptTarget;\r\n    /**\r\n     * Gets the language variant of the source file.\r\n     */\r\n    getLanguageVariant(): LanguageVariant;\r\n    /**\r\n     * Gets if this is a declaration file.\r\n     */\r\n    isDeclarationFile(): boolean;\r\n    /**\r\n     * Gets if the source file was discovered while loading an external library.\r\n     */\r\n    isFromExternalLibrary(): boolean;\r\n    /**\r\n     * Gets if the source file is a descendant of a node_modules directory.\r\n     */\r\n    isInNodeModules(): boolean;\r\n    /**\r\n     * Gets if this source file has been saved or if the latest changes have been saved.\r\n     */\r\n    isSaved(): boolean;\r\n    /**\r\n     * Gets the pre-emit diagnostics of the specified source file.\r\n     */\r\n    getPreEmitDiagnostics(): Diagnostic[];\r\n    /**\r\n     * Deindents the line at the specified position.\r\n     * @param pos - Position.\r\n     * @param times - Times to unindent. Specify a negative value to indent.\r\n     */\r\n    unindent(pos: number, times?: number): this;\r\n    /**\r\n     * Deindents the lines within the specified range.\r\n     * @param positionRange - Position range.\r\n     * @param times - Times to unindent. Specify a negative value to indent.\r\n     */\r\n    unindent(positionRange: [number, number], times?: number): this;\r\n    /**\r\n     * Indents the line at the specified position.\r\n     * @param pos - Position.\r\n     * @param times - Times to indent. Specify a negative value to unindent.\r\n     */\r\n    indent(pos: number, times?: number): this;\r\n    /**\r\n     * Indents the lines within the specified range.\r\n     * @param positionRange - Position range.\r\n     * @param times - Times to indent. Specify a negative value to unindent.\r\n     */\r\n    indent(positionRange: [number, number], times?: number): this;\r\n    /**\r\n     * Emits the source file.\r\n     */\r\n    emit(options?: SourceFileEmitOptions): EmitResult;\r\n    /**\r\n     * Gets the emit output of this source file.\r\n     * @param options - Emit options.\r\n     */\r\n    getEmitOutput(options?: {\r\n        emitOnlyDtsFiles?: boolean;\r\n    }): EmitOutput;\r\n    /**\r\n     * Formats the source file text using the internal TypeScript formatting API.\r\n     * @param settings - Format code settings.\r\n     */\r\n    formatText(settings?: FormatCodeSettings): void;\r\n    /**\r\n     * Refresh the source file from the file system.\r\n     *\r\n     * WARNING: When updating from the file system, this will \"forget\" any previously navigated nodes.\r\n     * @returns What action ended up taking place.\r\n     */\r\n    refreshFromFileSystem(): Promise<FileSystemRefreshResult>;\r\n    /**\r\n     * Synchronously refreshes the source file from the file system.\r\n     *\r\n     * WARNING: When updating from the file system, this will \"forget\" any previously navigated nodes.\r\n     * @returns What action ended up taking place.\r\n     */\r\n    refreshFromFileSystemSync(): FileSystemRefreshResult;\r\n    /**\r\n     * Gets the relative path to another source file.\r\n     * @param sourceFile - Source file.\r\n     */\r\n    getRelativePathTo(sourceFile: SourceFile): string;\r\n    /**\r\n     * Gets the relative path to another directory.\r\n     * @param directory - Directory.\r\n     */\r\n    getRelativePathTo(directory: Directory): string;\r\n    /**\r\n     * Gets the relative path to the specified source file as a module specifier.\r\n     * @param sourceFile - Source file.\r\n     */\r\n    getRelativePathAsModuleSpecifierTo(sourceFile: SourceFile): string;\r\n    /**\r\n     * Gets the relative path to the specified directory as a module specifier.\r\n     * @param directory - Directory.\r\n     */\r\n    getRelativePathAsModuleSpecifierTo(directory: Directory): string;\r\n    /**\r\n     * Subscribe to when the source file is modified.\r\n     * @param subscription - Subscription.\r\n     * @param subscribe - Optional and defaults to true. Use an explicit false to unsubscribe.\r\n     */\r\n    onModified(subscription: (sender: SourceFile) => void, subscribe?: boolean): this;\r\n    /**\r\n     * Organizes the imports in the file.\r\n     *\r\n     * WARNING! This will forget all the nodes in the file! It's best to do this after you're all done with the file.\r\n     * @param formatSettings - Format code settings.\r\n     * @param userPreferences - User preferences for refactoring.\r\n     */\r\n    organizeImports(formatSettings?: FormatCodeSettings, userPreferences?: UserPreferences): this;\r\n    /**\r\n     * Code fix to add import declarations for identifiers that are referenced, but not imported in the source file.\r\n     * @param formatSettings - Format code settings.\r\n     * @param userPreferences - User preferences for refactoring.\r\n     */\r\n    fixMissingImports(formatSettings?: FormatCodeSettings, userPreferences?: UserPreferences): this;\r\n    /**\r\n     * Applies the text changes to the source file.\r\n     *\r\n     * WARNING! This will forget all the nodes in the file! It's best to do this after you're all done with the file.\r\n     * @param textChanges - Text changes.\r\n     */\r\n    applyTextChanges(textChanges: ReadonlyArray<TextChange>): this;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<SourceFileStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): SourceFileStructure;\r\n    private _refreshFromFileSystemInternal;\r\n}\r\n\r\ndeclare const BlockBase: Constructor<TextInsertableNode> & Constructor<StatementedNode> & typeof Statement;\r\n\r\nexport declare class Block extends BlockBase<ts.Block> {\r\n}\r\n\r\ndeclare const BreakStatementBase: Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class BreakStatement extends BreakStatementBase<ts.BreakStatement> {\r\n    /**\r\n     * Gets this break statement's label or undefined if it does not exist.\r\n     */\r\n    getLabel(): Identifier | undefined;\r\n    /**\r\n     * Gets this break statement's label or throw if it does not exist.\r\n     */\r\n    getLabelOrThrow(): Identifier;\r\n}\r\n\r\ndeclare const CaseBlockBase: Constructor<TextInsertableNode> & typeof Node;\r\n\r\nexport declare class CaseBlock extends CaseBlockBase<ts.CaseBlock> {\r\n    /**\r\n     * Gets the clauses.\r\n     */\r\n    getClauses(): CaseOrDefaultClause[];\r\n    /**\r\n     * Removes the clause at the specified index.\r\n     * @param index - Index.\r\n     */\r\n    removeClause(index: number): this;\r\n    /**\r\n     * Removes the clauses in the specified range.\r\n     * @param indexRange - Index range.\r\n     */\r\n    removeClauses(indexRange: [number, number]): this;\r\n}\r\n\r\ndeclare const CaseClauseBase: Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<StatementedNode> & typeof Node;\r\n\r\nexport declare class CaseClause extends CaseClauseBase<ts.CaseClause> {\r\n    /**\r\n     * Gets this switch statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n    /**\r\n     * Removes this case clause.\r\n     */\r\n    remove(): void;\r\n}\r\n\r\ndeclare const CatchClauseBase: typeof Node;\r\n\r\nexport declare class CatchClause extends CatchClauseBase<ts.CatchClause> {\r\n    /**\r\n     * Gets this catch clause's block.\r\n     */\r\n    getBlock(): Block;\r\n    /**\r\n     * Gets this catch clause's variable declaration or undefined if none exists.\r\n     */\r\n    getVariableDeclaration(): VariableDeclaration | undefined;\r\n    /**\r\n     * Gets this catch clause's variable declaration or throws if none exists.\r\n     */\r\n    getVariableDeclarationOrThrow(): VariableDeclaration;\r\n}\r\n\r\ndeclare const ContinueStatementBase: Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class ContinueStatement extends ContinueStatementBase<ts.ContinueStatement> {\r\n    /**\r\n     * Gets this continue statement's label or undefined if it does not exist.\r\n     */\r\n    getLabel(): Identifier | undefined;\r\n    /**\r\n     * Gets this continue statement's label or throw if it does not exist.\r\n     */\r\n    getLabelOrThrow(): Identifier;\r\n}\r\n\r\ndeclare const DebuggerStatementBase: typeof Statement;\r\n\r\nexport declare class DebuggerStatement extends DebuggerStatementBase<ts.DebuggerStatement> {\r\n}\r\n\r\ndeclare const DefaultClauseBase: Constructor<ChildOrderableNode> & Constructor<TextInsertableNode> & Constructor<StatementedNode> & typeof Node;\r\n\r\nexport declare class DefaultClause extends DefaultClauseBase<ts.DefaultClause> {\r\n    /**\r\n     * Removes the default clause.\r\n     */\r\n    remove(): void;\r\n}\r\n\r\ndeclare const DoStatementBase: typeof IterationStatement;\r\n\r\nexport declare class DoStatement extends DoStatementBase<ts.DoStatement> {\r\n    /**\r\n     * Gets this do statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n}\r\n\r\ndeclare const EmptyStatementBase: typeof Statement;\r\n\r\nexport declare class EmptyStatement extends EmptyStatementBase<ts.EmptyStatement> {\r\n}\r\n\r\ndeclare const ExpressionStatementBase: Constructor<JSDocableNode> & Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class ExpressionStatement extends ExpressionStatementBase<ts.ExpressionStatement> {\r\n    /**\r\n     * Gets this expression statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n}\r\n\r\ndeclare const ForInStatementBase: typeof IterationStatement;\r\n\r\nexport declare class ForInStatement extends ForInStatementBase<ts.ForInStatement> {\r\n    /**\r\n     * Gets this for in statement's initializer.\r\n     */\r\n    getInitializer(): VariableDeclarationList | Expression;\r\n    /**\r\n     * Gets this for in statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n}\r\n\r\ndeclare const ForOfStatementBase: Constructor<AwaitableNode> & typeof IterationStatement;\r\n\r\nexport declare class ForOfStatement extends ForOfStatementBase<ts.ForOfStatement> {\r\n    /**\r\n     * Gets this for of statement's initializer.\r\n     */\r\n    getInitializer(): VariableDeclarationList | Expression;\r\n    /**\r\n     * Gets this for of statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n}\r\n\r\ndeclare const ForStatementBase: typeof IterationStatement;\r\n\r\nexport declare class ForStatement extends ForStatementBase<ts.ForStatement> {\r\n    /**\r\n     * Gets this for statement's initializer or undefined if none exists.\r\n     */\r\n    getInitializer(): VariableDeclarationList | Expression | undefined;\r\n    /**\r\n     * Gets this for statement's initializer or throws if none exists.\r\n     */\r\n    getInitializerOrThrow(): Expression<ts.Expression> | VariableDeclarationList;\r\n    /**\r\n     * Gets this for statement's condition or undefined if none exists.\r\n     */\r\n    getCondition(): Expression | undefined;\r\n    /**\r\n     * Gets this for statement's condition or throws if none exists.\r\n     */\r\n    getConditionOrThrow(): Expression<ts.Expression>;\r\n    /**\r\n     * Gets this for statement's incrementor.\r\n     */\r\n    getIncrementor(): Expression | undefined;\r\n    /**\r\n     * Gets this for statement's incrementor or throws if none exists.\r\n     */\r\n    getIncrementorOrThrow(): Expression<ts.Expression>;\r\n}\r\n\r\ndeclare const IfStatementBase: Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class IfStatement extends IfStatementBase<ts.IfStatement> {\r\n    /**\r\n     * Gets this if statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n    /**\r\n     * Gets this if statement's then statement.\r\n     */\r\n    getThenStatement(): Statement;\r\n    /**\r\n     * Gets this if statement's else statement.\r\n     */\r\n    getElseStatement(): Statement | undefined;\r\n}\r\n\r\ndeclare const IterationStatementBase: Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class IterationStatement<T extends ts.IterationStatement = ts.IterationStatement> extends IterationStatementBase<T> {\r\n    /**\r\n     * Gets this iteration statement's statement.\r\n     */\r\n    getStatement(): Statement;\r\n}\r\n\r\ndeclare const LabeledStatementBase: Constructor<JSDocableNode> & Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class LabeledStatement extends LabeledStatementBase<ts.LabeledStatement> {\r\n    /**\r\n     * Gets this labeled statement's label\r\n     */\r\n    getLabel(): Identifier;\r\n    /**\r\n     * Gets this labeled statement's statement\r\n     */\r\n    getStatement(): Statement;\r\n}\r\n\r\ndeclare const NotEmittedStatementBase: typeof Statement;\r\n\r\nexport declare class NotEmittedStatement extends NotEmittedStatementBase<ts.NotEmittedStatement> {\r\n}\r\n\r\ndeclare const ReturnStatementBase: Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class ReturnStatement extends ReturnStatementBase<ts.ReturnStatement> {\r\n    /**\r\n     * Gets this return statement's expression if it exists or throws.\r\n     */\r\n    getExpressionOrThrow(): Expression<ts.Expression>;\r\n    /**\r\n     * Gets this return statement's expression if it exists.\r\n     */\r\n    getExpression(): Expression | undefined;\r\n}\r\n\r\nexport declare class Statement<T extends ts.Statement = ts.Statement> extends Node<T> {\r\n    /**\r\n     * Removes the statement.\r\n     */\r\n    remove(): void;\r\n}\r\n\r\nexport declare function StatementedNode<T extends Constructor<StatementedNodeExtensionType>>(Base: T): Constructor<StatementedNode> & T;\r\n\r\nexport interface StatementedNode {\r\n    /**\r\n     * Gets the node's statements.\r\n     */\r\n    getStatements(): Statement[];\r\n    /**\r\n     * Gets the first statement that matches the provided condition or returns undefined if it doesn't exist.\r\n     * @param findFunction - Function to find the statement by.\r\n     */\r\n    getStatement(findFunction: (statement: Node) => boolean): Statement | undefined;\r\n    /**\r\n     * Gets the first statement that matches the provided condition or throws if it doesn't exist.\r\n     * @param findFunction - Function to find the statement by.\r\n     */\r\n    getStatementOrThrow(findFunction: (statement: Node) => boolean): Statement;\r\n    /**\r\n     * Gets the first statement that matches the provided syntax kind or returns undefined if it doesn't exist.\r\n     * @param kind - Syntax kind to find the node by.\r\n     */\r\n    getStatementByKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;\r\n    /**\r\n     * Gets the first statement that matches the provided syntax kind or throws if it doesn't exist.\r\n     * @param kind - Syntax kind to find the node by.\r\n     */\r\n    getStatementByKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];\r\n    /**\r\n     * Add statements.\r\n     * @param textOrWriterFunction - Text or writer function to add the statement or statements with.\r\n     * @returns The statements that were added.\r\n     */\r\n    addStatements(textOrWriterFunction: string | WriterFunction): Statement[];\r\n    /**\r\n     * Inserts statements at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param textOrWriterFunction - Text or writer function to write the statement or statements with.\r\n     * @returns The statements that were inserted.\r\n     */\r\n    insertStatements(index: number, textOrWriterFunction: string | WriterFunction): Statement[];\r\n    /**\r\n     * Removes the statement at the specified index.\r\n     * @param index - Child index to remove the statement at.\r\n     */\r\n    removeStatement(index: number): this;\r\n    /**\r\n     * Removes the statements at the specified index range.\r\n     * @param indexRange - The start and end inclusive index range to remove.\r\n     */\r\n    removeStatements(indexRange: [number, number]): this;\r\n    /**\r\n     * Adds an class declaration as a child.\r\n     * @param structure - Structure of the class declaration to add.\r\n     */\r\n    addClass(structure: ClassDeclarationStructure): ClassDeclaration;\r\n    /**\r\n     * Adds class declarations as a child.\r\n     * @param structures - Structures of the class declarations to add.\r\n     */\r\n    addClasses(structures: ReadonlyArray<ClassDeclarationStructure>): ClassDeclaration[];\r\n    /**\r\n     * Inserts an class declaration as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the class declaration to insert.\r\n     */\r\n    insertClass(index: number, structure: ClassDeclarationStructure): ClassDeclaration;\r\n    /**\r\n     * Inserts class declarations as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the class declarations to insert.\r\n     */\r\n    insertClasses(index: number, structures: ReadonlyArray<ClassDeclarationStructure>): ClassDeclaration[];\r\n    /**\r\n     * Gets the direct class declaration children.\r\n     */\r\n    getClasses(): ClassDeclaration[];\r\n    /**\r\n     * Gets a class.\r\n     * @param name - Name of the class.\r\n     */\r\n    getClass(name: string): ClassDeclaration | undefined;\r\n    /**\r\n     * Gets a class.\r\n     * @param findFunction - Function to use to find the class.\r\n     */\r\n    getClass(findFunction: (declaration: ClassDeclaration) => boolean): ClassDeclaration | undefined;\r\n    /**\r\n     * Gets a class or throws if it doesn't exist.\r\n     * @param name - Name of the class.\r\n     */\r\n    getClassOrThrow(name: string): ClassDeclaration;\r\n    /**\r\n     * Gets a class or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the class.\r\n     */\r\n    getClassOrThrow(findFunction: (declaration: ClassDeclaration) => boolean): ClassDeclaration;\r\n    /**\r\n     * Adds an enum declaration as a child.\r\n     * @param structure - Structure of the enum declaration to add.\r\n     */\r\n    addEnum(structure: EnumDeclarationStructure): EnumDeclaration;\r\n    /**\r\n     * Adds enum declarations as a child.\r\n     * @param structures - Structures of the enum declarations to add.\r\n     */\r\n    addEnums(structures: ReadonlyArray<EnumDeclarationStructure>): EnumDeclaration[];\r\n    /**\r\n     * Inserts an enum declaration as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the enum declaration to insert.\r\n     */\r\n    insertEnum(index: number, structure: EnumDeclarationStructure): EnumDeclaration;\r\n    /**\r\n     * Inserts enum declarations as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the enum declarations to insert.\r\n     */\r\n    insertEnums(index: number, structures: ReadonlyArray<EnumDeclarationStructure>): EnumDeclaration[];\r\n    /**\r\n     * Gets the direct enum declaration children.\r\n     */\r\n    getEnums(): EnumDeclaration[];\r\n    /**\r\n     * Gets an enum.\r\n     * @param name - Name of the enum.\r\n     */\r\n    getEnum(name: string): EnumDeclaration | undefined;\r\n    /**\r\n     * Gets an enum.\r\n     * @param findFunction - Function to use to find the enum.\r\n     */\r\n    getEnum(findFunction: (declaration: EnumDeclaration) => boolean): EnumDeclaration | undefined;\r\n    /**\r\n     * Gets an enum or throws if it doesn't exist.\r\n     * @param name - Name of the enum.\r\n     */\r\n    getEnumOrThrow(name: string): EnumDeclaration;\r\n    /**\r\n     * Gets an enum or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the enum.\r\n     */\r\n    getEnumOrThrow(findFunction: (declaration: EnumDeclaration) => boolean): EnumDeclaration;\r\n    /**\r\n     * Adds a function declaration as a child.\r\n     * @param structure - Structure of the function declaration to add.\r\n     */\r\n    addFunction(structure: FunctionDeclarationStructure): FunctionDeclaration;\r\n    /**\r\n     * Adds function declarations as a child.\r\n     * @param structures - Structures of the function declarations to add.\r\n     */\r\n    addFunctions(structures: ReadonlyArray<FunctionDeclarationStructure>): FunctionDeclaration[];\r\n    /**\r\n     * Inserts an function declaration as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the function declaration to insert.\r\n     */\r\n    insertFunction(index: number, structure: FunctionDeclarationStructure): FunctionDeclaration;\r\n    /**\r\n     * Inserts function declarations as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the function declarations to insert.\r\n     */\r\n    insertFunctions(index: number, structures: ReadonlyArray<FunctionDeclarationStructure>): FunctionDeclaration[];\r\n    /**\r\n     * Gets the direct function declaration children.\r\n     */\r\n    getFunctions(): FunctionDeclaration[];\r\n    /**\r\n     * Gets a function.\r\n     * @param name - Name of the function.\r\n     */\r\n    getFunction(name: string): FunctionDeclaration | undefined;\r\n    /**\r\n     * Gets a function.\r\n     * @param findFunction - Function to use to find the function.\r\n     */\r\n    getFunction(findFunction: (declaration: FunctionDeclaration) => boolean): FunctionDeclaration | undefined;\r\n    /**\r\n     * Gets a function or throws if it doesn't exist.\r\n     * @param name - Name of the function.\r\n     */\r\n    getFunctionOrThrow(name: string): FunctionDeclaration;\r\n    /**\r\n     * Gets a function or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the function.\r\n     */\r\n    getFunctionOrThrow(findFunction: (declaration: FunctionDeclaration) => boolean): FunctionDeclaration;\r\n    /**\r\n     * Adds a interface declaration as a child.\r\n     * @param structure - Structure of the interface declaration to add.\r\n     */\r\n    addInterface(structure: InterfaceDeclarationStructure): InterfaceDeclaration;\r\n    /**\r\n     * Adds interface declarations as a child.\r\n     * @param structures - Structures of the interface declarations to add.\r\n     */\r\n    addInterfaces(structures: ReadonlyArray<InterfaceDeclarationStructure>): InterfaceDeclaration[];\r\n    /**\r\n     * Inserts an interface declaration as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the interface declaration to insert.\r\n     */\r\n    insertInterface(index: number, structure: InterfaceDeclarationStructure): InterfaceDeclaration;\r\n    /**\r\n     * Inserts interface declarations as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the interface declarations to insert.\r\n     */\r\n    insertInterfaces(index: number, structures: ReadonlyArray<InterfaceDeclarationStructure>): InterfaceDeclaration[];\r\n    /**\r\n     * Gets the direct interface declaration children.\r\n     */\r\n    getInterfaces(): InterfaceDeclaration[];\r\n    /**\r\n     * Gets an interface.\r\n     * @param name - Name of the interface.\r\n     */\r\n    getInterface(name: string): InterfaceDeclaration | undefined;\r\n    /**\r\n     * Gets an interface.\r\n     * @param findFunction - Function to use to find the interface.\r\n     */\r\n    getInterface(findFunction: (declaration: InterfaceDeclaration) => boolean): InterfaceDeclaration | undefined;\r\n    /**\r\n     * Gets an interface or throws if it doesn't exist.\r\n     * @param name - Name of the interface.\r\n     */\r\n    getInterfaceOrThrow(name: string): InterfaceDeclaration;\r\n    /**\r\n     * Gets an interface or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the interface.\r\n     */\r\n    getInterfaceOrThrow(findFunction: (declaration: InterfaceDeclaration) => boolean): InterfaceDeclaration;\r\n    /**\r\n     * Adds a namespace declaration as a child.\r\n     * @param structure - Structure of the namespace declaration to add.\r\n     */\r\n    addNamespace(structure: NamespaceDeclarationStructure): NamespaceDeclaration;\r\n    /**\r\n     * Adds namespace declarations as a child.\r\n     * @param structures - Structures of the namespace declarations to add.\r\n     */\r\n    addNamespaces(structures: ReadonlyArray<NamespaceDeclarationStructure>): NamespaceDeclaration[];\r\n    /**\r\n     * Inserts an namespace declaration as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the namespace declaration to insert.\r\n     */\r\n    insertNamespace(index: number, structure: NamespaceDeclarationStructure): NamespaceDeclaration;\r\n    /**\r\n     * Inserts namespace declarations as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the namespace declarations to insert.\r\n     */\r\n    insertNamespaces(index: number, structures: ReadonlyArray<NamespaceDeclarationStructure>): NamespaceDeclaration[];\r\n    /**\r\n     * Gets the direct namespace declaration children.\r\n     */\r\n    getNamespaces(): NamespaceDeclaration[];\r\n    /**\r\n     * Gets a namespace.\r\n     * @param name - Name of the namespace.\r\n     */\r\n    getNamespace(name: string): NamespaceDeclaration | undefined;\r\n    /**\r\n     * Gets a namespace.\r\n     * @param findFunction - Function to use to find the namespace.\r\n     */\r\n    getNamespace(findFunction: (declaration: NamespaceDeclaration) => boolean): NamespaceDeclaration | undefined;\r\n    /**\r\n     * Gets a namespace or throws if it doesn't exist.\r\n     * @param name - Name of the namespace.\r\n     */\r\n    getNamespaceOrThrow(name: string): NamespaceDeclaration;\r\n    /**\r\n     * Gets a namespace or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the namespace.\r\n     */\r\n    getNamespaceOrThrow(findFunction: (declaration: NamespaceDeclaration) => boolean): NamespaceDeclaration;\r\n    /**\r\n     * Adds a type alias declaration as a child.\r\n     * @param structure - Structure of the type alias declaration to add.\r\n     */\r\n    addTypeAlias(structure: TypeAliasDeclarationStructure): TypeAliasDeclaration;\r\n    /**\r\n     * Adds type alias declarations as a child.\r\n     * @param structures - Structures of the type alias declarations to add.\r\n     */\r\n    addTypeAliases(structures: ReadonlyArray<TypeAliasDeclarationStructure>): TypeAliasDeclaration[];\r\n    /**\r\n     * Inserts an type alias declaration as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the type alias declaration to insert.\r\n     */\r\n    insertTypeAlias(index: number, structure: TypeAliasDeclarationStructure): TypeAliasDeclaration;\r\n    /**\r\n     * Inserts type alias declarations as a child.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the type alias declarations to insert.\r\n     */\r\n    insertTypeAliases(index: number, structures: ReadonlyArray<TypeAliasDeclarationStructure>): TypeAliasDeclaration[];\r\n    /**\r\n     * Gets the direct type alias declaration children.\r\n     */\r\n    getTypeAliases(): TypeAliasDeclaration[];\r\n    /**\r\n     * Gets a type alias.\r\n     * @param name - Name of the type alias.\r\n     */\r\n    getTypeAlias(name: string): TypeAliasDeclaration | undefined;\r\n    /**\r\n     * Gets a type alias.\r\n     * @param findFunction - Function to use to find the type alias.\r\n     */\r\n    getTypeAlias(findFunction: (declaration: TypeAliasDeclaration) => boolean): TypeAliasDeclaration | undefined;\r\n    /**\r\n     * Gets a type alias or throws if it doesn't exist.\r\n     * @param name - Name of the type alias.\r\n     */\r\n    getTypeAliasOrThrow(name: string): TypeAliasDeclaration;\r\n    /**\r\n     * Gets a type alias or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the type alias.\r\n     */\r\n    getTypeAliasOrThrow(findFunction: (declaration: TypeAliasDeclaration) => boolean): TypeAliasDeclaration;\r\n    /**\r\n     * Adds a variable statement.\r\n     * @param structure - Structure of the variable statement.\r\n     */\r\n    addVariableStatement(structure: VariableStatementStructure): VariableStatement;\r\n    /**\r\n     * Adds variable statements.\r\n     * @param structures - Structures of the variable statements.\r\n     */\r\n    addVariableStatements(structures: ReadonlyArray<VariableStatementStructure>): VariableStatement[];\r\n    /**\r\n     * Inserts a variable statement.\r\n     * @param structure - Structure of the variable statement.\r\n     */\r\n    insertVariableStatement(index: number, structure: VariableStatementStructure): VariableStatement;\r\n    /**\r\n     * Inserts variable statements.\r\n     * @param structures - Structures of the variable statements.\r\n     */\r\n    insertVariableStatements(index: number, structures: ReadonlyArray<VariableStatementStructure>): VariableStatement[];\r\n    /**\r\n     * Gets the direct variable statement children.\r\n     */\r\n    getVariableStatements(): VariableStatement[];\r\n    /**\r\n     * Gets a variable statement.\r\n     * @param name - Name of one of the variable statement's declarations.\r\n     */\r\n    getVariableStatement(name: string): VariableStatement | undefined;\r\n    /**\r\n     * Gets a variable statement.\r\n     * @param findFunction - Function to use to find the variable statement.\r\n     */\r\n    getVariableStatement(findFunction: (declaration: VariableStatement) => boolean): VariableStatement | undefined;\r\n    /**\r\n     * Gets a variable statement or throws if it doesn't exist.\r\n     * @param name - Name of one of the variable statement's declarations.\r\n     */\r\n    getVariableStatementOrThrow(name: string): VariableStatement;\r\n    /**\r\n     * Gets a variable statement or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the variable statement.\r\n     */\r\n    getVariableStatementOrThrow(findFunction: (declaration: VariableStatement) => boolean): VariableStatement;\r\n    /**\r\n     * Gets all the variable declarations within all the variable declarations of the direct variable statement children.\r\n     */\r\n    getVariableDeclarations(): VariableDeclaration[];\r\n    /**\r\n     * Gets a variable declaration.\r\n     * @param name - Name of the variable declaration.\r\n     */\r\n    getVariableDeclaration(name: string): VariableDeclaration | undefined;\r\n    /**\r\n     * Gets a variable declaration.\r\n     * @param findFunction - Function to use to find the variable declaration.\r\n     */\r\n    getVariableDeclaration(findFunction: (declaration: VariableDeclaration) => boolean): VariableDeclaration | undefined;\r\n    /**\r\n     * Gets a variable declaration or throws if it doesn't exist.\r\n     * @param name - Name of the variable declaration.\r\n     */\r\n    getVariableDeclarationOrThrow(name: string): VariableDeclaration;\r\n    /**\r\n     * Gets a variable declaration or throws if it doesn't exist.\r\n     * @param findFunction - Function to use to find the variable declaration.\r\n     */\r\n    getVariableDeclarationOrThrow(findFunction: (declaration: VariableDeclaration) => boolean): VariableDeclaration;\r\n}\r\n\r\ndeclare type StatementedNodeExtensionType = Node<ts.SourceFile | ts.FunctionDeclaration | ts.ModuleDeclaration | ts.FunctionLikeDeclaration | ts.CaseClause | ts.DefaultClause | ts.ModuleBlock>;\r\n\r\ndeclare const SwitchStatementBase: Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class SwitchStatement extends SwitchStatementBase<ts.SwitchStatement> {\r\n    /**\r\n     * Gets this switch statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n    /**\r\n     * Gets this switch statement's case block.\r\n     */\r\n    getCaseBlock(): CaseBlock;\r\n    /**\r\n     * Gets the switch statement's case block's clauses.\r\n     */\r\n    getClauses(): CaseOrDefaultClause[];\r\n    /**\r\n     * Removes the specified clause based on the provided index.\r\n     * @param index - Index.\r\n     */\r\n    removeClause(index: number): CaseBlock;\r\n    /**\r\n     * Removes the specified clauses based on the provided index range.\r\n     * @param indexRange - Index range.\r\n     */\r\n    removeClauses(indexRange: [number, number]): CaseBlock;\r\n}\r\n\r\ndeclare const ThrowStatementBase: typeof Statement;\r\n\r\nexport declare class ThrowStatement extends ThrowStatementBase<ts.ThrowStatement> {\r\n    /**\r\n     * Gets the throw statement's expression.\r\n     */\r\n    getExpression(): Expression | undefined;\r\n    /**\r\n     * Gets the throw statement's expression or throws undefined if it doesn't exist.\r\n     */\r\n    getExpressionOrThrow(): Expression;\r\n}\r\n\r\ndeclare const TryStatementBase: typeof Statement;\r\n\r\nexport declare class TryStatement extends TryStatementBase<ts.TryStatement> {\r\n    /**\r\n     * Gets this try statement's try block.\r\n     */\r\n    getTryBlock(): Block;\r\n    /**\r\n     * Gets this try statement's catch clause or undefined if none exists.\r\n     */\r\n    getCatchClause(): CatchClause | undefined;\r\n    /**\r\n     * Gets this try statement's catch clause or throws if none exists.\r\n     */\r\n    getCatchClauseOrThrow(): CatchClause;\r\n    /**\r\n     * Gets this try statement's finally block or undefined if none exists.\r\n     */\r\n    getFinallyBlock(): Block | undefined;\r\n    /**\r\n     * Gets this try statement's finally block or throws if none exists.\r\n     */\r\n    getFinallyBlockOrThrow(): Block;\r\n}\r\n\r\ndeclare const VariableStatementBase: Constructor<ChildOrderableNode> & Constructor<NamespaceChildableNode> & Constructor<JSDocableNode> & Constructor<AmbientableNode> & Constructor<ExportableNode> & Constructor<ModifierableNode> & typeof Statement;\r\n\r\nexport declare class VariableStatement extends VariableStatementBase<ts.VariableStatement> {\r\n    /**\r\n     * Get variable declaration list.\r\n     */\r\n    getDeclarationList(): VariableDeclarationList;\r\n    /**\r\n     * Get the variable declarations.\r\n     */\r\n    getDeclarations(): VariableDeclaration[];\r\n    /**\r\n     * Gets the variable declaration kind.\r\n     */\r\n    getDeclarationKind(): VariableDeclarationKind;\r\n    /**\r\n     * Gets the variable declaration kind keyword.\r\n     */\r\n    getDeclarationKindKeyword(): Node<ts.Node>;\r\n    /**\r\n     * Sets the variable declaration kind.\r\n     * @param type - Type to set.\r\n     */\r\n    setDeclarationKind(type: VariableDeclarationKind): VariableDeclarationList;\r\n    /**\r\n     * Add a variable declaration to the statement.\r\n     * @param structure - Structure representing the variable declaration to add.\r\n     */\r\n    addDeclaration(structure: VariableDeclarationStructure): VariableDeclaration;\r\n    /**\r\n     * Adds variable declarations to the statement.\r\n     * @param structures - Structures representing the variable declarations to add.\r\n     */\r\n    addDeclarations(structures: ReadonlyArray<VariableDeclarationStructure>): VariableDeclaration[];\r\n    /**\r\n     * Inserts a variable declaration at the specified index within the statement.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the variable declaration to insert.\r\n     */\r\n    insertDeclaration(index: number, structure: VariableDeclarationStructure): VariableDeclaration;\r\n    /**\r\n     * Inserts variable declarations at the specified index within the statement.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the variable declarations to insert.\r\n     */\r\n    insertDeclarations(index: number, structures: ReadonlyArray<VariableDeclarationStructure>): VariableDeclaration[];\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<VariableStatementStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): VariableStatementStructure;\r\n}\r\n\r\ndeclare const WhileStatementBase: typeof IterationStatement;\r\n\r\nexport declare class WhileStatement extends WhileStatementBase<ts.WhileStatement> {\r\n    /**\r\n     * Gets this while statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n}\r\n\r\ndeclare const WithStatementBase: Constructor<ChildOrderableNode> & typeof Statement;\r\n\r\nexport declare class WithStatement extends WithStatementBase<ts.WithStatement> {\r\n    /**\r\n     * Gets this with statement's expression.\r\n     */\r\n    getExpression(): Expression;\r\n    /**\r\n     * Gets this with statement's statement.\r\n     */\r\n    getStatement(): Statement;\r\n}\r\n\r\nexport declare class ArrayTypeNode extends TypeNode<ts.ArrayTypeNode> {\r\n    /**\r\n     * Gets the array type node's element type node.\r\n     */\r\n    getElementTypeNode(): TypeNode;\r\n}\r\n\r\nexport declare class ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase<ts.ConstructorTypeNode> {\r\n}\r\n\r\ndeclare const ExpressionWithTypeArgumentsBase: Constructor<LeftHandSideExpressionedNode> & typeof TypeNode;\r\n\r\nexport declare class ExpressionWithTypeArguments extends ExpressionWithTypeArgumentsBase<ts.ExpressionWithTypeArguments> {\r\n    /**\r\n     * Gets the type arguments.\r\n     */\r\n    getTypeArguments(): TypeNode[];\r\n}\r\n\r\ndeclare const FunctionTypeNodeBase: Constructor<TypeParameteredNode> & typeof FunctionOrConstructorTypeNodeBase;\r\n\r\nexport declare class FunctionTypeNode extends FunctionTypeNodeBase<ts.FunctionTypeNode> {\r\n}\r\n\r\ndeclare const FunctionOrConstructorTypeNodeBaseBase: Constructor<SignaturedDeclaration> & typeof TypeNode;\r\n\r\nexport declare class FunctionOrConstructorTypeNodeBase<T extends ts.FunctionOrConstructorTypeNode = ts.FunctionOrConstructorTypeNode> extends FunctionOrConstructorTypeNodeBaseBase<T> {\r\n}\r\n\r\ndeclare const ImportTypeNodeBase: Constructor<TypeArgumentedNode> & typeof TypeNode;\r\n\r\nexport declare class ImportTypeNode extends ImportTypeNodeBase<ts.ImportTypeNode> {\r\n    /**\r\n     * Sets the argument text.\r\n     * @param text - Text of the argument.\r\n     */\r\n    setArgument(text: string): this;\r\n    /**\r\n     * Gets the argument passed into the import type.\r\n     */\r\n    getArgument(): TypeNode;\r\n    /**\r\n     * Sets the qualifier text.\r\n     * @param text - Text.\r\n     */\r\n    setQualifier(text: string): this;\r\n    /**\r\n     * Gets the qualifier of the import type if it exists or throws\r\n     */\r\n    getQualifierOrThrow(): EntityName;\r\n    /**\r\n     * Gets the qualifier of the import type if it exists or returns undefined.\r\n     */\r\n    getQualifier(): EntityName | undefined;\r\n}\r\n\r\nexport declare class IndexedAccessTypeNode extends TypeNode<ts.IndexedAccessTypeNode> {\r\n    /**\r\n     * Gets the indexed access type node's object type node.\r\n     *\r\n     * This is `MyObjectType` in `MyObjectType[\"myIndex\"]`.\r\n     */\r\n    getObjectTypeNode(): TypeNode;\r\n    /**\r\n     * Gets the indexed access type node's index type node.\r\n     *\r\n     * This is `\"myIndex\"` in `MyObjectType[\"myIndex\"]`.\r\n     */\r\n    getIndexTypeNode(): TypeNode;\r\n}\r\n\r\nexport declare class IntersectionTypeNode extends TypeNode<ts.IntersectionTypeNode> {\r\n    /**\r\n     * Gets the intersection type nodes.\r\n     */\r\n    getTypeNodes(): TypeNode[];\r\n}\r\n\r\nexport declare class LiteralTypeNode extends TypeNode<ts.LiteralTypeNode> {\r\n    /**\r\n     * Gets the literal type node's literal.\r\n     */\r\n    getLiteral(): BooleanLiteral | LiteralExpression | PrefixUnaryExpression;\r\n}\r\n\r\nexport declare class ParenthesizedTypeNode extends TypeNode<ts.ParenthesizedTypeNode> {\r\n    /**\r\n     * Gets the node within the parentheses.\r\n     */\r\n    getTypeNode(): TypeNode;\r\n    /**\r\n     * Sets the type within the parentheses.\r\n     * @param textOrWriterFunction - Text or writer function to set the type with.\r\n     */\r\n    setType(textOrWriterFunction: string | WriterFunction): this;\r\n}\r\n\r\nexport declare class TupleTypeNode extends TypeNode<ts.TupleTypeNode> {\r\n    /**\r\n     * Gets the tuple element type nodes.\r\n     */\r\n    getElementTypeNodes(): TypeNode[];\r\n}\r\n\r\ndeclare const TypeAliasDeclarationBase: Constructor<ChildOrderableNode> & Constructor<TypeParameteredNode> & Constructor<TypedNode> & Constructor<JSDocableNode> & Constructor<AmbientableNode> & Constructor<ExportableNode> & Constructor<ModifierableNode> & Constructor<NamedNode> & typeof Statement;\r\n\r\nexport declare class TypeAliasDeclaration extends TypeAliasDeclarationBase<ts.TypeAliasDeclaration> {\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<TypeAliasDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): TypeAliasDeclarationStructure;\r\n}\r\n\r\ndeclare const TypeLiteralNodeBase: Constructor<TypeElementMemberedNode> & typeof TypeNode;\r\n\r\nexport declare class TypeLiteralNode extends TypeLiteralNodeBase<ts.TypeLiteralNode> {\r\n}\r\n\r\nexport declare class TypeNode<T extends ts.TypeNode = ts.TypeNode> extends Node<T> {\r\n}\r\n\r\ndeclare const TypeParameterDeclarationBase: Constructor<NamedNode> & typeof Node;\r\n\r\nexport declare class TypeParameterDeclaration extends TypeParameterDeclarationBase<ts.TypeParameterDeclaration> {\r\n    /**\r\n     * Gets the constraint of the type parameter.\r\n     */\r\n    getConstraint(): TypeNode | undefined;\r\n    /**\r\n     * Gets the constraint of the type parameter or throws if it doesn't exist.\r\n     */\r\n    getConstraintOrThrow(): TypeNode<ts.TypeNode>;\r\n    /**\r\n     * Sets the type parameter constraint.\r\n     * @param text - Text to set as the constraint.\r\n     */\r\n    setConstraint(text: string | WriterFunction): this;\r\n    /**\r\n     * Removes the constraint type node.\r\n     */\r\n    removeConstraint(): this;\r\n    /**\r\n     * Gets the default node of the type parameter.\r\n     */\r\n    getDefault(): TypeNode | undefined;\r\n    /**\r\n     * Gets the default node of the type parameter or throws if it doesn't exist.\r\n     */\r\n    getDefaultOrThrow(): TypeNode<ts.TypeNode>;\r\n    /**\r\n     * Sets the type parameter default type node.\r\n     * @param text - Text to set as the default type node.\r\n     */\r\n    setDefault(text: string | WriterFunction): this;\r\n    /**\r\n     * Removes the default type node.\r\n     */\r\n    removeDefault(): this;\r\n    /**\r\n     * Removes this type parameter.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<TypeParameterDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): TypeParameterDeclarationStructure;\r\n}\r\n\r\nexport declare class TypeReferenceNode extends TypeNode<ts.TypeReferenceNode> {\r\n    /**\r\n     * Gets the type name.\r\n     */\r\n    getTypeName(): EntityName;\r\n    /**\r\n     * Gets the type arguments.\r\n     */\r\n    getTypeArguments(): TypeNode[];\r\n}\r\n\r\nexport declare class UnionTypeNode extends TypeNode<ts.UnionTypeNode> {\r\n    /**\r\n     * Gets the union type nodes.\r\n     */\r\n    getTypeNodes(): TypeNode[];\r\n}\r\n\r\ndeclare const VariableDeclarationBase: Constructor<ExportGetableNode> & Constructor<ExclamationTokenableNode> & Constructor<TypedNode> & Constructor<InitializerExpressionableNode> & Constructor<BindingNamedNode> & typeof Node;\r\n\r\nexport declare class VariableDeclaration extends VariableDeclarationBase<ts.VariableDeclaration> {\r\n    /**\r\n     * Removes this variable declaration.\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Gets the corresponding variable statement if it exists. Throws for variable declarations in for statements.\r\n     */\r\n    getVariableStatementOrThrow(): TryStatement & VariableStatement;\r\n    /**\r\n     * Gets the corresponding variable statement if it exists. Returns undefined for variable declarations in for statements.\r\n     */\r\n    getVariableStatement(): (TryStatement & VariableStatement) | undefined;\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<VariableDeclarationStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): VariableDeclarationStructure;\r\n}\r\nexport declare enum VariableDeclarationKind {\r\n    Var = \"var\",\r\n    Let = \"let\",\r\n    Const = \"const\"\r\n}\r\n\r\ndeclare const VariableDeclarationListBase: Constructor<ModifierableNode> & typeof Node;\r\n\r\nexport declare class VariableDeclarationList extends VariableDeclarationListBase<ts.VariableDeclarationList> {\r\n    /**\r\n     * Get the variable declarations.\r\n     */\r\n    getDeclarations(): VariableDeclaration[];\r\n    /**\r\n     * Gets the variable declaration kind.\r\n     */\r\n    getDeclarationKind(): VariableDeclarationKind;\r\n    /**\r\n     * Gets the variable declaration kind keyword.\r\n     */\r\n    getDeclarationKindKeyword(): Node;\r\n    /**\r\n     * Sets the variable declaration kind.\r\n     * @param type - Type to set.\r\n     */\r\n    setDeclarationKind(type: VariableDeclarationKind): this;\r\n    /**\r\n     * Add a variable declaration to the statement.\r\n     * @param structure - Structure representing the variable declaration to add.\r\n     */\r\n    addDeclaration(structure: VariableDeclarationStructure): VariableDeclaration;\r\n    /**\r\n     * Adds variable declarations to the statement.\r\n     * @param structures - Structures representing the variable declarations to add.\r\n     */\r\n    addDeclarations(structures: ReadonlyArray<VariableDeclarationStructure>): VariableDeclaration[];\r\n    /**\r\n     * Inserts a variable declaration at the specified index within the statement.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the variable declaration to insert.\r\n     */\r\n    insertDeclaration(index: number, structure: VariableDeclarationStructure): VariableDeclaration;\r\n    /**\r\n     * Inserts variable declarations at the specified index within the statement.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the variable declarations to insert.\r\n     */\r\n    insertDeclarations(index: number, structures: ReadonlyArray<VariableDeclarationStructure>): VariableDeclaration[];\r\n    /**\r\n     * Sets the node from a structure.\r\n     * @param structure - Structure to set the node with.\r\n     */\r\n    set(structure: Partial<VariableDeclarationListStructure>): this;\r\n    /**\r\n     * Gets the structure equivalent to this node.\r\n     */\r\n    getStructure(): VariableDeclarationListStructure;\r\n}\r\n\r\nexport declare class Signature {\r\n    private constructor();\r\n    /**\r\n     * Gets the underlying compiler signature.\r\n     */\r\n    readonly compilerSignature: ts.Signature;\r\n    /**\r\n     * Gets the type parameters.\r\n     */\r\n    getTypeParameters(): TypeParameter[];\r\n    /**\r\n     * Gets the parameters.\r\n     */\r\n    getParameters(): Symbol[];\r\n    /**\r\n     * Gets the signature return type.\r\n     */\r\n    getReturnType(): Type;\r\n    /**\r\n     * Get the documentation comments.\r\n     */\r\n    getDocumentationComments(): SymbolDisplayPart[];\r\n    /**\r\n     * Gets the JS doc tags.\r\n     */\r\n    getJsDocTags(): JSDocTagInfo[];\r\n    /**\r\n     * Gets the signature's declaration.\r\n     */\r\n    getDeclaration(): MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | FunctionExpression | ArrowFunction | FunctionDeclaration | JSDocFunctionType;\r\n}\r\n\r\nexport declare class Symbol {\r\n    /**\r\n     * Gets the underlying compiler symbol.\r\n     */\r\n    readonly compilerSymbol: ts.Symbol;\r\n    private constructor();\r\n    /**\r\n     * Gets the symbol name.\r\n     */\r\n    getName(): string;\r\n    /**\r\n     * Gets the escaped name.\r\n     */\r\n    getEscapedName(): string;\r\n    /**\r\n     * Gets the aliased symbol or throws if it doesn't exist.\r\n     */\r\n    getAliasedSymbolOrThrow(): Symbol;\r\n    /**\r\n     * Gets the aliased symbol or returns undefined if it doesn't exist.\r\n     */\r\n    getAliasedSymbol(): Symbol | undefined;\r\n    /**\r\n     * Gets if the symbol is an alias.\r\n     */\r\n    isAlias(): boolean;\r\n    /**\r\n     * Gets the symbol flags.\r\n     */\r\n    getFlags(): SymbolFlags;\r\n    /**\r\n     * Gets if the symbol has the specified flags.\r\n     * @param flags - Flags to check if the symbol has.\r\n     */\r\n    hasFlags(flags: SymbolFlags): boolean;\r\n    /**\r\n     * Gets the value declaration of a symbol or throws if it doesn't exist.\r\n     */\r\n    getValueDeclarationOrThrow(): Node;\r\n    /**\r\n     * Gets the value declaration of the symbol or returns undefined if it doesn't exist.\r\n     */\r\n    getValueDeclaration(): Node | undefined;\r\n    /**\r\n     * Gets the symbol declarations.\r\n     */\r\n    getDeclarations(): Node[];\r\n    /**\r\n     * Gets the export of the symbol by the specified name or throws if not exists.\r\n     * @param name - Name of the export.\r\n     */\r\n    getExportByNameOrThrow(name: string): Symbol;\r\n    /**\r\n     * Gets the export of the symbol by the specified name or returns undefined if not exists.\r\n     * @param name - Name of the export.\r\n     */\r\n    getExportByName(name: string): Symbol | undefined;\r\n    /**\r\n     * Gets the exports from the symbol.\r\n     */\r\n    getExports(): Symbol[];\r\n    /**\r\n     * Gets the global export of the symbol by the specified name or throws if not exists.\r\n     * @param name - Name of the global export.\r\n     */\r\n    getGlobalExportByNameOrThrow(name: string): Symbol;\r\n    /**\r\n     * Gets the global export of the symbol by the specified name or returns undefined if not exists.\r\n     * @param name - Name of the global export.\r\n     */\r\n    getGlobalExportByName(name: string): Symbol | undefined;\r\n    /**\r\n     * Gets the global exports from the symbol.\r\n     */\r\n    getGlobalExports(): Symbol[];\r\n    /**\r\n     * Gets the member of the symbol by the specified name or throws if not exists.\r\n     * @param name - Name of the export.\r\n     */\r\n    getMemberByNameOrThrow(name: string): Symbol;\r\n    /**\r\n     * Gets the member of the symbol by the specified name or returns undefined if not exists.\r\n     * @param name - Name of the member.\r\n     */\r\n    getMemberByName(name: string): Symbol | undefined;\r\n    /**\r\n     * Gets the members of the symbol\r\n     */\r\n    getMembers(): Symbol[];\r\n    /**\r\n     * Gets the declared type of the symbol.\r\n     */\r\n    getDeclaredType(): Type;\r\n    /**\r\n     * Gets the type of the symbol at a location.\r\n     * @param node - Location to get the type at for this symbol.\r\n     */\r\n    getTypeAtLocation(node: Node): Type<ts.Type>;\r\n    /**\r\n     * Gets the fully qualified name.\r\n     */\r\n    getFullyQualifiedName(): string;\r\n}\r\n\r\nexport interface FormatCodeSettings extends ts.FormatCodeSettings {\r\n    ensureNewLineAtEndOfFile?: boolean;\r\n}\r\n/**\r\n * Options for renaming a node.\r\n */\r\nexport interface RenameOptions {\r\n    /**\r\n     * Whether comments referencing this node should be renamed.\r\n     * @remarks False by default.\r\n     */\r\n    renameInComments?: boolean;\r\n    /**\r\n     * Whether strings referencing this node should be renamed.\r\n     * @remarks False by default.\r\n     */\r\n    renameInStrings?: boolean;\r\n}\r\n\r\n/**\r\n * User preferences for refactoring.\r\n */\r\nexport interface UserPreferences extends ts.UserPreferences {\r\n}\r\n\r\nexport declare class LanguageService {\r\n    private readonly _compilerObject;\r\n    private readonly _compilerHost;\r\n    private _program;\r\n    /**\r\n     * Gets the compiler language service.\r\n     */\r\n    readonly compilerObject: ts.LanguageService;\r\n    private constructor();\r\n    /**\r\n     * Gets the language service's program.\r\n     */\r\n    getProgram(): Program;\r\n    /**\r\n     * Rename the specified node.\r\n     * @param node - Node to rename.\r\n     * @param newName - New name for the node.\r\n     * @param options - Options for renaming the node.\r\n     */\r\n    renameNode(node: Node, newName: string, options?: RenameOptions): void;\r\n    /**\r\n     * Rename the provided rename locations.\r\n     * @param renameLocations - Rename locations.\r\n     * @param newName - New name for the node.\r\n     */\r\n    renameLocations(renameLocations: ReadonlyArray<RenameLocation>, newName: string): void;\r\n    /**\r\n     * Gets the definitions for the specified node.\r\n     * @param node - Node.\r\n     */\r\n    getDefinitions(node: Node): DefinitionInfo[];\r\n    /**\r\n     * Gets the definitions at the specified position.\r\n     * @param sourceFile - Source file.\r\n     * @param pos - Position.\r\n     */\r\n    getDefinitionsAtPosition(sourceFile: SourceFile, pos: number): DefinitionInfo[];\r\n    /**\r\n     * Gets the implementations for the specified node.\r\n     * @param node - Node.\r\n     */\r\n    getImplementations(node: Node): ImplementationLocation[];\r\n    /**\r\n     * Gets the implementations at the specified position.\r\n     * @param sourceFile - Source file.\r\n     * @param pos - Position.\r\n     */\r\n    getImplementationsAtPosition(sourceFile: SourceFile, pos: number): ImplementationLocation[];\r\n    /**\r\n     * Finds references based on the specified node.\r\n     * @param node - Node to find references for.\r\n     */\r\n    findReferences(node: Node): ReferencedSymbol[];\r\n    /**\r\n     * Finds the nodes that reference the definition(s) of the specified node.\r\n     * @param node - Node.\r\n     */\r\n    findReferencesAsNodes(node: Node): Node<ts.Node>[];\r\n    /**\r\n     * Finds references based on the specified position.\r\n     * @param sourceFile - Source file.\r\n     * @param pos - Position to find the reference at.\r\n     */\r\n    findReferencesAtPosition(sourceFile: SourceFile, pos: number): ReferencedSymbol[];\r\n    /**\r\n     * Find the rename locations for the specified node.\r\n     * @param node - Node to get the rename locations for.\r\n     * @param options - Options for renaming.\r\n     */\r\n    findRenameLocations(node: Node, options?: RenameOptions): RenameLocation[];\r\n    /**\r\n     * Gets the suggestion diagnostics.\r\n     * @param filePathOrSourceFile - The source file or file path to get suggestions for.\r\n     */\r\n    getSuggestionDiagnostics(filePathOrSourceFile: SourceFile | string): DiagnosticWithLocation[];\r\n    /**\r\n     * Gets the formatting edits for a range.\r\n     * @param filePath - File path.\r\n     * @param range - Position range.\r\n     * @param formatSettings - Format code settings.\r\n     */\r\n    getFormattingEditsForRange(filePath: string, range: [number, number], formatSettings: FormatCodeSettings): TextChange[];\r\n    /**\r\n     * Gets the formatting edits for a document.\r\n     * @param filePath - File path of the source file.\r\n     * @param formatSettings - Format code settings.\r\n     */\r\n    getFormattingEditsForDocument(filePath: string, formatSettings: FormatCodeSettings): TextChange[];\r\n    /**\r\n     * Gets the formatted text for a document.\r\n     * @param filePath - File path of the source file.\r\n     * @param formatSettings - Format code settings.\r\n     */\r\n    getFormattedDocumentText(filePath: string, formatSettings: FormatCodeSettings): string;\r\n    /**\r\n     * Gets the emit output of a source file.\r\n     * @param sourceFile - Source file.\r\n     * @param emitOnlyDtsFiles - Whether to only emit the d.ts files.\r\n     */\r\n    getEmitOutput(sourceFile: SourceFile, emitOnlyDtsFiles?: boolean): EmitOutput;\r\n    /**\r\n     * Gets the emit output of a source file.\r\n     * @param filePath - File path.\r\n     * @param emitOnlyDtsFiles - Whether to only emit the d.ts files.\r\n     */\r\n    getEmitOutput(filePath: string, emitOnlyDtsFiles?: boolean): EmitOutput;\r\n    /**\r\n     * Gets the indentation at the specified position.\r\n     * @param sourceFile - Source file.\r\n     * @param position - Position.\r\n     * @param settings - Editor settings.\r\n     */\r\n    getIdentationAtPosition(sourceFile: SourceFile, position: number, settings?: EditorSettings): number;\r\n    /**\r\n     * Gets the indentation at the specified position.\r\n     * @param filePath - File path.\r\n     * @param position - Position.\r\n     * @param settings - Editor settings.\r\n     */\r\n    getIdentationAtPosition(filePath: string, position: number, settings?: EditorSettings): number;\r\n    /**\r\n     * Gets the file text changes for organizing the imports in a source file.\r\n     *\r\n     * @param sourceFile - Source file.\r\n     * @param formatSettings - Format code settings.\r\n     * @param userPreferences - User preferences for refactoring.\r\n     */\r\n    organizeImports(sourceFile: SourceFile, formatSettings?: FormatCodeSettings, userPreferences?: UserPreferences): FileTextChanges[];\r\n    /**\r\n     * Gets the file text changes for organizing the imports in a source file.\r\n     *\r\n     * @param filePath - File path of the source file.\r\n     * @param formatSettings - Format code settings.\r\n     * @param userPreferences - User preferences for refactoring.\r\n     */\r\n    organizeImports(filePath: string, formatSettings?: FormatCodeSettings, userPreferences?: UserPreferences): FileTextChanges[];\r\n    /**\r\n     * Gets the edit information for applying a refactor at a the provided position in a source file.\r\n     * @param filePathOrSourceFile - File path or source file to get the edits for.\r\n     * @param formatSettings - Fomat code settings.\r\n     * @param positionOrRange - Position in the source file where to apply given refactor.\r\n     * @param refactorName - Refactor name.\r\n     * @param actionName - Refactor action name.\r\n     * @param preferences - User preferences for refactoring.\r\n     */\r\n    getEditsForRefactor(filePathOrSourceFile: string | SourceFile, formatSettings: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences?: UserPreferences): RefactorEditInfo | undefined;\r\n    /**\r\n     * Gets file changes and actions to perform for the provided fixId.\r\n     * @param filePathOrSourceFile - File path or source file to get the combined code fixes for.\r\n     * @param fixId - Identifier for the code fix (ex. \"fixMissingImport\"). These ids are found in the `ts.codefix` namespace in the compiler api source.\r\n     * @param formatSettings - Format code settings.\r\n     * @param preferences - User preferences for refactoring.\r\n     */\r\n    getCombinedCodeFix(filePathOrSourceFile: string | SourceFile, fixId: {}, formatSettings?: FormatCodeSettings, preferences?: UserPreferences): CombinedCodeActions;\r\n    /**\r\n     * Gets the edit information for applying a code fix at the provided text range in a source file.\r\n     * @param filePathOrSourceFile - File path or source file to get the code fixes for.\r\n     * @param start - Start position of the text range to be fixed.\r\n     * @param end - End position of the text range to be fixed.\r\n     * @param errorCodes - One or more error codes associated with the code fixes to retrieve.\r\n     * @param formatOptions - Format code settings.\r\n     * @param preferences - User preferences for refactoring.\r\n     */\r\n    getCodeFixesAtPosition(filePathOrSourceFile: string | SourceFile, start: number, end: number, errorCodes: ReadonlyArray<number>, formatOptions?: FormatCodeSettings, preferences?: UserPreferences): CodeFixAction[];\r\n    private _getFilePathFromFilePathOrSourceFile;\r\n    private _getFilledSettings;\r\n    private _getFilledUserPreferences;\r\n}\r\n\r\n/**\r\n * Options for emitting from a Program.\r\n */\r\nexport interface ProgramEmitOptions extends EmitOptions {\r\n    writeFile?: ts.WriteFileCallback;\r\n}\r\n\r\n/**\r\n * Options for emitting.\r\n */\r\nexport interface EmitOptions extends EmitOptionsBase {\r\n    /**\r\n     * Optional source file to only emit.\r\n     */\r\n    targetSourceFile?: SourceFile;\r\n}\r\n\r\nexport interface EmitOptionsBase {\r\n    /**\r\n     * Whether only .d.ts files should be emitted.\r\n     */\r\n    emitOnlyDtsFiles?: boolean;\r\n    /**\r\n     * Transformers to act on the files when emitting.\r\n     */\r\n    customTransformers?: ts.CustomTransformers;\r\n}\r\n\r\n/**\r\n * Wrapper around Program.\r\n */\r\nexport declare class Program {\r\n    private constructor();\r\n    /**\r\n     * Gets the underlying compiler program.\r\n     */\r\n    readonly compilerObject: ts.Program;\r\n    /**\r\n     * Get the program's type checker.\r\n     */\r\n    getTypeChecker(): TypeChecker;\r\n    /**\r\n     * Emits the TypeScript files to JavaScript files.\r\n     * @param options - Options for emitting.\r\n     */\r\n    emit(options?: ProgramEmitOptions): EmitResult;\r\n    /**\r\n     * Emits the TypeScript files to JavaScript files to memory.\r\n     * @param options - Options for emitting.\r\n     */\r\n    emitToMemory(options?: EmitOptions): MemoryEmitResult;\r\n    /**\r\n     * Gets the syntactic diagnostics.\r\n     * @param sourceFile - Optional source file to filter by.\r\n     */\r\n    getSyntacticDiagnostics(sourceFile?: SourceFile): DiagnosticWithLocation[];\r\n    /**\r\n     * Gets the semantic diagnostics.\r\n     * @param sourceFile - Optional source file to filter by.\r\n     */\r\n    getSemanticDiagnostics(sourceFile?: SourceFile): Diagnostic[];\r\n    /**\r\n     * Gets the declaration diagnostics.\r\n     * @param sourceFile - Optional source file to filter by.\r\n     */\r\n    getDeclarationDiagnostics(sourceFile?: SourceFile): DiagnosticWithLocation[];\r\n    /**\r\n     * Gets the global diagnostics.\r\n     */\r\n    getGlobalDiagnostics(): Diagnostic[];\r\n    /**\r\n     * Gets the emit module resolution kind.\r\n     */\r\n    getEmitModuleResolutionKind(): ModuleResolutionKind;\r\n    /**\r\n     * Gets if the provided source file was discovered while loading an external library.\r\n     * @param sourceFile - Source file.\r\n     */\r\n    isSourceFileFromExternalLibrary(sourceFile: SourceFile): boolean;\r\n}\r\n\r\n/**\r\n * Represents a code action.\r\n */\r\nexport declare class CodeAction<TCompilerObject extends ts.CodeAction = ts.CodeAction> {\r\n    protected constructor();\r\n    /** Gets the compiler object. */\r\n    readonly compilerObject: TCompilerObject;\r\n    /** Description of the code action. */\r\n    getDescription(): string;\r\n    /** Text changes to apply to each file as part of the code action. */\r\n    getChanges(): FileTextChanges[];\r\n}\r\n\r\n/**\r\n * Represents file changes.\r\n *\r\n * Commands are currently not implemented.\r\n */\r\nexport declare class CombinedCodeActions {\r\n    private constructor();\r\n    /** Gets the compiler object. */\r\n    readonly compilerObject: ts.CombinedCodeActions;\r\n    /** Text changes to apply to each file. */\r\n    getChanges(): FileTextChanges[];\r\n}\r\n\r\n/**\r\n * Represents a code fix action.\r\n */\r\nexport declare class CodeFixAction extends CodeAction<ts.CodeFixAction> {\r\n    /**\r\n     * Short name to identify the fix, for use by telemetry.\r\n     */\r\n    getFixName(): string;\r\n    /**\r\n     * If present, one may call 'getCombinedCodeFix' with this fixId.\r\n     * This may be omitted to indicate that the code fix can't be applied in a group.\r\n     */\r\n    getFixId(): {} | undefined;\r\n    /**\r\n     * Gets the description of the code fix when fixing everything.\r\n     */\r\n    getFixAllDescription(): string | undefined;\r\n}\r\n\r\n/**\r\n * Definition info.\r\n */\r\nexport declare class DefinitionInfo<TCompilerObject extends ts.DefinitionInfo = ts.DefinitionInfo> extends DocumentSpan<TCompilerObject> {\r\n    protected constructor();\r\n    /**\r\n     * Gets the kind.\r\n     */\r\n    getKind(): ts.ScriptElementKind;\r\n    /**\r\n     * Gets the name.\r\n     */\r\n    getName(): string;\r\n    /**\r\n     * Gets the container kind.\r\n     */\r\n    getContainerKind(): ts.ScriptElementKind;\r\n    /**\r\n     * Gets the container name.\r\n     */\r\n    getContainerName(): string;\r\n    /**\r\n     * Gets the declaration node.\r\n     */\r\n    getDeclarationNode(): Node | undefined;\r\n}\r\n\r\n/**\r\n * Diagnostic.\r\n */\r\nexport declare class Diagnostic<TCompilerObject extends ts.Diagnostic = ts.Diagnostic> {\r\n    protected constructor();\r\n    /**\r\n     * Gets the underlying compiler diagnostic.\r\n     */\r\n    readonly compilerObject: TCompilerObject;\r\n    /**\r\n     * Gets the source file.\r\n     */\r\n    getSourceFile(): SourceFile | undefined;\r\n    /**\r\n     * Gets the message text.\r\n     */\r\n    getMessageText(): string | DiagnosticMessageChain;\r\n    /**\r\n     * Gets the line number.\r\n     */\r\n    getLineNumber(): number | undefined;\r\n    /**\r\n     * Gets the start.\r\n     */\r\n    getStart(): number | undefined;\r\n    /**\r\n     * Gets the length.\r\n     */\r\n    getLength(): number | undefined;\r\n    /**\r\n     * Gets the diagnostic category.\r\n     */\r\n    getCategory(): DiagnosticCategory;\r\n    /**\r\n     * Gets the code of the diagnostic.\r\n     */\r\n    getCode(): number;\r\n    /**\r\n     * Gets the source.\r\n     */\r\n    getSource(): string | undefined;\r\n}\r\n\r\n/**\r\n * Diagnostic message chain.\r\n */\r\nexport declare class DiagnosticMessageChain {\r\n    private constructor();\r\n    /**\r\n     * Gets the underlying compiler object.\r\n     */\r\n    readonly compilerObject: ts.DiagnosticMessageChain;\r\n    /**\r\n     * Gets the message text.\r\n     */\r\n    getMessageText(): string;\r\n    /**\r\n     * Gets th enext diagnostic message chain in the chain.\r\n     */\r\n    getNext(): DiagnosticMessageChain | undefined;\r\n    /**\r\n     * Gets the code of the diagnostic message chain.\r\n     */\r\n    getCode(): number;\r\n    /**\r\n     * Gets the category of the diagnostic message chain.\r\n     */\r\n    getCategory(): DiagnosticCategory;\r\n}\r\n\r\nexport declare class DiagnosticWithLocation extends Diagnostic<ts.DiagnosticWithLocation> {\r\n    private constructor();\r\n    /**\r\n     * Gets the line number.\r\n     */\r\n    getLineNumber(): number;\r\n    /**\r\n     * Gets the start.\r\n     */\r\n    getStart(): number;\r\n    /**\r\n     * Gets the length\r\n     */\r\n    getLength(): number;\r\n    /**\r\n     * Gets the source file.\r\n     */\r\n    getSourceFile(): SourceFile;\r\n}\r\n\r\n/**\r\n * Document span.\r\n */\r\nexport declare class DocumentSpan<TCompilerObject extends ts.DocumentSpan = ts.DocumentSpan> {\r\n    protected constructor();\r\n    /**\r\n     * Gets the compiler object.\r\n     */\r\n    readonly compilerObject: TCompilerObject;\r\n    /**\r\n     * Gets the source file this reference is in.\r\n     */\r\n    getSourceFile(): SourceFile;\r\n    /**\r\n     * Gets the text span.\r\n     */\r\n    getTextSpan(): TextSpan;\r\n    /**\r\n     * Gets the node at the start of the text span.\r\n     */\r\n    getNode(): Node<ts.Node>;\r\n    /**\r\n     * Gets the original text span if the span represents a location that was remapped.\r\n     */\r\n    getOriginalTextSpan(): TextSpan | undefined;\r\n    /**\r\n     * Gets the original file name if the span represents a location that was remapped.\r\n     */\r\n    getOriginalFileName(): string | undefined;\r\n}\r\n\r\n/**\r\n * Output of an emit on a single file.\r\n */\r\nexport declare class EmitOutput {\r\n    private readonly _filePath;\r\n    private constructor();\r\n    /**\r\n     * TypeScript compiler emit result.\r\n     */\r\n    readonly compilerObject: ts.EmitOutput;\r\n    /**\r\n     * Gets if the emit was skipped.\r\n     */\r\n    getEmitSkipped(): boolean;\r\n    /**\r\n     * Gets the output files.\r\n     */\r\n    getOutputFiles(): OutputFile[];\r\n}\r\n\r\n/**\r\n * Result of an emit.\r\n */\r\nexport declare class EmitResult {\r\n    protected constructor();\r\n    /**\r\n     * TypeScript compiler emit result.\r\n     */\r\n    readonly compilerObject: ts.EmitResult;\r\n    /**\r\n     * If the emit was skipped.\r\n     */\r\n    getEmitSkipped(): boolean;\r\n    /**\r\n     * Contains declaration emit diagnostics.\r\n     *\r\n     * If the `noEmitOnError` compiler option is true, this will also include the program's semantic, syntactic, global, options, and if enabled declaration diagnostics.\r\n     * @remarks If you are looking for non-declaration emit diagnostics, then call `Project#getPreEmitDiagnostics()` or get specific diagnostics available from the program.\r\n     */\r\n    getDiagnostics(): Diagnostic<ts.Diagnostic>[];\r\n}\r\n\r\n/**\r\n * The emitted file in memory.\r\n */\r\nexport interface MemoryEmitResultFile {\r\n    /**\r\n     * File path that was emitted to.\r\n     */\r\n    filePath: string;\r\n    /**\r\n     * The text that was emitted.\r\n     */\r\n    text: string;\r\n    /**\r\n     * Whether the byte order mark should be written.\r\n     */\r\n    writeByteOrderMark: boolean;\r\n}\r\n\r\n/**\r\n * Result of an emit to memory.\r\n */\r\nexport declare class MemoryEmitResult extends EmitResult {\r\n    private readonly _files;\r\n    private constructor();\r\n    /**\r\n     * Gets the files that were emitted to memory.\r\n     */\r\n    getFiles(): MemoryEmitResultFile[];\r\n}\r\n\r\nexport declare class FileTextChanges {\r\n    private constructor();\r\n    /**\r\n     * Gets the file path.\r\n     */\r\n    getFilePath(): string;\r\n    /**\r\n     * Gets the source file if it was in the cache at the time of this class' creation.\r\n     */\r\n    getSourceFile(): SourceFile | undefined;\r\n    /**\r\n     * Gets the text changes\r\n     */\r\n    getTextChanges(): TextChange[];\r\n    /**\r\n     * Gets if this change is for creating a new file.\r\n     */\r\n    isNewFile(): boolean;\r\n}\r\n\r\nexport declare class ImplementationLocation extends DocumentSpan<ts.ImplementationLocation> {\r\n    private constructor();\r\n    /**\r\n     * Gets the kind.\r\n     */\r\n    getKind(): ts.ScriptElementKind;\r\n    /**\r\n     * Gets the display parts.\r\n     */\r\n    getDisplayParts(): SymbolDisplayPart[];\r\n}\r\n\r\n/**\r\n * Output file of an emit.\r\n */\r\nexport declare class OutputFile {\r\n    private constructor();\r\n    /**\r\n     * TypeScript compiler output file.\r\n     */\r\n    readonly compilerObject: ts.OutputFile;\r\n    /**\r\n     * Gets the file path.\r\n     */\r\n    getFilePath(): string;\r\n    /**\r\n     * Gets whether the byte order mark should be written.\r\n     */\r\n    getWriteByteOrderMark(): boolean;\r\n    /**\r\n     * Gets the file text.\r\n     */\r\n    getText(): string;\r\n}\r\n\r\n/**\r\n * Set of edits to make in response to a refactor action, plus an optional location where renaming should be invoked from.\r\n */\r\nexport declare class RefactorEditInfo {\r\n    private constructor();\r\n    /** Gets the compiler refactor edit info. */\r\n    readonly compilerObject: ts.RefactorEditInfo;\r\n    /**\r\n     * Gets refactor file text changes\r\n     */\r\n    getEdits(): FileTextChanges[];\r\n    /**\r\n     * Gets the file path for a rename refactor.\r\n     */\r\n    getRenameFilePath(): string | undefined;\r\n    /**\r\n     * Location where renaming should be invoked from.\r\n     */\r\n    getRenameLocation(): number | undefined;\r\n}\r\n\r\n/**\r\n * Referenced symbol.\r\n */\r\nexport declare class ReferencedSymbol {\r\n    private constructor();\r\n    /**\r\n     * Gets the compiler referenced symbol.\r\n     */\r\n    readonly compilerObject: ts.ReferencedSymbol;\r\n    /**\r\n     * Gets the definition.\r\n     */\r\n    getDefinition(): ReferencedSymbolDefinitionInfo;\r\n    /**\r\n     * Gets the references.\r\n     */\r\n    getReferences(): ReferenceEntry[];\r\n}\r\n\r\nexport declare class ReferencedSymbolDefinitionInfo extends DefinitionInfo<ts.ReferencedSymbolDefinitionInfo> {\r\n    private constructor();\r\n    /**\r\n     * Gets the display parts.\r\n     */\r\n    getDisplayParts(): SymbolDisplayPart[];\r\n}\r\n\r\nexport declare class ReferenceEntry extends DocumentSpan<ts.ReferenceEntry> {\r\n    private constructor();\r\n    isWriteAccess(): boolean;\r\n    /**\r\n     * If this is the definition reference.\r\n     */\r\n    isDefinition(): boolean;\r\n    isInString(): true | undefined;\r\n}\r\n\r\n/**\r\n * Rename location.\r\n */\r\nexport declare class RenameLocation extends DocumentSpan<ts.RenameLocation> {\r\n}\r\n\r\n/**\r\n * Symbol display part.\r\n */\r\nexport declare class SymbolDisplayPart {\r\n    private constructor();\r\n    /** Gets the compiler symbol display part. */\r\n    readonly compilerObject: ts.SymbolDisplayPart;\r\n    /**\r\n     * Gets the text.\r\n     */\r\n    getText(): string;\r\n    /**\r\n     * Gets the kind.\r\n     *\r\n     * Examples: \"text\", \"lineBreak\"\r\n     */\r\n    getKind(): string;\r\n}\r\n\r\n/**\r\n * Represents a text change.\r\n */\r\nexport declare class TextChange {\r\n    private constructor();\r\n    /** Gets the compiler text change. */\r\n    readonly compilerObject: ts.TextChange;\r\n    /**\r\n     * Gets the text span.\r\n     */\r\n    getSpan(): TextSpan;\r\n    /**\r\n     * Gets the new text.\r\n     */\r\n    getNewText(): string;\r\n}\r\n\r\n/**\r\n * Represents a span of text.\r\n */\r\nexport declare class TextSpan {\r\n    private constructor();\r\n    /** Gets the compiler text span. */\r\n    readonly compilerObject: ts.TextSpan;\r\n    /**\r\n     * Gets the start.\r\n     */\r\n    getStart(): number;\r\n    /**\r\n     * Gets the start + length.\r\n     */\r\n    getEnd(): number;\r\n    /**\r\n     * Gets the length.\r\n     */\r\n    getLength(): number;\r\n}\r\n\r\n/**\r\n * Wrapper around the TypeChecker.\r\n */\r\nexport declare class TypeChecker {\r\n    private constructor();\r\n    /**\r\n     * Gets the compiler's TypeChecker.\r\n     */\r\n    readonly compilerObject: ts.TypeChecker;\r\n    /**\r\n     * Gets the ambient module symbols (ex. modules in the @types folder or node_modules).\r\n     */\r\n    getAmbientModules(): Symbol[];\r\n    /**\r\n     * Gets the apparent type of a type.\r\n     * @param type - Type to get the apparent type of.\r\n     */\r\n    getApparentType(type: Type): Type<ts.Type>;\r\n    /**\r\n     * Gets the constant value of a declaration.\r\n     * @param node - Node to get the constant value from.\r\n     */\r\n    getConstantValue(node: EnumMember): string | number | undefined;\r\n    /**\r\n     * Gets the fully qualified name of a symbol.\r\n     * @param symbol - Symbol to get the fully qualified name of.\r\n     */\r\n    getFullyQualifiedName(symbol: Symbol): string;\r\n    /**\r\n     * Gets the type at the specified location.\r\n     * @param node - Node to get the type for.\r\n     */\r\n    getTypeAtLocation(node: Node): Type;\r\n    /**\r\n     * Gets the contextual type of an expression.\r\n     * @param expression - Expression.\r\n     */\r\n    getContextualType(expression: Expression): Type | undefined;\r\n    /**\r\n     * Gets the type of a symbol at the specified location.\r\n     * @param symbol - Symbol to get the type for.\r\n     * @param node - Location to get the type for.\r\n     */\r\n    getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;\r\n    /**\r\n     * Gets the declared type of a symbol.\r\n     * @param symbol - Symbol to get the type for.\r\n     */\r\n    getDeclaredTypeOfSymbol(symbol: Symbol): Type;\r\n    /**\r\n     * Gets the symbol at the specified location or undefined if none exists.\r\n     * @param node - Node to get the symbol for.\r\n     */\r\n    getSymbolAtLocation(node: Node): Symbol | undefined;\r\n    /**\r\n     * Gets the aliased symbol of a symbol.\r\n     * @param symbol - Symbol to get the alias symbol of.\r\n     */\r\n    getAliasedSymbol(symbol: Symbol): Symbol | undefined;\r\n    /**\r\n     * Gets the properties of a type.\r\n     * @param type - Type.\r\n     */\r\n    getPropertiesOfType(type: Type): Symbol[];\r\n    /**\r\n     * Gets the type text\r\n     * @param type - Type to get the text of.\r\n     * @param enclosingNode - Enclosing node.\r\n     * @param typeFormatFlags - Type format flags.\r\n     */\r\n    getTypeText(type: Type, enclosingNode?: Node, typeFormatFlags?: TypeFormatFlags): string;\r\n    /**\r\n     * Gets the return type of a signature.\r\n     * @param signature - Signature to get the return type of.\r\n     */\r\n    getReturnTypeOfSignature(signature: Signature): Type;\r\n    /**\r\n     * Gets a signature from a node.\r\n     * @param node - Node to get the signature from.\r\n     */\r\n    getSignatureFromNode(node: Node<ts.SignatureDeclaration>): Signature | undefined;\r\n    /**\r\n     * Gets the exports of a module.\r\n     * @param moduleSymbol - Module symbol.\r\n     */\r\n    getExportsOfModule(moduleSymbol: Symbol): Symbol[];\r\n    /**\r\n     * Gets the local target symbol of the provided export specifier.\r\n     * @param exportSpecifier - Export specifier.\r\n     */\r\n    getExportSpecifierLocalTargetSymbol(exportSpecifier: ExportSpecifier): Symbol | undefined;\r\n    /**\r\n     * Gets the resolved signature from a node or returns undefined if the signature can't be resolved.\r\n     * @param node - Node to get the signature from.\r\n     */\r\n    getResolvedSignature(node: CallLikeExpression): Signature | undefined;\r\n    /**\r\n     * Gets the resolved signature from a node or throws if the signature cannot be resolved.\r\n     * @param node - Node to get the signature from.\r\n     */\r\n    getResolvedSignatureOrThrow(node: CallLikeExpression): Signature;\r\n    /**\r\n     * Gets the base type of a literal type.\r\n     *\r\n     * For example, for a number literal type it will return the number type.\r\n     * @param type - Literal type to get the base type of.\r\n     */\r\n    getBaseTypeOfLiteralType(type: Type): Type<ts.Type>;\r\n    private _getDefaultTypeFormatFlags;\r\n}\r\n\r\nexport declare class Type<TType extends ts.Type = ts.Type> {\r\n    /**\r\n     * Gets the underlying compiler type.\r\n     */\r\n    readonly compilerType: TType;\r\n    protected constructor();\r\n    /**\r\n     * Gets the type text.\r\n     * @param enclosingNode - The enclosing node.\r\n     * @param typeFormatFlags - Format flags for the type text.\r\n     */\r\n    getText(enclosingNode?: Node, typeFormatFlags?: TypeFormatFlags): string;\r\n    /**\r\n     * Gets the alias symbol if it exists.\r\n     */\r\n    getAliasSymbol(): Symbol | undefined;\r\n    /**\r\n     * Gets the alias symbol if it exists, or throws.\r\n     */\r\n    getAliasSymbolOrThrow(): Symbol;\r\n    /**\r\n     * Gets the alias type arguments.\r\n     */\r\n    getAliasTypeArguments(): Type[];\r\n    /**\r\n     * Gets the apparent type.\r\n     */\r\n    getApparentType(): Type;\r\n    /**\r\n     * Gets the array type\r\n     */\r\n    getArrayType(): Type<ts.Type> | undefined;\r\n    /**\r\n     * Gets the base types.\r\n     */\r\n    getBaseTypes(): Type<ts.BaseType>[];\r\n    /**\r\n     * Gets the base type of a literal type.\r\n     *\r\n     * For example, for a number literal type it will return the number type.\r\n     */\r\n    getBaseTypeOfLiteralType(): Type<ts.Type>;\r\n    /**\r\n     * Gets the call signatures.\r\n     */\r\n    getCallSignatures(): Signature[];\r\n    /**\r\n     * Gets the construct signatures.\r\n     */\r\n    getConstructSignatures(): Signature[];\r\n    /**\r\n     * Gets the constraint or throws if it doesn't exist.\r\n     */\r\n    getConstraintOrThrow(): Type<ts.Type>;\r\n    /**\r\n     * Gets the constraint or returns undefined if it doesn't exist.\r\n     */\r\n    getConstraint(): Type<ts.Type> | undefined;\r\n    /**\r\n     * Gets the default type or throws if it doesn't exist.\r\n     */\r\n    getDefaultOrThrow(): Type<ts.Type>;\r\n    /**\r\n     * Gets the default type or returns undefined if it doesn't exist.\r\n     */\r\n    getDefault(): Type<ts.Type> | undefined;\r\n    /**\r\n     * Gets the properties of the type.\r\n     */\r\n    getProperties(): Symbol[];\r\n    /**\r\n     * Gets a property.\r\n     * @param name - By a name.\r\n     * @param findFunction - Function for searching for a property.\r\n     */\r\n    getProperty(name: string): Symbol | undefined;\r\n    getProperty(findFunction: (declaration: Symbol) => boolean): Symbol | undefined;\r\n    /**\r\n     * Gets the apparent properties of the type.\r\n     */\r\n    getApparentProperties(): Symbol[];\r\n    /**\r\n     * Gets an apparent property.\r\n     * @param name - By a name.\r\n     * @param findFunction - Function for searching for an apparent property.\r\n     */\r\n    getApparentProperty(name: string): Symbol | undefined;\r\n    getApparentProperty(findFunction: (declaration: Symbol) => boolean): Symbol | undefined;\r\n    /**\r\n     * Gets if the type is possibly null or undefined.\r\n     */\r\n    isNullable(): boolean;\r\n    /**\r\n     * Gets the non-nullable type.\r\n     */\r\n    getNonNullableType(): Type;\r\n    /**\r\n     * Gets the number index type.\r\n     */\r\n    getNumberIndexType(): Type | undefined;\r\n    /**\r\n     * Gets the string index type.\r\n     */\r\n    getStringIndexType(): Type | undefined;\r\n    /**\r\n     * Gets the target type of a type reference if it exists.\r\n     */\r\n    getTargetType(): Type<ts.GenericType> | undefined;\r\n    /**\r\n     * Gets the target type of a type reference or throws if it doesn't exist.\r\n     */\r\n    getTargetTypeOrThrow(): Type<ts.GenericType>;\r\n    /**\r\n     * Gets type arguments.\r\n     */\r\n    getTypeArguments(): Type[];\r\n    /**\r\n     * Gets the individual element types of the tuple.\r\n     */\r\n    getTupleElements(): Type[];\r\n    /**\r\n     * Gets the union types.\r\n     */\r\n    getUnionTypes(): Type[];\r\n    /**\r\n     * Gets the intersection types.\r\n     */\r\n    getIntersectionTypes(): Type[];\r\n    /**\r\n     * Gets the symbol of the type.\r\n     */\r\n    getSymbol(): Symbol | undefined;\r\n    /**\r\n     * Gets the symbol of the type or throws.\r\n     */\r\n    getSymbolOrThrow(): Symbol;\r\n    /**\r\n     * Gets if this is an anonymous type.\r\n     */\r\n    isAnonymous(): boolean;\r\n    /**\r\n     * Gets if this is an any type.\r\n     */\r\n    isAny(): boolean;\r\n    /**\r\n     * Gets if this is an array type.\r\n     */\r\n    isArray(): boolean;\r\n    /**\r\n     * Gets if this is a boolean type.\r\n     */\r\n    isBoolean(): boolean;\r\n    /**\r\n     * Gets if this is a string type.\r\n     */\r\n    isString(): boolean;\r\n    /**\r\n     * Gets if this is a number type.\r\n     */\r\n    isNumber(): boolean;\r\n    /**\r\n     * Gets if this is a literal type.\r\n     */\r\n    isLiteral(): boolean;\r\n    /**\r\n     * Gets if this is a boolean literal type.\r\n     */\r\n    isBooleanLiteral(): boolean;\r\n    /**\r\n     * Gets if this is an enum literal type.\r\n     */\r\n    isEnumLiteral(): boolean;\r\n    /**\r\n     * Gets if this is a number literal type.\r\n     */\r\n    isNumberLiteral(): boolean;\r\n    /**\r\n     * Gets if this is a string literal type.\r\n     */\r\n    isStringLiteral(): boolean;\r\n    /**\r\n     * Gets if this is a class type.\r\n     */\r\n    isClass(): boolean;\r\n    /**\r\n     * Gets if this is a class or interface type.\r\n     */\r\n    isClassOrInterface(): boolean;\r\n    /**\r\n     * Gets if this is an enum type.\r\n     */\r\n    isEnum(): boolean;\r\n    /**\r\n     * Gets if this is an interface type.\r\n     */\r\n    isInterface(): boolean;\r\n    /**\r\n     * Gets if this is an object type.\r\n     */\r\n    isObject(): boolean;\r\n    /**\r\n     * Gets if this is a type parameter.\r\n     */\r\n    isTypeParameter(): this is TypeParameter;\r\n    /**\r\n     * Gets if this is a tuple type.\r\n     */\r\n    isTuple(): boolean;\r\n    /**\r\n     * Gets if this is a union type.\r\n     */\r\n    isUnion(): boolean;\r\n    /**\r\n     * Gets if this is an intersection type.\r\n     */\r\n    isIntersection(): boolean;\r\n    /**\r\n     * Gets if this is a union or intersection type.\r\n     */\r\n    isUnionOrIntersection(): boolean;\r\n    /**\r\n     * Gets if this is the unknown type.\r\n     */\r\n    isUnknown(): boolean;\r\n    /**\r\n     * Gets if this is the null type.\r\n     */\r\n    isNull(): boolean;\r\n    /**\r\n     * Gets if this is the undefined type.\r\n     */\r\n    isUndefined(): boolean;\r\n    /**\r\n     * Gets the type flags.\r\n     */\r\n    getFlags(): TypeFlags;\r\n    /**\r\n     * Gets the object flags.\r\n     * @remarks Returns 0 for a non-object type.\r\n     */\r\n    getObjectFlags(): ObjectFlags | 0;\r\n    private _hasTypeFlag;\r\n    private _hasAnyTypeFlag;\r\n    private _hasObjectFlag;\r\n}\r\n\r\nexport declare class TypeParameter extends Type<ts.TypeParameter> {\r\n    /**\r\n     * Gets the constraint or throws if it doesn't exist.\r\n     */\r\n    getConstraintOrThrow(): Type;\r\n    /**\r\n     * Gets the constraint type.\r\n     */\r\n    getConstraint(): Type | undefined;\r\n    /**\r\n     * Gets the default type or throws if it doesn't exist.\r\n     */\r\n    getDefaultOrThrow(): Type;\r\n    /**\r\n     * Gets the default type or undefined if it doesn't exist.\r\n     */\r\n    getDefault(): Type | undefined;\r\n}\r\n\r\nexport declare class ArgumentError extends BaseError {\r\n    protected constructor();\r\n}\r\n\r\nexport declare class ArgumentNullOrWhitespaceError extends ArgumentError {\r\n    private constructor();\r\n}\r\n\r\nexport declare class ArgumentOutOfRangeError extends ArgumentError {\r\n    private constructor();\r\n}\r\n\r\nexport declare class ArgumentTypeError extends ArgumentError {\r\n    private constructor();\r\n}\r\nexport declare abstract class BaseError extends Error {\r\n    readonly message: string;\r\n    protected constructor();\r\n}\r\n\r\nexport declare class DirectoryNotFoundError extends PathNotFoundError {\r\n    private constructor();\r\n}\r\n\r\nexport declare class FileNotFoundError extends PathNotFoundError {\r\n    private constructor();\r\n}\r\n\r\nexport declare class InvalidOperationError extends BaseError {\r\n    private constructor();\r\n}\r\n\r\nexport declare class NotImplementedError extends BaseError {\r\n    private constructor();\r\n}\r\n\r\nexport declare class NotSupportedError extends BaseError {\r\n    private constructor();\r\n}\r\n\r\nexport declare class PathNotFoundError extends BaseError {\r\n    readonly path: string;\r\n    protected constructor();\r\n    readonly code: \"ENOENT\";\r\n}\r\n\r\n/**\r\n * Holds the compiler options.\r\n */\r\nexport declare class CompilerOptionsContainer extends SettingsContainer<CompilerOptions> {\r\n    constructor();\r\n    /**\r\n     * Sets one or all of the compiler options.\r\n     *\r\n     * WARNING: Setting the compiler options will cause a complete reparse of all the source files.\r\n     * @param settings - Compiler options to set.\r\n     */\r\n    set(settings: Partial<CompilerOptions>): void;\r\n}\r\n\r\n/** Kinds of indentation */\r\nexport declare enum IndentationText {\r\n    /** Two spaces */\r\n    TwoSpaces = \"  \",\r\n    /** Four spaces */\r\n    FourSpaces = \"    \",\r\n    /** Eight spaces */\r\n    EightSpaces = \"        \",\r\n    /** Tab */\r\n    Tab = \"\\t\"\r\n}\r\n\r\n/**\r\n * Manipulation settings.\r\n */\r\nexport interface ManipulationSettings extends SupportedFormatCodeSettingsOnly {\r\n    /** Indentation text */\r\n    indentationText: IndentationText;\r\n    /** New line kind */\r\n    newLineKind: NewLineKind;\r\n    /** Quote type used for string literals. */\r\n    quoteKind: QuoteKind;\r\n}\r\n\r\n/**\r\n * FormatCodeSettings that are currently supported in the library.\r\n */\r\nexport interface SupportedFormatCodeSettings extends SupportedFormatCodeSettingsOnly, EditorSettings {\r\n}\r\n\r\n/**\r\n * FormatCodeSettings that are currently supported in the library.\r\n */\r\nexport interface SupportedFormatCodeSettingsOnly {\r\n    /**\r\n     * Whether to insert a space after opening and before closing non-empty braces.\r\n     *\r\n     * ex. `import { Item } from \"./Item\";` or `import {Item} from \"./Item\";`\r\n     */\r\n    insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: boolean;\r\n}\r\n\r\n/**\r\n * Holds the manipulation settings.\r\n */\r\nexport declare class ManipulationSettingsContainer extends SettingsContainer<ManipulationSettings> {\r\n    private _editorSettings;\r\n    private _formatCodeSettings;\r\n    private _userPreferences;\r\n    constructor();\r\n    /**\r\n     * Gets the editor settings based on the current manipulation settings.\r\n     */\r\n    getEditorSettings(): Readonly<EditorSettings>;\r\n    /**\r\n     * Gets the format code settings.\r\n     */\r\n    getFormatCodeSettings(): Readonly<SupportedFormatCodeSettings>;\r\n    /**\r\n     * Gets the user preferences.\r\n     */\r\n    getUserPreferences(): Readonly<UserPreferences>;\r\n    /**\r\n     * Gets the quote kind used for string literals.\r\n     */\r\n    getQuoteKind(): QuoteKind;\r\n    /**\r\n     * Gets the new line kind.\r\n     */\r\n    getNewLineKind(): NewLineKind;\r\n    /**\r\n     * Gets the new line kind as a string.\r\n     */\r\n    getNewLineKindAsString(): \"\\n\" | \"\\r\\n\";\r\n    /**\r\n     * Gets the indentation text;\r\n     */\r\n    getIndentationText(): IndentationText;\r\n    /**\r\n     * Sets one or all of the settings.\r\n     * @param settings - Settings to set.\r\n     */\r\n    set(settings: Partial<ManipulationSettings>): void;\r\n}\r\nexport declare abstract class SettingsContainer<T extends object> {\r\n    protected constructor();\r\n    /**\r\n     * Resets the settings to the default.\r\n     */\r\n    reset(): void;\r\n    /**\r\n     * Gets a copy of the settings as an object.\r\n     */\r\n    get(): T;\r\n    /**\r\n     * Sets one or all of the settings.\r\n     * @param settings - Settings to set.\r\n     */\r\n    set(settings: Partial<T>): void;\r\n}\r\nexport interface AbstractableNodeStructure {\r\n    isAbstract?: boolean;\r\n}\r\nexport interface AmbientableNodeStructure {\r\n    hasDeclareKeyword?: boolean;\r\n}\r\nexport interface AsyncableNodeStructure {\r\n    isAsync?: boolean;\r\n}\r\nexport interface AwaitableNodeStructure {\r\n    isAwaited?: boolean;\r\n}\r\n\r\nexport interface BodiedNodeStructure {\r\n    bodyText?: string | WriterFunction;\r\n}\r\n\r\nexport interface BodyableNodeStructure {\r\n    bodyText?: string | WriterFunction;\r\n}\r\n\r\nexport interface DecoratableNodeStructure {\r\n    decorators?: DecoratorStructure[];\r\n}\r\nexport interface ExclamationTokenableNodeStructure {\r\n    hasExclamationToken?: boolean;\r\n}\r\nexport interface ExportableNodeStructure {\r\n    isExported?: boolean;\r\n    isDefaultExport?: boolean;\r\n}\r\n\r\nexport interface ExtendsClauseableNodeStructure {\r\n    extends?: (string | WriterFunction)[] | WriterFunction;\r\n}\r\nexport interface GeneratorableNodeStructure {\r\n    isGenerator?: boolean;\r\n}\r\n\r\nexport interface ImplementsClauseableNodeStructure {\r\n    implements?: (string | WriterFunction)[] | WriterFunction;\r\n}\r\n\r\nexport interface InitializerExpressionableNodeStructure extends InitializerSetExpressionableNodeStructure {\r\n}\r\n\r\nexport interface InitializerSetExpressionableNodeStructure {\r\n    initializer?: string | WriterFunction;\r\n}\r\n\r\nexport interface JSDocableNodeStructure {\r\n    docs?: (JSDocStructure | string)[];\r\n}\r\n\r\nexport interface ModuledNodeStructure {\r\n    imports?: ImportDeclarationStructure[];\r\n    exports?: ExportDeclarationStructure[];\r\n}\r\nexport interface BindingNamedNodeStructure {\r\n    name: string;\r\n}\r\nexport interface DeclarationNamedNodeStructure {\r\n    name?: string;\r\n}\r\nexport interface NameableNodeStructure {\r\n    name?: string;\r\n}\r\nexport interface NamedNodeStructure {\r\n    name: string;\r\n}\r\nexport interface PropertyNameableNodeStructure {\r\n    name?: string;\r\n}\r\nexport interface PropertyNamedNodeStructure {\r\n    name: string;\r\n}\r\n\r\nexport interface ParameteredNodeStructure {\r\n    parameters?: ParameterDeclarationStructure[];\r\n}\r\nexport interface QuestionTokenableNodeStructure {\r\n    hasQuestionToken?: boolean;\r\n}\r\nexport interface ReadonlyableNodeStructure {\r\n    isReadonly?: boolean;\r\n}\r\n\r\nexport interface ReturnTypedNodeStructure {\r\n    returnType?: string | WriterFunction;\r\n}\r\n\r\nexport interface ScopeableNodeStructure {\r\n    scope?: Scope;\r\n}\r\n\r\nexport interface ScopedNodeStructure {\r\n    scope?: Scope;\r\n}\r\n\r\nexport interface SignaturedDeclarationStructure extends ParameteredNodeStructure, ReturnTypedNodeStructure {\r\n}\r\nexport interface StaticableNodeStructure {\r\n    isStatic?: boolean;\r\n}\r\n\r\nexport interface TypedNodeStructure {\r\n    type?: string | WriterFunction;\r\n}\r\n\r\nexport interface TypeElementMemberedNodeStructure {\r\n    callSignatures?: CallSignatureDeclarationStructure[];\r\n    constructSignatures?: ConstructSignatureDeclarationStructure[];\r\n    indexSignatures?: IndexSignatureDeclarationStructure[];\r\n    methods?: MethodSignatureStructure[];\r\n    properties?: PropertySignatureStructure[];\r\n}\r\n\r\nexport interface TypeParameteredNodeStructure {\r\n    typeParameters?: (TypeParameterDeclarationStructure | string)[];\r\n}\r\n\r\nexport interface ClassLikeDeclarationBaseStructure extends NameableNodeStructure, ClassLikeDeclarationBaseSpecificStructure, ImplementsClauseableNodeStructure, DecoratableNodeStructure, TypeParameteredNodeStructure, JSDocableNodeStructure, AbstractableNodeStructure {\r\n}\r\n\r\ninterface ClassLikeDeclarationBaseSpecificStructure {\r\n    extends?: string | WriterFunction;\r\n    ctors?: ConstructorDeclarationStructure[];\r\n    properties?: PropertyDeclarationStructure[];\r\n    getAccessors?: GetAccessorDeclarationStructure[];\r\n    setAccessors?: SetAccessorDeclarationStructure[];\r\n    methods?: MethodDeclarationStructure[];\r\n}\r\n\r\nexport interface ClassDeclarationStructure extends ClassLikeDeclarationBaseStructure, ClassDeclarationSpecificStructure, AmbientableNodeStructure, ExportableNodeStructure {\r\n    /**\r\n     * The class name.\r\n     * @remarks Can be undefined. For example: `export default class { ... }`\r\n     */\r\n    name?: string;\r\n}\r\n\r\ninterface ClassDeclarationSpecificStructure {\r\n}\r\n\r\nexport interface ConstructorDeclarationStructure extends ConstructorDeclarationSpecificStructure, ScopedNodeStructure, FunctionLikeDeclarationStructure, BodyableNodeStructure {\r\n}\r\n\r\ninterface ConstructorDeclarationSpecificStructure {\r\n    overloads?: ConstructorDeclarationOverloadStructure[];\r\n}\r\n\r\nexport interface ConstructorDeclarationOverloadStructure extends ScopedNodeStructure, SignaturedDeclarationStructure, TypeParameteredNodeStructure, JSDocableNodeStructure {\r\n}\r\n\r\nexport interface GetAccessorDeclarationStructure extends GetAccessorDeclarationSpecificStructure, PropertyNamedNodeStructure, StaticableNodeStructure, DecoratableNodeStructure, AbstractableNodeStructure, ScopedNodeStructure, FunctionLikeDeclarationStructure, BodyableNodeStructure {\r\n}\r\n\r\ninterface GetAccessorDeclarationSpecificStructure {\r\n}\r\n\r\nexport interface MethodDeclarationStructure extends MethodDeclarationSpecificStructure, PropertyNamedNodeStructure, StaticableNodeStructure, DecoratableNodeStructure, AbstractableNodeStructure, ScopedNodeStructure, AsyncableNodeStructure, GeneratorableNodeStructure, FunctionLikeDeclarationStructure, BodyableNodeStructure, QuestionTokenableNodeStructure {\r\n}\r\n\r\ninterface MethodDeclarationSpecificStructure {\r\n    overloads?: MethodDeclarationOverloadStructure[];\r\n}\r\n\r\nexport interface MethodDeclarationOverloadStructure extends StaticableNodeStructure, AbstractableNodeStructure, ScopedNodeStructure, AsyncableNodeStructure, GeneratorableNodeStructure, SignaturedDeclarationStructure, TypeParameteredNodeStructure, JSDocableNodeStructure, QuestionTokenableNodeStructure {\r\n}\r\n\r\nexport interface PropertyDeclarationStructure extends PropertyDeclarationSpecificStructure, PropertyNamedNodeStructure, TypedNodeStructure, QuestionTokenableNodeStructure, ExclamationTokenableNodeStructure, StaticableNodeStructure, ScopedNodeStructure, JSDocableNodeStructure, ReadonlyableNodeStructure, InitializerExpressionableNodeStructure, DecoratableNodeStructure, AbstractableNodeStructure {\r\n}\r\n\r\ninterface PropertyDeclarationSpecificStructure {\r\n}\r\n\r\nexport interface SetAccessorDeclarationStructure extends SetAccessorDeclarationSpecificStructure, PropertyNamedNodeStructure, StaticableNodeStructure, DecoratableNodeStructure, AbstractableNodeStructure, ScopedNodeStructure, FunctionLikeDeclarationStructure, BodyableNodeStructure {\r\n}\r\n\r\ninterface SetAccessorDeclarationSpecificStructure {\r\n}\r\n\r\nexport interface DecoratorStructure {\r\n    name: string;\r\n    /**\r\n     * Arguments for a decorator factory.\r\n     * @remarks Provide an empty array to make the structure a decorator factory.\r\n     */\r\n    arguments?: (string | WriterFunction)[] | WriterFunction;\r\n    typeArguments?: string[];\r\n}\r\n\r\nexport interface JSDocStructure {\r\n    description: string | WriterFunction;\r\n}\r\n\r\nexport interface ExpressionedNodeStructure {\r\n    expression: string | WriterFunction;\r\n}\r\n\r\nexport interface PropertyAssignmentStructure extends PropertyAssignmentSpecificStructure, PropertyNamedNodeStructure {\r\n}\r\n\r\ninterface PropertyAssignmentSpecificStructure {\r\n    initializer: string | WriterFunction;\r\n}\r\n\r\nexport interface ShorthandPropertyAssignmentStructure extends ShorthandPropertyAssignmentSpecificStructure, NamedNodeStructure {\r\n}\r\n\r\ninterface ShorthandPropertyAssignmentSpecificStructure {\r\n}\r\n\r\nexport interface SpreadAssignmentStructure extends ExpressionedNodeStructure {\r\n}\r\n\r\nexport interface EnumDeclarationStructure extends NamedNodeStructure, EnumDeclarationSpecificStructure, JSDocableNodeStructure, AmbientableNodeStructure, ExportableNodeStructure {\r\n}\r\n\r\ninterface EnumDeclarationSpecificStructure {\r\n    isConst?: boolean;\r\n    members?: EnumMemberStructure[];\r\n}\r\n\r\nexport interface EnumMemberStructure extends EnumMemberSpecificStructure, PropertyNamedNodeStructure, JSDocableNodeStructure, InitializerExpressionableNodeStructure {\r\n}\r\n\r\ninterface EnumMemberSpecificStructure {\r\n    value?: number | string;\r\n}\r\n\r\nexport interface FunctionDeclarationStructure extends FunctionDeclarationSpecificStructure, NameableNodeStructure, FunctionLikeDeclarationStructure, StatementedNodeStructure, AsyncableNodeStructure, GeneratorableNodeStructure, AmbientableNodeStructure, ExportableNodeStructure, BodyableNodeStructure {\r\n}\r\n\r\ninterface FunctionDeclarationSpecificStructure {\r\n    overloads?: FunctionDeclarationOverloadStructure[];\r\n}\r\n\r\nexport interface FunctionDeclarationOverloadStructure extends SignaturedDeclarationStructure, TypeParameteredNodeStructure, JSDocableNodeStructure, AsyncableNodeStructure, GeneratorableNodeStructure, AmbientableNodeStructure, ExportableNodeStructure {\r\n}\r\n\r\nexport interface FunctionLikeDeclarationStructure extends SignaturedDeclarationStructure, TypeParameteredNodeStructure, JSDocableNodeStructure, StatementedNodeStructure {\r\n}\r\n\r\nexport interface ParameterDeclarationStructure extends DeclarationNamedNodeStructure, TypedNodeStructure, ReadonlyableNodeStructure, DecoratableNodeStructure, QuestionTokenableNodeStructure, ScopeableNodeStructure, InitializerExpressionableNodeStructure, ParameterDeclarationSpecificStructure {\r\n}\r\n\r\ninterface ParameterDeclarationSpecificStructure {\r\n    isRestParameter?: boolean;\r\n}\r\n\r\nexport interface CallSignatureDeclarationStructure extends CallSignatureDeclarationSpecificStructure, JSDocableNodeStructure, SignaturedDeclarationStructure, TypeParameteredNodeStructure {\r\n}\r\n\r\ninterface CallSignatureDeclarationSpecificStructure {\r\n}\r\n\r\nexport interface ConstructSignatureDeclarationStructure extends ConstructSignatureDeclarationSpecificStructure, JSDocableNodeStructure, SignaturedDeclarationStructure, TypeParameteredNodeStructure {\r\n}\r\n\r\ninterface ConstructSignatureDeclarationSpecificStructure {\r\n}\r\n\r\nexport interface IndexSignatureDeclarationStructure extends IndexSignatureDeclarationSpecificStructure, JSDocableNodeStructure, ReadonlyableNodeStructure, ReturnTypedNodeStructure {\r\n}\r\n\r\ninterface IndexSignatureDeclarationSpecificStructure {\r\n    keyName?: string;\r\n    keyType?: string;\r\n}\r\n\r\nexport interface InterfaceDeclarationStructure extends NamedNodeStructure, InterfaceDeclarationSpecificStructure, ExtendsClauseableNodeStructure, TypeParameteredNodeStructure, JSDocableNodeStructure, AmbientableNodeStructure, ExportableNodeStructure, TypeElementMemberedNodeStructure {\r\n}\r\n\r\ninterface InterfaceDeclarationSpecificStructure {\r\n}\r\n\r\nexport interface MethodSignatureStructure extends PropertyNamedNodeStructure, MethodSignatureSpecificStructure, QuestionTokenableNodeStructure, JSDocableNodeStructure, SignaturedDeclarationStructure, TypeParameteredNodeStructure {\r\n}\r\n\r\ninterface MethodSignatureSpecificStructure {\r\n}\r\n\r\nexport interface PropertySignatureStructure extends PropertySignatureSpecificStructure, PropertyNamedNodeStructure, TypedNodeStructure, QuestionTokenableNodeStructure, JSDocableNodeStructure, ReadonlyableNodeStructure, InitializerExpressionableNodeStructure {\r\n}\r\n\r\ninterface PropertySignatureSpecificStructure {\r\n}\r\n\r\nexport interface JsxAttributeStructure extends JsxAttributeSpecificStructure, NamedNodeStructure {\r\n}\r\n\r\ninterface JsxAttributeSpecificStructure {\r\n    isSpreadAttribute?: false;\r\n    initializer?: string;\r\n}\r\n\r\nexport interface JsxElementStructure {\r\n    name: string;\r\n    attributes?: (JsxAttributeStructure | JsxSpreadAttributeStructure)[];\r\n    isSelfClosing?: boolean;\r\n    children?: JsxElementStructure[];\r\n    bodyText?: string;\r\n}\r\nexport interface JsxSpreadAttributeStructure {\r\n    isSpreadAttribute: true;\r\n    expression: string;\r\n}\r\n\r\nexport interface ExportAssignmentStructure {\r\n    isExportEquals?: boolean;\r\n    expression: string | WriterFunction;\r\n}\r\n\r\nexport interface ExportDeclarationStructure {\r\n    namedExports?: (string | ExportSpecifierStructure | WriterFunction)[] | WriterFunction;\r\n    moduleSpecifier?: string;\r\n}\r\nexport interface ExportSpecifierStructure {\r\n    name: string;\r\n    alias?: string;\r\n}\r\n\r\nexport interface ImportDeclarationStructure {\r\n    defaultImport?: string;\r\n    namespaceImport?: string;\r\n    namedImports?: (ImportSpecifierStructure | string | WriterFunction)[] | WriterFunction;\r\n    moduleSpecifier: string;\r\n}\r\nexport interface ImportSpecifierStructure {\r\n    name: string;\r\n    alias?: string;\r\n}\r\n\r\nexport interface NamespaceDeclarationStructure extends NamedNodeStructure, NamespaceDeclarationSpecificStructure, JSDocableNodeStructure, AmbientableNodeStructure, ExportableNodeStructure, StatementedNodeStructure, BodiedNodeStructure, ModuledNodeStructure {\r\n}\r\n\r\ninterface NamespaceDeclarationSpecificStructure {\r\n    /**\r\n     * The namespace declaration kind.\r\n     *\r\n     * @remarks Defaults to \"namespace\".\r\n     */\r\n    declarationKind?: NamespaceDeclarationKind;\r\n}\r\n\r\nexport interface SourceFileStructure extends SourceFileSpecificStructure, StatementedNodeStructure, ModuledNodeStructure {\r\n    bodyText?: string | WriterFunction;\r\n}\r\n\r\ninterface SourceFileSpecificStructure {\r\n}\r\n\r\nexport interface StatementedNodeStructure {\r\n    classes?: ClassDeclarationStructure[];\r\n    enums?: EnumDeclarationStructure[];\r\n    functions?: FunctionDeclarationStructure[];\r\n    interfaces?: InterfaceDeclarationStructure[];\r\n    namespaces?: NamespaceDeclarationStructure[];\r\n    typeAliases?: TypeAliasDeclarationStructure[];\r\n}\r\n\r\nexport interface VariableDeclarationListStructure extends VariableDeclarationListSpecificStructure {\r\n}\r\n\r\ninterface VariableDeclarationListSpecificStructure {\r\n    declarationKind?: VariableDeclarationKind;\r\n    declarations: VariableDeclarationStructure[];\r\n}\r\n\r\nexport interface VariableDeclarationStructure extends VariableDeclarationSpecificStructure, BindingNamedNodeStructure, InitializerExpressionableNodeStructure, TypedNodeStructure, ExclamationTokenableNodeStructure {\r\n}\r\n\r\ninterface VariableDeclarationSpecificStructure {\r\n}\r\n\r\nexport interface VariableStatementStructure extends VariableStatementSpecificStructure, JSDocableNodeStructure, AmbientableNodeStructure, ExportableNodeStructure {\r\n}\r\n\r\ninterface VariableStatementSpecificStructure {\r\n    declarationKind?: VariableDeclarationKind;\r\n    declarations: VariableDeclarationStructure[];\r\n}\r\n\r\nexport interface TypeAliasDeclarationStructure extends TypeAliasDeclarationSpecificStructure, NamedNodeStructure, TypedNodeStructure, TypeParameteredNodeStructure, JSDocableNodeStructure, AmbientableNodeStructure, ExportableNodeStructure {\r\n    type: string | WriterFunction;\r\n}\r\n\r\ninterface TypeAliasDeclarationSpecificStructure {\r\n    type: string | WriterFunction;\r\n}\r\n\r\nexport interface TypeParameterDeclarationStructure extends TypeParameterDeclarationSpecificStructure, NamedNodeStructure {\r\n}\r\n\r\ninterface TypeParameterDeclarationSpecificStructure {\r\n    constraint?: string | WriterFunction;\r\n    default?: string | WriterFunction;\r\n}\r\n\r\nexport { ts, SyntaxKind, CompilerOptions, EmitHint, ScriptKind, NewLineKind, LanguageVariant, ScriptTarget, TypeFlags, ObjectFlags, SymbolFlags, TypeFormatFlags, DiagnosticCategory, EditorSettings, ModuleResolutionKind };\r\nexport * from \"./code-block-writer\";\r\n\r\n/** @deprecated Use the named export \"Project\" */\r\nexport default Project;\r\n"
